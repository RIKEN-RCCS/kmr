<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KMR: src/kmrmapms.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KMR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">kmrmapms.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Master-Worker Mapping on Key-Value Stream.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;mpi.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;poll.h&gt;</code><br />
<code>#include &lt;netdb.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;sys/wait.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
<code>#include &lt;sys/param.h&gt;</code><br />
<code>#include &lt;arpa/inet.h&gt;</code><br />
<code>#include &lt;sys/mman.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;<a class="el" href="kmr_8h_source.html">kmr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="kmrimpl_8h_source.html">kmrimpl.h</a>&quot;</code><br />
</div>
<p><a href="kmrmapms_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__map__ms__commands__argument.html">kmr_map_ms_commands_argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__spawn__state.html">kmr_spawn_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of each Spawning.  <a href="structkmr__spawn__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__spawning.html">kmr_spawning</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of Spawner.  <a href="structkmr__spawning.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a69c30d0c97b90070c98a4262553f2656"><td class="memItemLeft" align="right" valign="top"><a id="a69c30d0c97b90070c98a4262553f2656"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_RPC_ID_FIN</b>&#160;&#160;&#160;-2</td></tr>
<tr class="separator:a69c30d0c97b90070c98a4262553f2656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f55b0683f1713930762a07114f41af9"><td class="memItemLeft" align="right" valign="top"><a id="a6f55b0683f1713930762a07114f41af9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_RPC_ID_NONE</b>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:a6f55b0683f1713930762a07114f41af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memItemLeft" align="right" valign="top"><a id="afa99ec4acc4ecb2dc3c2d05da15d0e3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX</b>(a,  b)&#160;&#160;&#160;(((a)&gt;(b))?(a):(b))</td></tr>
<tr class="separator:afa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acffbd305ee72dcd4593c0d8af64a4f"><td class="memItemLeft" align="right" valign="top"><a id="a3acffbd305ee72dcd4593c0d8af64a4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIN</b>(a,  b)&#160;&#160;&#160;(((a)&lt;(b))?(a):(b))</td></tr>
<tr class="separator:a3acffbd305ee72dcd4593c0d8af64a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a61dadd085c1777f559549e05962b2c9e"><td class="memItemLeft" align="right" valign="top"><a id="a61dadd085c1777f559549e05962b2c9e"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>KMR_RPC_NONE</b>, 
<b>KMR_RPC_GOON</b>, 
<b>KMR_RPC_DONE</b>
 }</td></tr>
<tr class="separator:a61dadd085c1777f559549e05962b2c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49828019ad9a722a5d69fe26be8e73b5"><td class="memItemLeft" align="right" valign="top"><a id="a49828019ad9a722a5d69fe26be8e73b5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>kmr_spawn_mode</b> { <b>KMR_SPAWN_INTERACT</b>, 
<b>KMR_SPAWN_SERIAL</b>, 
<b>KMR_SPAWN_PARALLEL</b>
 }</td></tr>
<tr class="separator:a49828019ad9a722a5d69fe26be8e73b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3048516f440aae1b72978d4de807a3c0"><td class="memItemLeft" align="right" valign="top"><a id="a3048516f440aae1b72978d4de807a3c0"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_accept_on_watch</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__spawning.html">kmr_spawning</a> *spw, int index)</td></tr>
<tr class="separator:a3048516f440aae1b72978d4de807a3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4affed93e72e3eb5cd339305fe814b0b"><td class="memItemLeft" align="right" valign="top"><a id="a4affed93e72e3eb5cd339305fe814b0b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_assert_peer_tag</b> (int tag)</td></tr>
<tr class="separator:a4affed93e72e3eb5cd339305fe814b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff55a0dfef42007f1121baaeb6da22f4"><td class="memItemLeft" align="right" valign="top"><a id="aff55a0dfef42007f1121baaeb6da22f4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_check_exec__</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr)</td></tr>
<tr class="separator:aff55a0dfef42007f1121baaeb6da22f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4f8d7c1626c74f22957fb64fa6e0f8"><td class="memItemLeft" align="right" valign="top"><a id="a1f4f8d7c1626c74f22957fb64fa6e0f8"></a>
<a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_create_dummy_context</b> (void)</td></tr>
<tr class="separator:a1f4f8d7c1626c74f22957fb64fa6e0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9525abafb4204640c2d7086c02eba4bf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#a9525abafb4204640c2d7086c02eba4bf">kmr_exec_command</a> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, const long index)</td></tr>
<tr class="memdesc:a9525abafb4204640c2d7086c02eba4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs commands in <a class="el" href="kmrmapms_8c.html#a4f8a223da5a75d698ca59279bf1c7384" title="Maps in the master-worker mode, specialized to run serial commands. ">kmr_map_ms_commands()</a>.  <a href="#a9525abafb4204640c2d7086c02eba4bf">More...</a><br /></td></tr>
<tr class="separator:a9525abafb4204640c2d7086c02eba4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c88c269206504a62b5ec33e987a2698"><td class="memItemLeft" align="right" valign="top"><a id="a3c88c269206504a62b5ec33e987a2698"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_exec_command_e</b> (_Bool use_exec, const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, const long index)</td></tr>
<tr class="separator:a3c88c269206504a62b5ec33e987a2698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0cec94609f88dcf28ac66b4f459205"><td class="memItemLeft" align="right" valign="top"><a id="a3a0cec94609f88dcf28ac66b4f459205"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_free_comm_with_tracing</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__spawning.html">kmr_spawning</a> *spw, struct <a class="el" href="structkmr__spawn__state.html">kmr_spawn_state</a> *s)</td></tr>
<tr class="separator:a3a0cec94609f88dcf28ac66b4f459205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47d401153aa4f75bc990384d9e78e74"><td class="memItemLeft" align="right" valign="top">MPI_Comm *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#ae47d401153aa4f75bc990384d9e78e74">kmr_get_spawner_communicator</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, long index)</td></tr>
<tr class="memdesc:ae47d401153aa4f75bc990384d9e78e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains (a reference to) a parent inter-communicator of a spawned process.  <a href="#ae47d401153aa4f75bc990384d9e78e74">More...</a><br /></td></tr>
<tr class="separator:ae47d401153aa4f75bc990384d9e78e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55f983c105e4d2a760812ce20efd428"><td class="memItemLeft" align="right" valign="top"><a id="ad55f983c105e4d2a760812ce20efd428"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_get_spawner_communicator_ff</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, long ii, int *comm)</td></tr>
<tr class="separator:ad55f983c105e4d2a760812ce20efd428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720ddc11ebf127853ac29d807d0be41a"><td class="memItemLeft" align="right" valign="top"><a id="a720ddc11ebf127853ac29d807d0be41a"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_list_spawns</b> (struct <a class="el" href="structkmr__spawning.html">kmr_spawning</a> *spw, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, MPI_Info info, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt)</td></tr>
<tr class="separator:a720ddc11ebf127853ac29d807d0be41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e97f416cbe863872a64d3d012eb196"><td class="memItemLeft" align="right" valign="top"><a id="a47e97f416cbe863872a64d3d012eb196"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_listen_to_watch</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__spawning.html">kmr_spawning</a> *spw, int index)</td></tr>
<tr class="separator:a47e97f416cbe863872a64d3d012eb196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff078da0b876241e88cc84e4ab58977"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#abff078da0b876241e88cc84e4ab58977">kmr_map_master</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:abff078da0b876241e88cc84e4ab58977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delivers key-value pairs as requested.  <a href="#abff078da0b876241e88cc84e4ab58977">More...</a><br /></td></tr>
<tr class="separator:abff078da0b876241e88cc84e4ab58977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d52c3c69250bf19dd28d5e38809df79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#a9d52c3c69250bf19dd28d5e38809df79">kmr_map_ms</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:a9d52c3c69250bf19dd28d5e38809df79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps in master-worker mode.  <a href="#a9d52c3c69250bf19dd28d5e38809df79">More...</a><br /></td></tr>
<tr class="separator:a9d52c3c69250bf19dd28d5e38809df79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8a223da5a75d698ca59279bf1c7384"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#a4f8a223da5a75d698ca59279bf1c7384">kmr_map_ms_commands</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> sopt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:a4f8a223da5a75d698ca59279bf1c7384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps in the master-worker mode, specialized to run serial commands.  <a href="#a4f8a223da5a75d698ca59279bf1c7384">More...</a><br /></td></tr>
<tr class="separator:a4f8a223da5a75d698ca59279bf1c7384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309f2ef87bc5f4ec67d53a446cbb392e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#a309f2ef87bc5f4ec67d53a446cbb392e">kmr_map_parallel_processes</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, MPI_Info info, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> mapfn)</td></tr>
<tr class="memdesc:a309f2ef87bc5f4ec67d53a446cbb392e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not communicate to the parent.  <a href="#a309f2ef87bc5f4ec67d53a446cbb392e">More...</a><br /></td></tr>
<tr class="separator:a309f2ef87bc5f4ec67d53a446cbb392e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ea39208f60d2f6ba895cafa0302a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#a5b8ea39208f60d2f6ba895cafa0302a2">kmr_map_processes</a> (_Bool nonmpi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, MPI_Info info, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> mapfn)</td></tr>
<tr class="memdesc:a5b8ea39208f60d2f6ba895cafa0302a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps on processes started by MPI_Comm_spawn() to run independent processes.  <a href="#a5b8ea39208f60d2f6ba895cafa0302a2">More...</a><br /></td></tr>
<tr class="separator:a5b8ea39208f60d2f6ba895cafa0302a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5120d3c93ea5a471ab040f94dbd29a41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#a5120d3c93ea5a471ab040f94dbd29a41">kmr_map_serial_processes</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, MPI_Info info, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> mapfn)</td></tr>
<tr class="memdesc:a5120d3c93ea5a471ab040f94dbd29a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps on processes started by MPI_Comm_spawn() to run serial processes.  <a href="#a5120d3c93ea5a471ab040f94dbd29a41">More...</a><br /></td></tr>
<tr class="separator:a5120d3c93ea5a471ab040f94dbd29a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6741cc4eb46526512e43c99cf3aafc"><td class="memItemLeft" align="right" valign="top"><a id="a4e6741cc4eb46526512e43c99cf3aafc"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_map_spawned_processes</b> (enum kmr_spawn_mode mode, char *name, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, MPI_Info info, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> mapfn)</td></tr>
<tr class="separator:a4e6741cc4eb46526512e43c99cf3aafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2502be0968e7f62404e02f8f445c7498"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498">kmr_map_via_spawn</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, MPI_Info info, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> mapfn)</td></tr>
<tr class="memdesc:a2502be0968e7f62404e02f8f445c7498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps on processes started by MPI_Comm_spawn().  <a href="#a2502be0968e7f62404e02f8f445c7498">More...</a><br /></td></tr>
<tr class="separator:a2502be0968e7f62404e02f8f445c7498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6a69891fa608de50c1c732e2eaa74f"><td class="memItemLeft" align="right" valign="top"><a id="a8a6a69891fa608de50c1c732e2eaa74f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_map_via_spawn_ff</b> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, int finfo, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> mapfn)</td></tr>
<tr class="separator:a8a6a69891fa608de50c1c732e2eaa74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fcf482f94b2d1b18e55a79bd7378a1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#a66fcf482f94b2d1b18e55a79bd7378a1">kmr_map_worker</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:a66fcf482f94b2d1b18e55a79bd7378a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks the master for a task, then calls a map-function.  <a href="#a66fcf482f94b2d1b18e55a79bd7378a1">More...</a><br /></td></tr>
<tr class="separator:a66fcf482f94b2d1b18e55a79bd7378a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472651fc6d5cf770cb947909013a3d43"><td class="memItemLeft" align="right" valign="top"><a id="a472651fc6d5cf770cb947909013a3d43"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_receive_for_reply</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__spawning.html">kmr_spawning</a> *spw, int w, _Bool replyeach, _Bool replyroot)</td></tr>
<tr class="separator:a472651fc6d5cf770cb947909013a3d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e4b71fc1aa9386021576dd9c186b85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#a98e4b71fc1aa9386021576dd9c186b85">kmr_receive_kvs_from_spawned_fn</a> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, const long index)</td></tr>
<tr class="memdesc:a98e4b71fc1aa9386021576dd9c186b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects key-value pairs generated by spawned processes.  <a href="#a98e4b71fc1aa9386021576dd9c186b85">More...</a><br /></td></tr>
<tr class="separator:a98e4b71fc1aa9386021576dd9c186b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b0a9f5e3679c03c283c97f99cfed59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#ae6b0a9f5e3679c03c283c97f99cfed59">kmr_reply_to_spawner</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr)</td></tr>
<tr class="memdesc:ae6b0a9f5e3679c03c283c97f99cfed59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a reply message in the spawned process, which tells it is ready to finish and may have some data to send to the spawner in <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a>.  <a href="#ae6b0a9f5e3679c03c283c97f99cfed59">More...</a><br /></td></tr>
<tr class="separator:ae6b0a9f5e3679c03c283c97f99cfed59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f2e46ad4e40fb0f7140ffbf6da58e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmapms_8c.html#a14f2e46ad4e40fb0f7140ffbf6da58e7">kmr_send_kvs_to_spawner</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs)</td></tr>
<tr class="memdesc:a14f2e46ad4e40fb0f7140ffbf6da58e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the KVS from a spawned process to the map-function of the spawner.  <a href="#a14f2e46ad4e40fb0f7140ffbf6da58e7">More...</a><br /></td></tr>
<tr class="separator:a14f2e46ad4e40fb0f7140ffbf6da58e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf75f5294ffa38b28a4dbfd0740c9877"><td class="memItemLeft" align="right" valign="top"><a id="aaf75f5294ffa38b28a4dbfd0740c9877"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_spawn_info_get</b> (struct <a class="el" href="structkmr__spawn__info.html">kmr_spawn_info</a> *info, struct <a class="el" href="structkmr__spawn__state.html">kmr_spawn_state</a> *s)</td></tr>
<tr class="separator:aaf75f5294ffa38b28a4dbfd0740c9877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af516e9912e6fd47a2839febdef661a5a"><td class="memItemLeft" align="right" valign="top"><a id="af516e9912e6fd47a2839febdef661a5a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_spawn_info_put</b> (struct <a class="el" href="structkmr__spawn__info.html">kmr_spawn_info</a> *info, struct <a class="el" href="structkmr__spawn__state.html">kmr_spawn_state</a> *s, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, void *arg)</td></tr>
<tr class="separator:af516e9912e6fd47a2839febdef661a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae931332b9f0218db74496591c0672750"><td class="memItemLeft" align="right" valign="top"><a id="ae931332b9f0218db74496591c0672750"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_sum_on_all_ranks</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, int v, int *sum)</td></tr>
<tr class="separator:ae931332b9f0218db74496591c0672750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a0109a80c03597ff8d085cc78fe901"><td class="memItemLeft" align="right" valign="top"><a id="ac0a0109a80c03597ff8d085cc78fe901"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_wait_for_reply</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__spawning.html">kmr_spawning</a> *spw, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt)</td></tr>
<tr class="separator:ac0a0109a80c03597ff8d085cc78fe901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcb7c1aaa6571c41e364a812fc9176c"><td class="memItemLeft" align="right" valign="top"><a id="a6dcb7c1aaa6571c41e364a812fc9176c"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_wait_for_watch</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__spawning.html">kmr_spawning</a> *spw, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> _)</td></tr>
<tr class="separator:a6dcb7c1aaa6571c41e364a812fc9176c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ce0b43c420c140556e808e1816218f"><td class="memItemLeft" align="right" valign="top"><a id="a61ce0b43c420c140556e808e1816218f"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_wait_then_map</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__spawning.html">kmr_spawning</a> *spw, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="separator:a61ce0b43c420c140556e808e1816218f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a43bc75951f7d3db36ae025524da0326c"><td class="memItemLeft" align="right" valign="top"><a id="a43bc75951f7d3db36ae025524da0326c"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_kv_buffer_slack_size</b> = 1024</td></tr>
<tr class="separator:a43bc75951f7d3db36ae025524da0326c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Master-Worker Mapping on Key-Value Stream. </p>

<p class="definition">Definition in file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="abff078da0b876241e88cc84e4ab58977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff078da0b876241e88cc84e4ab58977">&#9670;&nbsp;</a></span>kmr_map_master()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int kmr_map_master </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delivers key-value pairs as requested. </p>
<p>It returns MPI_SUCCESS if all done, or MPI_ERR_ROOT otherwise. It finishes the tasks when all nodes have contacted and all worker threads are done. Protocol: (1) Receive an RPC request (KMR_TAG_REQ). A request consists of a triple of integers (task-ID, peer-tag, result-size) ("int req[3]"). The task-ID encodes some special values. (2) Receive a result if a worker has one. (3) Return a new task if available. A reply consists of a tuple of integers (task-ID, argument-size) ("int ack[2]"). (4) Or, return a "no-tasks" indicator by ID=KMR_RPC_ID_NONE. (5) <a class="el" href="structCount.html">Count</a> "done" messages by ID=KMR_RPC_ID_FIN, which indicates the worker node has finished for all worker threads. The task-ID in an RPC request is KMR_RPC_ID_NONE for the first request (meaning that the request has no result). Peer-tags are used in subsequent messages to direct reply messages to a requesting thread. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l00072">72</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a66fcf482f94b2d1b18e55a79bd7378a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fcf482f94b2d1b18e55a79bd7378a1">&#9670;&nbsp;</a></span>kmr_map_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int kmr_map_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asks the master for a task, then calls a map-function. </p>
<p>With threading, each thread works independently asking the master for a task. It simply protects MPI send/recv calls by OMP critical sections, but their grain sizes are too large for uses of OMP critical sections. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l00222">222</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a9d52c3c69250bf19dd28d5e38809df79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d52c3c69250bf19dd28d5e38809df79">&#9670;&nbsp;</a></span>kmr_map_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps in master-worker mode. </p>
<p>The input key-value stream should be empty except on rank0 where the master is running (the contents on the worker ranks are ignored). It consumes the input key-value stream. The master does delivery only. The master returns frequently to give a chance to check-pointing, etc. The master returns immaturely each time one pair is delivered, and those returns are marked by MPI_ERR_ROOT indicating more tasks remain. In contrast, workers return only after all tasks done. The enough state to have to keep during <a class="el" href="kmrmapms_8c.html#a9d52c3c69250bf19dd28d5e38809df79" title="Maps in master-worker mode. ">kmr_map_ms()</a> for check-pointing is in the key-value streams KVI and KVO on the master. Note that this totally diverges from bulk-synchronous execution. It does not accept key-value field types KMR_KV_POINTER_OWNED or KMR_KV_POINTER_UNMANAGED. Effective-options: NOTHREADING, KEEP_OPEN. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l00344">344</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="ae6b0a9f5e3679c03c283c97f99cfed59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b0a9f5e3679c03c283c97f99cfed59">&#9670;&nbsp;</a></span>kmr_reply_to_spawner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_reply_to_spawner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a reply message in the spawned process, which tells it is ready to finish and may have some data to send to the spawner in <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l01893">1893</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="ae47d401153aa4f75bc990384d9e78e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47d401153aa4f75bc990384d9e78e74">&#9670;&nbsp;</a></span>kmr_get_spawner_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm* kmr_get_spawner_communicator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains (a reference to) a parent inter-communicator of a spawned process. </p>
<p>It is used inside a map-function of <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a>; Pass INDEX the same argument to a map-function. It returns a reference for the side-effect of freeing a communicator in a map-function. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l01916">1916</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a2502be0968e7f62404e02f8f445c7498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2502be0968e7f62404e02f8f445c7498">&#9670;&nbsp;</a></span>kmr_map_via_spawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_via_spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Info&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>mapfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps on processes started by MPI_Comm_spawn(). </p>
<p>It is intended to run custom MPI programs which will return a reply as MPI messages. Consider other variations to run independent processes, when the spawned processes will not interact with the parent: <a class="el" href="kmrmapms_8c.html#a5120d3c93ea5a471ab040f94dbd29a41" title="Maps on processes started by MPI_Comm_spawn() to run serial processes. ">kmr_map_serial_processes()</a>, <a class="el" href="kmrmapms_8c.html#a309f2ef87bc5f4ec67d53a446cbb392e" title="Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not commun...">kmr_map_parallel_processes()</a>, or <a class="el" href="kmrmapms_8c.html#a4f8a223da5a75d698ca59279bf1c7384" title="Maps in the master-worker mode, specialized to run serial commands. ">kmr_map_ms_commands()</a>.<br />
 A spawner (parent) spawns processes specified by key-value pairs. The key part is ignored, and the value part is a list of null-separated strings which constitutes a command and arguments. The option SEPARATOR_SPACE changes the separator character to whitespaces. If the first string is "maxprocs=n", then the number of processes is taken from this string. Or, an MPI_Info entry "maxprocs" in INFO is used, in which case "maxprocs" is common to all spawns. It is an error if neither is specified. A spawner tries to control the simultaneously running processes limited to the number of processes in the universe. When multiple spawners are active (more than one ranks have the entries to spawn), they divide the universe evenly among them.<br />
 The option REPLY_EACH or REPLY_ROOT lets a spawner wait for reply messages from the spawned processes, and then the spawner calls a map-function. A reply message is of the tag KMR_TAG_SPAWN_REPLY=500 and length zero, and <a class="el" href="kmrmapms_8c.html#ae6b0a9f5e3679c03c283c97f99cfed59" title="Sends a reply message in the spawned process, which tells it is ready to finish and may have some dat...">kmr_reply_to_spawner()</a> can be used to send this reply. When none of REPLY_EACH or REPLY_ROOT are specified, the spawner immediately calls a map-function one-by-one in the FIFO order (before the spawned processes finish). In that case, no load-balance is taken. Thus, the map-function should wait for the spawned processes to finish, otherwise, a spawner starts next spawns continuously and runs out the processes, which causes the MPI runtime to signal an error.<br />
 Communication between the spawned processes and a map-function of a spawner is through an inter-communicator. The parent inter-communicator of the spawned processes can be taken by MPI_Comm_get_parent() as usual. The inter-communicator at the spawner side can be obtained by calling <a class="el" href="kmrmapms_8c.html#ae47d401153aa4f75bc990384d9e78e74" title="Obtains (a reference to) a parent inter-communicator of a spawned process. ">kmr_get_spawner_communicator()</a> inside a map-function.<br />
 The INFO argument is passed to MPI_Comm_spawn() after inserting the entries which appear in the command line, when the command line has prefixes of the form "key=value". Insertion of the prefixes can be terminated by an empty entry "=". Use of info is discouraged, because it is not portable and may contradicts to the implicit assumption of the KMR implementation.<br />
 NOTE: There is no way to check the availability of processes for spawning in the MPI specification and MPI implementations. And, the MPI runtime signals errors when it runs out the processes. Thus, it puts a sleep (1 sec) in between MPI_Comm_spawn() calls to allow clean-ups in the MPI runtime and to avoid timing issues.<br />
 INTERFACE CHANGE: Set mr-&gt;spawn_pass_intercomm_in_argument=1 to enables the old interface, where the map-function MAPFN is called with the <a class="el" href="structkmr__spawn__state.html" title="State of each Spawning. ">kmr_spawn_state</a> structure as the general argument. The argument ARG passed to the mapper is stored in the MAPARG slot in the <a class="el" href="structkmr__spawn__state.html" title="State of each Spawning. ">kmr_spawn_state</a> structure. When TAKE_CKPT option is specified, a checkpoint data file of the output key-value stream is saved if both CKPT_ENABLE and CKPT_SELECTIVE global options are set. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l01992">1992</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a309f2ef87bc5f4ec67d53a446cbb392e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309f2ef87bc5f4ec67d53a446cbb392e">&#9670;&nbsp;</a></span>kmr_map_parallel_processes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_parallel_processes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Info&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>mapfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not communicate to the parent. </p>
<p>The programs need to be MPI. It is a variation of <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a>, and refer to the comments on it for the basic usage. Since the spawned program does not know the parent, there is no way to communicate from the spawner. The map-function is called after the processes have exited, so that the map-function can check the result files created by the spawned processes.<br />
This function detects the end of spawned processes using a watch-program "kmrwatch0", by checking a closure of a socket to which "kmrwatch0" connected.<br />
 NOTE THAT THIS OPERATION WILL BLOCK INDEFINITELY AND FAIL, DEPENDING ON THE BEHAVIOR OF AN MPI IMPLEMENTATION. It is checked to work with Open MPI (1.6) and MPICH2 (1.5), but not with Intel MPI (4.1) and YAMPI2 (GridMPI 2.1). It depends on the behavior that MPI_Comm_free() on the parent and MPI_Finalize() on the child do not synchronize. The quote of the standard (MPI 2.x) says: "Though collective, MPI_Comm_free is anticipated that this operation will normally be implemented to be local, ..." The blocking situation can be checked by enabling tracing around calls to MPI_Comm_free() by (mr-&gt;trace_map_spawn=1).<br />
 NOTE (on MPI spawn implementations): Open MPI (1.6) allows to spawn non-MPI processes by passing an special MPI_Info. MPICH2 (1.5) does not allow to spawn non-MPI processes, because MPI_Comm_spawn() of the parent and MPI_Init() of the child synchronize. In Intel MPI (4.1) and YAMPI2 (GridMPI), the calls of MPI_Comm_free() on the parent and MPI_Finalize() or MPI_Comm_free() on the child synchronize, and thus, they require to call MPI_Comm_free() at an appropriate time on the parent.<br />
 Options REPLY_ROOT and REPLY_EACH have no effect. When TAKE_CKPT option is specified, a checkpoint data file of the output key-value stream is saved if both CKPT_ENABLE and CKPT_SELECTIVE global options are set. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02037">2037</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a5120d3c93ea5a471ab040f94dbd29a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5120d3c93ea5a471ab040f94dbd29a41">&#9670;&nbsp;</a></span>kmr_map_serial_processes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_serial_processes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Info&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>mapfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps on processes started by MPI_Comm_spawn() to run serial processes. </p>
<p>This should NOT be used; Use <a class="el" href="kmrmapms_8c.html#a4f8a223da5a75d698ca59279bf1c7384" title="Maps in the master-worker mode, specialized to run serial commands. ">kmr_map_ms_commands()</a>, instead. Fork-execing in <a class="el" href="kmrmapms_8c.html#a4f8a223da5a75d698ca59279bf1c7384" title="Maps in the master-worker mode, specialized to run serial commands. ">kmr_map_ms_commands()</a> is simpler than spawning. See also the comments on <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a> and <a class="el" href="kmrmapms_8c.html#a309f2ef87bc5f4ec67d53a446cbb392e" title="Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not commun...">kmr_map_parallel_processes()</a>. The map-function is called after the processes have exited, thus, there is no way to communicate from the map-function. Instead, the map-function can check the result files created by the spawned processes.<br />
 This function detects the end of spawned processes using a watch-program "kmrwatch0" which sends a reply to the parent in place of the serial program. Options REPLY_ROOT and REPLY_EACH have no effect. When TAKE_CKPT option is specified, a checkpoint data file of the output key-value stream is saved if both CKPT_ENABLE and CKPT_SELECTIVE global options are set. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02067">2067</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a5b8ea39208f60d2f6ba895cafa0302a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8ea39208f60d2f6ba895cafa0302a2">&#9670;&nbsp;</a></span>kmr_map_processes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_processes </td>
          <td>(</td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>nonmpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Info&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>mapfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps on processes started by MPI_Comm_spawn() to run independent processes. </p>
<p>It either calls <a class="el" href="kmrmapms_8c.html#a309f2ef87bc5f4ec67d53a446cbb392e" title="Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not commun...">kmr_map_parallel_processes()</a> or <a class="el" href="kmrmapms_8c.html#a5120d3c93ea5a471ab040f94dbd29a41" title="Maps on processes started by MPI_Comm_spawn() to run serial processes. ">kmr_map_serial_processes()</a> with regard to the NONMPI argument. See the comments of <a class="el" href="kmrmapms_8c.html#a309f2ef87bc5f4ec67d53a446cbb392e" title="Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not commun...">kmr_map_parallel_processes()</a> and <a class="el" href="kmrmapms_8c.html#a5120d3c93ea5a471ab040f94dbd29a41" title="Maps on processes started by MPI_Comm_spawn() to run serial processes. ">kmr_map_serial_processes()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02087">2087</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a14f2e46ad4e40fb0f7140ffbf6da58e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f2e46ad4e40fb0f7140ffbf6da58e7">&#9670;&nbsp;</a></span>kmr_send_kvs_to_spawner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_send_kvs_to_spawner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the KVS from a spawned process to the map-function of the spawner. </p>
<p>It is paired with <a class="el" href="kmrmapms_8c.html#a98e4b71fc1aa9386021576dd9c186b85" title="Collects key-value pairs generated by spawned processes. ">kmr_receive_kvs_from_spawned_fn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02127">2127</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a98e4b71fc1aa9386021576dd9c186b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e4b71fc1aa9386021576dd9c186b85">&#9670;&nbsp;</a></span>kmr_receive_kvs_from_spawned_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_receive_kvs_from_spawned_fn </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>kv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects key-value pairs generated by spawned processes. </p>
<p>It is a map-function to be used with <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a> with the REPLY_EACH option. The spawned processes call <a class="el" href="kmrmapms_8c.html#a14f2e46ad4e40fb0f7140ffbf6da58e7" title="Sends the KVS from a spawned process to the map-function of the spawner. ">kmr_send_kvs_to_spawner()</a> to send generated key-value pairs, and this function receives and puts them into KVO. PROTOCOL: The reply consists of one or two messages with the tag KMR_TAG_SPAWN_REPLY1=501. One is the data size, which is followed by a marshaled key-value stream when the data size is non-zero. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02161">2161</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a9525abafb4204640c2d7086c02eba4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9525abafb4204640c2d7086c02eba4bf">&#9670;&nbsp;</a></span>kmr_exec_command()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int kmr_exec_command </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>kv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs commands in <a class="el" href="kmrmapms_8c.html#a4f8a223da5a75d698ca59279bf1c7384" title="Maps in the master-worker mode, specialized to run serial commands. ">kmr_map_ms_commands()</a>. </p>
<p>It has system(3C) and fork-exec variants. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02394">2394</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a4f8a223da5a75d698ca59279bf1c7384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8a223da5a75d698ca59279bf1c7384">&#9670;&nbsp;</a></span>kmr_map_ms_commands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_ms_commands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td>
          <td class="paramname"><em>sopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps in the master-worker mode, specialized to run serial commands. </p>
<p>It executes a command specified by a key-value, then calls a map-function at finishes of the command. It takes the commands in the same way as <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a>. The commands never be MPI programs. It uses system(3C) or fork-exec, switching to fork-exec either when the SEPARATOR_SPACE option is specified, a command string includes null characters, or the MAP_MS_USE_EXEC option to KMR is specified. It is implemented with <a class="el" href="kmrmapms_8c.html#a9d52c3c69250bf19dd28d5e38809df79" title="Maps in master-worker mode. ">kmr_map_ms()</a>; see the comments on <a class="el" href="kmrmapms_8c.html#a9d52c3c69250bf19dd28d5e38809df79" title="Maps in master-worker mode. ">kmr_map_ms()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02432">2432</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
