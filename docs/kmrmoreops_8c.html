<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KMR: src/kmrmoreops.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KMR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">kmrmoreops.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>More Operatons on Key-Value Stream.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;mpi.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;<a class="el" href="kmr_8h_source.html">kmr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="kmrimpl_8h_source.html">kmrimpl.h</a>&quot;</code><br />
</div>
<p><a href="kmrmoreops_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__ranking__to__rank.html">kmr_ranking_to_rank</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memItemLeft" align="right" valign="top"><a id="afa99ec4acc4ecb2dc3c2d05da15d0e3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX</b>(a,  b)&#160;&#160;&#160;(((a)&gt;(b))?(a):(b))</td></tr>
<tr class="separator:afa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acffbd305ee72dcd4593c0d8af64a4f"><td class="memItemLeft" align="right" valign="top"><a id="a3acffbd305ee72dcd4593c0d8af64a4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIN</b>(a,  b)&#160;&#160;&#160;(((a)&lt;(b))?(a):(b))</td></tr>
<tr class="separator:a3acffbd305ee72dcd4593c0d8af64a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bed939fad7f0180a5ca46b47450f28c"><td class="memItemLeft" align="right" valign="top"><a id="a8bed939fad7f0180a5ca46b47450f28c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NEVERHERE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a8bed939fad7f0180a5ca46b47450f28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1292ef72b8ba6ed975e96887404d1281"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a1292ef72b8ba6ed975e96887404d1281">kmr_add_ntuple</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *k, int klen, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u)</td></tr>
<tr class="memdesc:a1292ef72b8ba6ed975e96887404d1281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an n-tuple U with a given key K and KLEN in a key-value stream KVO.  <a href="#a1292ef72b8ba6ed975e96887404d1281">More...</a><br /></td></tr>
<tr class="separator:a1292ef72b8ba6ed975e96887404d1281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8e9a60b42fbed1aa7b9452c073d38b"><td class="memItemLeft" align="right" valign="top"><a id="a4b8e9a60b42fbed1aa7b9452c073d38b"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_add_pairing_under_key</b> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, int klen, union <a class="el" href="unionkmr__unit__sized.html">kmr_unit_sized</a> k, const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a> keyf, enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a> valf)</td></tr>
<tr class="separator:a4b8e9a60b42fbed1aa7b9452c073d38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00f09bbba752958cd1036ceb0aa5aad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#af00f09bbba752958cd1036ceb0aa5aad">kmr_choose_first_part</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, long n, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:af00f09bbba752958cd1036ceb0aa5aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses the first N entries from a key-value stream KVI.  <a href="#af00f09bbba752958cd1036ceb0aa5aad">More...</a><br /></td></tr>
<tr class="separator:af00f09bbba752958cd1036ceb0aa5aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94f22043b17c904d76dd4a85adce4b3"><td class="memItemLeft" align="right" valign="top"><a id="af94f22043b17c904d76dd4a85adce4b3"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_count_key_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv[], const long n, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p)</td></tr>
<tr class="separator:af94f22043b17c904d76dd4a85adce4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3bd276b046cca0644a0dd56f0b81fb"><td class="memItemLeft" align="right" valign="top"><a id="a6f3bd276b046cca0644a0dd56f0b81fb"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_count_keys</b> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo)</td></tr>
<tr class="separator:a6f3bd276b046cca0644a0dd56f0b81fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058890c9ef6689deacfd9eda9d25e513"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a058890c9ef6689deacfd9eda9d25e513">kmr_distribute</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, _Bool cyclic, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a058890c9ef6689deacfd9eda9d25e513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes key-values so that each rank has approximately the same number of pairs.  <a href="#a058890c9ef6689deacfd9eda9d25e513">More...</a><br /></td></tr>
<tr class="separator:a058890c9ef6689deacfd9eda9d25e513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e91769570ad3a791b0f8810bfafdfdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a6e91769570ad3a791b0f8810bfafdfdc">kmr_find_key</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> ki, struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> *ko)</td></tr>
<tr class="memdesc:a6e91769570ad3a791b0f8810bfafdfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a key-value pair for a key.  <a href="#a6e91769570ad3a791b0f8810bfafdfdc">More...</a><br /></td></tr>
<tr class="separator:a6e91769570ad3a791b0f8810bfafdfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990b6b5fb3b14deff589b13b97c146ad"><td class="memItemLeft" align="right" valign="top"><a id="a990b6b5fb3b14deff589b13b97c146ad"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_find_key_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:a990b6b5fb3b14deff589b13b97c146ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6134d913ad359d56c789a99fb668a0d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a6134d913ad359d56c789a99fb668a0d3">kmr_find_string</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, const char *k, const char **vq)</td></tr>
<tr class="memdesc:a6134d913ad359d56c789a99fb668a0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key K in the key-value stream KVS.  <a href="#a6134d913ad359d56c789a99fb668a0d3">More...</a><br /></td></tr>
<tr class="separator:a6134d913ad359d56c789a99fb668a0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5cf7099c266d60efecbe56ee47f5b6"><td class="memItemLeft" align="right" valign="top"><a id="abe5cf7099c266d60efecbe56ee47f5b6"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_first_n_elements_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:abe5cf7099c266d60efecbe56ee47f5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161eaf42b3fb2855b6186ccf41fc72ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a161eaf42b3fb2855b6186ccf41fc72ab">kmr_get_element_count</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, long *v)</td></tr>
<tr class="memdesc:a161eaf42b3fb2855b6186ccf41fc72ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of key-value pairs.  <a href="#a161eaf42b3fb2855b6186ccf41fc72ab">More...</a><br /></td></tr>
<tr class="separator:a161eaf42b3fb2855b6186ccf41fc72ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1295017905f68cd551d510b5b92340"><td class="memItemLeft" align="right" valign="top"><a id="afe1295017905f68cd551d510b5b92340"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_get_element_count_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv[], const long n, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p)</td></tr>
<tr class="separator:afe1295017905f68cd551d510b5b92340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f6e1a2a55846774f4103330aac553c"><td class="memItemLeft" align="right" valign="top"><a id="a21f6e1a2a55846774f4103330aac553c"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_get_integer_values_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv[], const long n, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p)</td></tr>
<tr class="separator:a21f6e1a2a55846774f4103330aac553c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e2c060cb87fa46364cae1e3038d47f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a40e2c060cb87fa46364cae1e3038d47f">kmr_histogram_count_by_ranks</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, long *frq, double *var, _Bool rankzeroonly)</td></tr>
<tr class="memdesc:a40e2c060cb87fa46364cae1e3038d47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an integer array FRQ[i] with the count of the elements of each rank.  <a href="#a40e2c060cb87fa46364cae1e3038d47f">More...</a><br /></td></tr>
<tr class="separator:a40e2c060cb87fa46364cae1e3038d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2dac5a39eab296fdb920455f699f1c"><td class="memItemLeft" align="right" valign="top"><a id="a9f2dac5a39eab296fdb920455f699f1c"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_make_product_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv[], const long n, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p)</td></tr>
<tr class="separator:a9f2dac5a39eab296fdb920455f699f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada07fb9d17822e3720c64976e3bc7fdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#ada07fb9d17822e3720c64976e3bc7fdd">kmr_map_for_some</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:ada07fb9d17822e3720c64976e3bc7fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps until some key-value are added.  <a href="#ada07fb9d17822e3720c64976e3bc7fdd">More...</a><br /></td></tr>
<tr class="separator:ada07fb9d17822e3720c64976e3bc7fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18d7541ca4f6e28c922edb006a388f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#af18d7541ca4f6e28c922edb006a388f4">kmr_match</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi0, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi1, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:af18d7541ca4f6e28c922edb006a388f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes key-value pairs as products of the two values in two key-value stream.  <a href="#af18d7541ca4f6e28c922edb006a388f4">More...</a><br /></td></tr>
<tr class="separator:af18d7541ca4f6e28c922edb006a388f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5383035b38c858eb5e107c65c8c2b03"><td class="memItemLeft" align="right" valign="top"><a id="ae5383035b38c858eb5e107c65c8c2b03"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_minmax2_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv[], const long n, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p)</td></tr>
<tr class="separator:ae5383035b38c858eb5e107c65c8c2b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f319be6ce3801095704549460e36760"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structkmr__ntuple__entry.html">kmr_ntuple_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a3f319be6ce3801095704549460e36760">kmr_nth_ntuple</a> (struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u, int nth)</td></tr>
<tr class="memdesc:a3f319be6ce3801095704549460e36760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an NTH entry of an n-tuple.  <a href="#a3f319be6ce3801095704549460e36760">More...</a><br /></td></tr>
<tr class="separator:a3f319be6ce3801095704549460e36760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1ec5745abce4c3b711146b0d4f5ce6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#aea1ec5745abce4c3b711146b0d4f5ce6">kmr_pairing</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:aea1ec5745abce4c3b711146b0d4f5ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a value part with a key-value pairing.  <a href="#aea1ec5745abce4c3b711146b0d4f5ce6">More...</a><br /></td></tr>
<tr class="separator:aea1ec5745abce4c3b711146b0d4f5ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26f7a21cd0f577c29e7333d63db8e20"><td class="memItemLeft" align="right" valign="top"><a id="ae26f7a21cd0f577c29e7333d63db8e20"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_pairing_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:ae26f7a21cd0f577c29e7333d63db8e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582f3b1af50e4e151d030e9dffab2fb0"><td class="memItemLeft" align="right" valign="top"><a id="a582f3b1af50e4e151d030e9dffab2fb0"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_partition_by_count_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:a582f3b1af50e4e151d030e9dffab2fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad82b8d28bfa069cfa22507b28b61912"><td class="memItemLeft" align="right" valign="top"><a id="aad82b8d28bfa069cfa22507b28b61912"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_partition_by_ranking_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:aad82b8d28bfa069cfa22507b28b61912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c130235033adf9a9875175c35afc14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a98c130235033adf9a9875175c35afc14">kmr_product_ntuples</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> **vv[2], long cnt[2], int marker, int slots[][2], int nslots, int keys[][2], int nkeys)</td></tr>
<tr class="memdesc:a98c130235033adf9a9875175c35afc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a direct product of the two sets of n-tuples VV[0] and VV[1] with their counts in CNT[0] and CNT[1].  <a href="#a98c130235033adf9a9875175c35afc14">More...</a><br /></td></tr>
<tr class="separator:a98c130235033adf9a9875175c35afc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b697e156cb35a757bca8e6c3153ade7"><td class="memItemLeft" align="right" valign="top"><a id="a0b697e156cb35a757bca8e6c3153ade7"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_product_ntuples_by_space</b> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> **vv[2], long cnt[2], int marker, int slots[][2], int nslots, int keys[][2], int nkeys, _Bool byspace)</td></tr>
<tr class="separator:a0b697e156cb35a757bca8e6c3153ade7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91185634c3bb308504757af9fea4fef2"><td class="memItemLeft" align="right" valign="top"><a id="a91185634c3bb308504757af9fea4fef2"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_put_integer_to_array_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:a91185634c3bb308504757af9fea4fef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7f6b32ff70600389005fb8cf85939c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a5b7f6b32ff70600389005fb8cf85939c">kmr_put_ntuple</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u, const int size, const void *v, const int len)</td></tr>
<tr class="memdesc:a5b7f6b32ff70600389005fb8cf85939c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an entry V with LEN in an n-tuple U whose size is limited to SIZE.  <a href="#a5b7f6b32ff70600389005fb8cf85939c">More...</a><br /></td></tr>
<tr class="separator:a5b7f6b32ff70600389005fb8cf85939c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d88c46543a928148613cbe3ef3db8d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a8d88c46543a928148613cbe3ef3db8d1">kmr_put_ntuple_entry</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u, const int sz, struct <a class="el" href="structkmr__ntuple__entry.html">kmr_ntuple_entry</a> e)</td></tr>
<tr class="memdesc:a8d88c46543a928148613cbe3ef3db8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an n-tuple entry E in an n-tuple U whose size is limited to SIZE.  <a href="#a8d88c46543a928148613cbe3ef3db8d1">More...</a><br /></td></tr>
<tr class="separator:a8d88c46543a928148613cbe3ef3db8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683553c3f8d8cebecad43a2ec7ba858b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a683553c3f8d8cebecad43a2ec7ba858b">kmr_put_ntuple_long</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u, const int sz, long v)</td></tr>
<tr class="memdesc:a683553c3f8d8cebecad43a2ec7ba858b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an integer value in an n-tuple U whose size is limited to SIZE.  <a href="#a683553c3f8d8cebecad43a2ec7ba858b">More...</a><br /></td></tr>
<tr class="separator:a683553c3f8d8cebecad43a2ec7ba858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffec5584ffa0f2c861af02a9463fd55"><td class="memItemLeft" align="right" valign="top"><a id="a3ffec5584ffa0f2c861af02a9463fd55"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_rank_for_sort</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:a3ffec5584ffa0f2c861af02a9463fd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8d470979d2edbc1d1af235f150e89e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a7d8d470979d2edbc1d1af235f150e89e">kmr_ranking</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, long *count, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a7d8d470979d2edbc1d1af235f150e89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a ranking to key-value pairs, and returns the number of the total elements in COUNT.  <a href="#a7d8d470979d2edbc1d1af235f150e89e">More...</a><br /></td></tr>
<tr class="separator:a7d8d470979d2edbc1d1af235f150e89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c439662308457dbab79963977f7963"><td class="memItemLeft" align="right" valign="top"><a id="a47c439662308457dbab79963977f7963"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_ranking_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:a47c439662308457dbab79963977f7963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d660a9aeea686ef51f6d0b2c571e2fa"><td class="memItemLeft" align="right" valign="top"><a id="a0d660a9aeea686ef51f6d0b2c571e2fa"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_ranking_to_rank_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:a0d660a9aeea686ef51f6d0b2c571e2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860590f8d6fd3ac6a1ec80255d380aa2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a860590f8d6fd3ac6a1ec80255d380aa2">kmr_reduce_for_some</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a> r)</td></tr>
<tr class="memdesc:a860590f8d6fd3ac6a1ec80255d380aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces until some key-value are added.  <a href="#a860590f8d6fd3ac6a1ec80255d380aa2">More...</a><br /></td></tr>
<tr class="separator:a860590f8d6fd3ac6a1ec80255d380aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ae0218d80610afda9c102dc3d19203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#af0ae0218d80610afda9c102dc3d19203">kmr_reset_ntuple</a> (struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u, int n, int marker)</td></tr>
<tr class="memdesc:af0ae0218d80610afda9c102dc3d19203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets an n-tuple U with N entries and a MARKER.  <a href="#af0ae0218d80610afda9c102dc3d19203">More...</a><br /></td></tr>
<tr class="separator:af0ae0218d80610afda9c102dc3d19203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50e7437f8d24e7c50927f21b0ad9d44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#aa50e7437f8d24e7c50927f21b0ad9d44">kmr_reverse</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:aa50e7437f8d24e7c50927f21b0ad9d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new pair by swapping the key and the value in each pair.  <a href="#aa50e7437f8d24e7c50927f21b0ad9d44">More...</a><br /></td></tr>
<tr class="separator:aa50e7437f8d24e7c50927f21b0ad9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed13742921f37a68ae9b9eaa1c41da4"><td class="memItemLeft" align="right" valign="top"><a id="a2ed13742921f37a68ae9b9eaa1c41da4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_reverse_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:a2ed13742921f37a68ae9b9eaa1c41da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b835671b9a5e20121307cd95809ad0"><td class="memItemLeft" align="right" valign="top"><a id="ae4b835671b9a5e20121307cd95809ad0"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_sample_kv</b> (long nsamples, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo)</td></tr>
<tr class="separator:ae4b835671b9a5e20121307cd95809ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec63a7e08169d92070414461a1759673"><td class="memItemLeft" align="right" valign="top"><a id="aec63a7e08169d92070414461a1759673"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_sample_to_array</b> (long nsamples, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> *bv)</td></tr>
<tr class="separator:aec63a7e08169d92070414461a1759673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04f1084ded85211ef0f45bae2e74127"><td class="memItemLeft" align="right" valign="top"><a id="ab04f1084ded85211ef0f45bae2e74127"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_scan_across_ranks_sequentially</b> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *total, <a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a> r)</td></tr>
<tr class="separator:ab04f1084ded85211ef0f45bae2e74127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73733e98faa5ee96665d415ef2044333"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a73733e98faa5ee96665d415ef2044333">kmr_scan_on_values</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *total, <a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a> r)</td></tr>
<tr class="memdesc:a73733e98faa5ee96665d415ef2044333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix-scans every key-value with a reduce-function (non-self-inclusively) and generates the final value in TOTAL (it generates the same value on all the ranks in the TOTAL).  <a href="#a73733e98faa5ee96665d415ef2044333">More...</a><br /></td></tr>
<tr class="separator:a73733e98faa5ee96665d415ef2044333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000731d22474a8c313e0f5de0236fe0e"><td class="memItemLeft" align="right" valign="top"><a id="a000731d22474a8c313e0f5de0236fe0e"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_scan_sum_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv[], const long n, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p)</td></tr>
<tr class="separator:a000731d22474a8c313e0f5de0236fe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c13b06c526421dbe8499416fff0ced"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#ab4c13b06c526421dbe8499416fff0ced">kmr_separate_ntuples</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv[], const long n, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> **vv[2], long cnt[2], int markers[2], _Bool disallow_other_entries)</td></tr>
<tr class="memdesc:ab4c13b06c526421dbe8499416fff0ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates the n-tuples stored in the value part of KV into the two sets by their marker values.  <a href="#ab4c13b06c526421dbe8499416fff0ced">More...</a><br /></td></tr>
<tr class="separator:ab4c13b06c526421dbe8499416fff0ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e89bd7e35b3d0a403c7fb61e3d8b087"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a6e89bd7e35b3d0a403c7fb61e3d8b087">kmr_shuffle_leveling_pair_count</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo)</td></tr>
<tr class="memdesc:a6e89bd7e35b3d0a403c7fb61e3d8b087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles key-values so that each rank has approximately the same number of pairs.  <a href="#a6e89bd7e35b3d0a403c7fb61e3d8b087">More...</a><br /></td></tr>
<tr class="separator:a6e89bd7e35b3d0a403c7fb61e3d8b087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d092c5a560c5df86729a383aa6e7fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a05d092c5a560c5df86729a383aa6e7fe">kmr_size_ntuple</a> (struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u)</td></tr>
<tr class="memdesc:a05d092c5a560c5df86729a383aa6e7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the storage size of an n-tuple.  <a href="#a05d092c5a560c5df86729a383aa6e7fe">More...</a><br /></td></tr>
<tr class="separator:a05d092c5a560c5df86729a383aa6e7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae398c2918a0097eb20f50b1ffb21c1da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#ae398c2918a0097eb20f50b1ffb21c1da">kmr_size_ntuple_by_lengths</a> (int n, int len[])</td></tr>
<tr class="memdesc:ae398c2918a0097eb20f50b1ffb21c1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the storage size of an n-tuple for N entries with LEN[i] size each.  <a href="#ae398c2918a0097eb20f50b1ffb21c1da">More...</a><br /></td></tr>
<tr class="separator:ae398c2918a0097eb20f50b1ffb21c1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dc49274f766b46b16ec77b0217c6ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a43dc49274f766b46b16ec77b0217c6ca">kmr_sort</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a43dc49274f766b46b16ec77b0217c6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a key-value stream globally.  <a href="#a43dc49274f766b46b16ec77b0217c6ca">More...</a><br /></td></tr>
<tr class="separator:a43dc49274f766b46b16ec77b0217c6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab020cce7e7f28f0937fc71a03bc759"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a6ab020cce7e7f28f0937fc71a03bc759">kmr_sort_by_one</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a6ab020cce7e7f28f0937fc71a03bc759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort by rank0, a degenerated case for small number of keys.  <a href="#a6ab020cce7e7f28f0937fc71a03bc759">More...</a><br /></td></tr>
<tr class="separator:a6ab020cce7e7f28f0937fc71a03bc759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee642a4f300cc31d6e86cdc6064d177"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a2ee642a4f300cc31d6e86cdc6064d177">kmr_sort_large</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a2ee642a4f300cc31d6e86cdc6064d177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a key-value stream by the regular or the random sampling-sort.  <a href="#a2ee642a4f300cc31d6e86cdc6064d177">More...</a><br /></td></tr>
<tr class="separator:a2ee642a4f300cc31d6e86cdc6064d177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4206dfa415bd8d42e836a4fbf0838f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a1f4206dfa415bd8d42e836a4fbf0838f">kmr_sort_small</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a1f4206dfa415bd8d42e836a4fbf0838f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a key-value stream, by partitioning to equal ranges.  <a href="#a1f4206dfa415bd8d42e836a4fbf0838f">More...</a><br /></td></tr>
<tr class="separator:a1f4206dfa415bd8d42e836a4fbf0838f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65527a79aed95651d87a96c2ee3f4dc"><td class="memItemLeft" align="right" valign="top"><a id="aa65527a79aed95651d87a96c2ee3f4dc"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_sum_key_counts_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv[], const long n, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p)</td></tr>
<tr class="separator:aa65527a79aed95651d87a96c2ee3f4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482875874e3a742cae4058d520be2c12"><td class="memItemLeft" align="right" valign="top"><a id="a482875874e3a742cae4058d520be2c12"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_tag_value_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:a482875874e3a742cae4058d520be2c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef882f82ea273da7b31a2de5c922d57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmrmoreops_8c.html#a5ef882f82ea273da7b31a2de5c922d57">kmr_unpairing</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a5ef882f82ea273da7b31a2de5c922d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a key-value pair from a pairing in the value part, discarding the original key.  <a href="#a5ef882f82ea273da7b31a2de5c922d57">More...</a><br /></td></tr>
<tr class="separator:a5ef882f82ea273da7b31a2de5c922d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b18656ffe5b22f4b9aab6de2ab5cdf"><td class="memItemLeft" align="right" valign="top"><a id="a92b18656ffe5b22f4b9aab6de2ab5cdf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_unpairing_fn</b> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *p, const long i)</td></tr>
<tr class="separator:a92b18656ffe5b22f4b9aab6de2ab5cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>More Operatons on Key-Value Stream. </p>

<p class="definition">Definition in file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a6e91769570ad3a791b0f8810bfafdfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e91769570ad3a791b0f8810bfafdfdc">&#9670;&nbsp;</a></span>kmr_find_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_find_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>ki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> *&#160;</td>
          <td class="paramname"><em>ko</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a key-value pair for a key. </p>
<p>It is an error when not exactly one entry is found. It does not consume the input KVS KVI. The returned key-value entry must be used before freeing the input KVS, when it points to an opaque data. It maps internally, so it is slow. It is tricky that the internally created KVS KVS0 points to the key-value area in the input KVS KVI. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00043">43</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a6134d913ad359d56c789a99fb668a0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6134d913ad359d56c789a99fb668a0d3">&#9670;&nbsp;</a></span>kmr_find_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_find_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>vq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the key K in the key-value stream KVS. </p>
<p>It returns a pointer pointing inside the key-value stream. It is an error when not exactly one entry is found. It does not consume the input KVS. It maps internally, so slow. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00073">73</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a161eaf42b3fb2855b6186ccf41fc72ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161eaf42b3fb2855b6186ccf41fc72ab">&#9670;&nbsp;</a></span>kmr_get_element_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_get_element_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the total number of key-value pairs. </p>
<p>It uses replication and reduction. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00114">114</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="aa50e7437f8d24e7c50927f21b0ad9d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50e7437f8d24e7c50927f21b0ad9d44">&#9670;&nbsp;</a></span>kmr_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a new pair by swapping the key and the value in each pair. </p>
<p>That is, it makes new pairs (v0,k0) from (k0,v0). This is a simple mapper. Effective-options: NOTHREADING, INSPECT, KEEP_OPEN, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00159">159</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="aea1ec5745abce4c3b711146b0d4f5ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1ec5745abce4c3b711146b0d4f5ce6">&#9670;&nbsp;</a></span>kmr_pairing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_pairing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a value part with a key-value pairing. </p>
<p>That is, it makes new pairs (k0,(k0,v0)) from (k0,v0). See <a class="el" href="kmrmoreops_8c.html#a5ef882f82ea273da7b31a2de5c922d57" title="Extracts a key-value pair from a pairing in the value part, discarding the original key...">kmr_unpairing()</a>. This is a simple mapper. Effective-options: NOTHREADING, INSPECT, KEEP_OPEN, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00212">212</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a5ef882f82ea273da7b31a2de5c922d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef882f82ea273da7b31a2de5c922d57">&#9670;&nbsp;</a></span>kmr_unpairing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_unpairing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a key-value pair from a pairing in the value part, discarding the original key. </p>
<p>It is the inverse of kmr_pairing. That is, it makes new pairs (k1,v1) from (k0,(k1,v1)). See <a class="el" href="kmrmoreops_8c.html#aea1ec5745abce4c3b711146b0d4f5ce6" title="Replaces a value part with a key-value pairing. ">kmr_pairing()</a>. This is a simple mapper. Effective-options: NOTHREADING, INSPECT, KEEP_OPEN, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00234">234</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a1f4206dfa415bd8d42e836a4fbf0838f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4206dfa415bd8d42e836a4fbf0838f">&#9670;&nbsp;</a></span>kmr_sort_small()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_sort_small </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a key-value stream, by partitioning to equal ranges. </p>
<p>It is NOT-STABLE due to quick-sort used inside. It consumes an input key-value stream unless INSPECT is specified. It assumes uniform distribution, and partioning is simply determined by the range of keys (MIN-MAX range is divided by nprocs). Effective-options: NOTHREADING, INSPECT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00388">388</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a2ee642a4f300cc31d6e86cdc6064d177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee642a4f300cc31d6e86cdc6064d177">&#9670;&nbsp;</a></span>kmr_sort_large()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_sort_large </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a key-value stream by the regular or the random sampling-sort. </p>
<p>It is NOT-STABLE due to quick-sort used inside. It consumes an input key-value stream unless INSPECT is specified. It can be used for "GraySort". Effective-options: NOTHREADING, INSPECT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00469">469</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a6ab020cce7e7f28f0937fc71a03bc759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab020cce7e7f28f0937fc71a03bc759">&#9670;&nbsp;</a></span>kmr_sort_by_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_sort_by_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort by rank0, a degenerated case for small number of keys. </p>
<p>It is NOT-STABLE due to quick-sort used inside. It consumes an input key-value stream unless INSPECT is specified. Effective-options: INSPECT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00544">544</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a43dc49274f766b46b16ec77b0217c6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43dc49274f766b46b16ec77b0217c6ca">&#9670;&nbsp;</a></span>kmr_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a key-value stream globally. </p>
<p>It is NOT-STABLE due to quick-sort used inside. It consumes an input key-value stream unless INSPECT is specified. It selects a sorting routine on the total number of keys. See <a class="el" href="kmrmoreops_8c.html#a2ee642a4f300cc31d6e86cdc6064d177" title="Sorts a key-value stream by the regular or the random sampling-sort. ">kmr_sort_large()</a>, <a class="el" href="kmrmoreops_8c.html#a1f4206dfa415bd8d42e836a4fbf0838f" title="Sorts a key-value stream, by partitioning to equal ranges. ">kmr_sort_small()</a>, or <a class="el" href="kmrmoreops_8c.html#a6ab020cce7e7f28f0937fc71a03bc759" title="Sort by rank0, a degenerated case for small number of keys. ">kmr_sort_by_one()</a>. The results are stored as ascending ranks, thus the rank0 holds the minimum. Effective-options: INSPECT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00575">575</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="af18d7541ca4f6e28c922edb006a388f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18d7541ca4f6e28c922edb006a388f4">&#9670;&nbsp;</a></span>kmr_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes key-value pairs as products of the two values in two key-value stream. </p>
<p>It creates a set of key-value pairs (ai,bj) of the pairs (key,ai) from KVS0 and (key,bj) from KVS1 for the matching key. It makes a direct-product of the values when multiple values exist for a matching key. That is, for example, given a set {(k,a0), (k,a1), (k,a2)} in KVS0 and {(k,b3), (k,b4)} in KVS1 for some distinct key, it creates {(a0,b3), (a0,b4), (a1,b3), (a1,b4), (a2,b3), (a2,b4)}. Effective-options: NOTHREADNG. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00696">696</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a7d8d470979d2edbc1d1af235f150e89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8d470979d2edbc1d1af235f150e89e">&#9670;&nbsp;</a></span>kmr_ranking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_ranking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a ranking to key-value pairs, and returns the number of the total elements in COUNT. </p>
<p>Ranking is a position in the key-value stream. That is, for example, given a sequence {(k0,v0), (k1,v1), (k2,v2)}, it creates {(0,(k0,v0)), (1,(k1,v1)), (2,(k2,v2))}. Effective-options: NOTHREADING, INSPECT, KEEP_OPEN. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00764">764</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a058890c9ef6689deacfd9eda9d25e513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058890c9ef6689deacfd9eda9d25e513">&#9670;&nbsp;</a></span>kmr_distribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_distribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>cyclic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distributes key-values so that each rank has approximately the same number of pairs. </p>
<p>It is used to level the load of mapping among ranks by calling it before mapping. <a class="el" href="kmr_8h.html#a194686701b3c46a869fe9eb2cab93252" title="Shuffles key-value pairs to the appropriate destination ranks. ">kmr_shuffle()</a> can be sufficient to distribute pairs in most cases, but sometimes it results in uneven distribution because shuffling is based on hashing on the keys. Effective-options: NOTHREADING, INSPECT, KEEP_OPEN. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00835">835</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a73733e98faa5ee96665d415ef2044333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73733e98faa5ee96665d415ef2044333">&#9670;&nbsp;</a></span>kmr_scan_on_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_scan_on_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefix-scans every key-value with a reduce-function (non-self-inclusively) and generates the final value in TOTAL (it generates the same value on all the ranks in the TOTAL). </p>
<p>The key-values are scanned in the order in the KVS as they are concatenated in the rank-order. The reduce-function should be associative and free of side-effects (because it is called multiple times on the same data). The reduce-function should output a single key-value when given any number of key-value pairs. Furthermore, it should output an identity element when it is given zero key-value pairs. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00943">943</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a6e89bd7e35b3d0a403c7fb61e3d8b087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e89bd7e35b3d0a403c7fb61e3d8b087">&#9670;&nbsp;</a></span>kmr_shuffle_leveling_pair_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_shuffle_leveling_pair_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles key-values so that each rank has approximately the same number of pairs. </p>
<p>It collects the same keys on a rank (cf. <a class="el" href="kmrmoreops_8c.html#a058890c9ef6689deacfd9eda9d25e513" title="Distributes key-values so that each rank has approximately the same number of pairs. ">kmr_distribute()</a>). </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01074">1074</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="af00f09bbba752958cd1036ceb0aa5aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00f09bbba752958cd1036ceb0aa5aad">&#9670;&nbsp;</a></span>kmr_choose_first_part()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_choose_first_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chooses the first N entries from a key-value stream KVI. </p>
<p>The option nothreading is implied to keep the ordering. Effective-options: INSPECT, KEEP_OPEN. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01145">1145</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="ada07fb9d17822e3720c64976e3bc7fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada07fb9d17822e3720c64976e3bc7fdd">&#9670;&nbsp;</a></span>kmr_map_for_some()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_for_some </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps until some key-value are added. </p>
<p>It stops processing, when the output is non-empty. It does not guarantee singleness. Existence/emptiness be checked by <a class="el" href="kmrmoreops_8c.html#a161eaf42b3fb2855b6186ccf41fc72ab" title="Gets the total number of key-value pairs. ">kmr_get_element_count()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01170">1170</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a860590f8d6fd3ac6a1ec80255d380aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860590f8d6fd3ac6a1ec80255d380aa2">&#9670;&nbsp;</a></span>kmr_reduce_for_some()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_reduce_for_some </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces until some key-value are added. </p>
<p>It stops processing, when the output is non-empty. It does not guarantee singleness. Existence/emptiness be checked by <a class="el" href="kmrmoreops_8c.html#a161eaf42b3fb2855b6186ccf41fc72ab" title="Gets the total number of key-value pairs. ">kmr_get_element_count()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01183">1183</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a3f319be6ce3801095704549460e36760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f319be6ce3801095704549460e36760">&#9670;&nbsp;</a></span>kmr_nth_ntuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structkmr__ntuple__entry.html">kmr_ntuple_entry</a> kmr_nth_ntuple </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an NTH entry of an n-tuple. </p>
<p>It returns a pair of a length and a pointer. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01197">1197</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a05d092c5a560c5df86729a383aa6e7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d092c5a560c5df86729a383aa6e7fe">&#9670;&nbsp;</a></span>kmr_size_ntuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_size_ntuple </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the storage size of an n-tuple. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01211">1211</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="ae398c2918a0097eb20f50b1ffb21c1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae398c2918a0097eb20f50b1ffb21c1da">&#9670;&nbsp;</a></span>kmr_size_ntuple_by_lengths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_size_ntuple_by_lengths </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the storage size of an n-tuple for N entries with LEN[i] size each. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01221">1221</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="af0ae0218d80610afda9c102dc3d19203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ae0218d80610afda9c102dc3d19203">&#9670;&nbsp;</a></span>kmr_reset_ntuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kmr_reset_ntuple </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>marker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets an n-tuple U with N entries and a MARKER. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01234">1234</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a5b7f6b32ff70600389005fb8cf85939c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7f6b32ff70600389005fb8cf85939c">&#9670;&nbsp;</a></span>kmr_put_ntuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_put_ntuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an entry V with LEN in an n-tuple U whose size is limited to SIZE. </p>
<p>An n-tuple should be initialized by <a class="el" href="kmrmoreops_8c.html#af0ae0218d80610afda9c102dc3d19203" title="Resets an n-tuple U with N entries and a MARKER. ">kmr_reset_ntuple()</a> first. Note it fills with zeros the gap of the alignment padding, allowing the n-tuples be used as opaque keys. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01252">1252</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a683553c3f8d8cebecad43a2ec7ba858b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683553c3f8d8cebecad43a2ec7ba858b">&#9670;&nbsp;</a></span>kmr_put_ntuple_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_put_ntuple_long </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an integer value in an n-tuple U whose size is limited to SIZE. </p>
<p>See <a class="el" href="kmrmoreops_8c.html#a5b7f6b32ff70600389005fb8cf85939c" title="Adds an entry V with LEN in an n-tuple U whose size is limited to SIZE. ">kmr_put_ntuple()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01274">1274</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a8d88c46543a928148613cbe3ef3db8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d88c46543a928148613cbe3ef3db8d1">&#9670;&nbsp;</a></span>kmr_put_ntuple_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_put_ntuple_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple__entry.html">kmr_ntuple_entry</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an n-tuple entry E in an n-tuple U whose size is limited to SIZE. </p>
<p>See <a class="el" href="kmrmoreops_8c.html#a5b7f6b32ff70600389005fb8cf85939c" title="Adds an entry V with LEN in an n-tuple U whose size is limited to SIZE. ">kmr_put_ntuple()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01284">1284</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a1292ef72b8ba6ed975e96887404d1281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1292ef72b8ba6ed975e96887404d1281">&#9670;&nbsp;</a></span>kmr_add_ntuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_add_ntuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>klen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an n-tuple U with a given key K and KLEN in a key-value stream KVO. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01295">1295</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="ab4c13b06c526421dbe8499416fff0ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c13b06c526421dbe8499416fff0ced">&#9670;&nbsp;</a></span>kmr_separate_ntuples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_separate_ntuples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>kv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> **&#160;</td>
          <td class="paramname"><em>vv</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cnt</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markers</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>disallow_other_entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates the n-tuples stored in the value part of KV into the two sets by their marker values. </p>
<p>It is intended to be used in reduce functions. It separates the n-tuples to the first set by marker=MARKERS[0] and to the second set by marker=MARKERS[1]. It returns two malloced arrays in VV with their sizes in CNT. The arrays VV[0] and VV[1] should be freed by the caller. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01318">1318</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a98c130235033adf9a9875175c35afc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c130235033adf9a9875175c35afc14">&#9670;&nbsp;</a></span>kmr_product_ntuples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_product_ntuples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> **&#160;</td>
          <td class="paramname"><em>vv</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cnt</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slots</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nslots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keys</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nkeys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a direct product of the two sets of n-tuples VV[0] and VV[1] with their counts in CNT[0] and CNT[1]. </p>
<p>It is intended to be used in reduce functions. The resulting n-tuples are created by SLOTS, which chooses i-th entry of the n-tuples by the SLOTS[i][0]-th entry from the the SLOTS[i][1] set, 0 from the first set and 1 from the second set. The product n-tuples have MARKER and are inserted into KVO under the new key. The new key is selected like values using KEYS[j][0] and KEYS[j][1]. The key is not an n-tuple when NKEYS=1, or an n-tuple of KEYS[j] entries. The n-tuple key has zero as a marker. Note that it does not remove duplicate entries. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01528">1528</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a40e2c060cb87fa46364cae1e3038d47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e2c060cb87fa46364cae1e3038d47f">&#9670;&nbsp;</a></span>kmr_histogram_count_by_ranks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_histogram_count_by_ranks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>frq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>rankzeroonly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an integer array FRQ[i] with the count of the elements of each rank. </p>
<p>The array FRQ be as large as nprocs. It also fills VAR[0]=average, VAR[1]=variance, VAR[2]=min, and VAR[3]=max. FRQ or VAR can be null. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01569">1569</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
