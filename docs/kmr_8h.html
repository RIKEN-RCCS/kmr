<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KMR: src/kmr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KMR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">kmr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>KMR Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
</div>
<p><a href="kmr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__code__line.html">kmr_code_line</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information of Source Code Line.  <a href="structkmr__code__line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__ctx.html">kmr_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">KMR Context.  <a href="structkmr__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__file__option.html">kmr_file_option</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to Mapping on Files.  <a href="structkmr__file__option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__keyed__record.html">kmr_keyed_record</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keyed-Record for Sorting.  <a href="structkmr__keyed__record.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__kv__box.html">kmr_kv_box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handy Copy of a Key-Value Field.  <a href="structkmr__kv__box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionkmr__kvs.html">kmr_kvs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-Value Stream (abstract).  <a href="unionkmr__kvs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__kvs__block.html">kmr_kvs_block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__kvs__dummy.html">kmr_kvs_dummy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-Value Stream (DUMMY); Mandatory Entries.  <a href="structkmr__kvs__dummy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__kvs__entry.html">kmr_kvs_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__kvs__list.html">kmr_kvs_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__kvs__list__head.html">kmr_kvs_list_head</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__kvs__oncore.html">kmr_kvs_oncore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-Value Stream.  <a href="structkmr__kvs__oncore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__kvs__pushoff.html">kmr_kvs_pushoff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-Value Stream with Shuffling at Addition of Key-Values.  <a href="structkmr__kvs__pushoff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__map__ms__state.html">kmr_map_ms_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State during <a class="el" href="kmr_8h.html#a9d52c3c69250bf19dd28d5e38809df79" title="Maps in master-worker mode. ">kmr_map_ms()</a>.  <a href="structkmr__map__ms__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__ntuple.html">kmr_ntuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-Tuple.  <a href="structkmr__ntuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__ntuple__entry.html">kmr_ntuple_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-Tuple Argument.  <a href="structkmr__ntuple__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__option.html">kmr_option</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to Mapping, Shuffling, and Reduction.  <a href="structkmr__option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__pushoff__buffers.html">kmr_pushoff_buffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record of Push-Off Key-Value Stream for a Rank.  <a href="structkmr__pushoff__buffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__spawn__info.html">kmr_spawn_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawning Info.  <a href="structkmr__spawn__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to Mapping by Spawns.  <a href="structkmr__spawn__option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionkmr__unit__sized.html">kmr_unit_sized</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-Sized Storage.  <a href="unionkmr__unit__sized.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab65d97d85cb04d34829bd0f4fbf867ef"><td class="memItemLeft" align="right" valign="top"><a id="ab65d97d85cb04d34829bd0f4fbf867ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_API_ID</b>&#160;&#160;&#160;KMR_API_ID0(KMR_H)</td></tr>
<tr class="separator:ab65d97d85cb04d34829bd0f4fbf867ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90159e0ac99eaf26dba3b4ebffdc9db8"><td class="memItemLeft" align="right" valign="top"><a id="a90159e0ac99eaf26dba3b4ebffdc9db8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_API_ID0</b>(X)&#160;&#160;&#160;KMR_API_ID1(X)</td></tr>
<tr class="separator:a90159e0ac99eaf26dba3b4ebffdc9db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2df066c95920dd7096079dc8d13f02d"><td class="memItemLeft" align="right" valign="top"><a id="ad2df066c95920dd7096079dc8d13f02d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_API_ID1</b>(X)&#160;&#160;&#160;kmr_api_ ## X</td></tr>
<tr class="separator:ad2df066c95920dd7096079dc8d13f02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076d4d56dd15608c1ec82dc5935cdb5a"><td class="memItemLeft" align="right" valign="top"><a id="a076d4d56dd15608c1ec82dc5935cdb5a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_BR0</b>&#160;&#160;&#160;{</td></tr>
<tr class="separator:a076d4d56dd15608c1ec82dc5935cdb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1e4e1e81661f0d194cd52a9b77067c"><td class="memItemLeft" align="right" valign="top"><a id="a2a1e4e1e81661f0d194cd52a9b77067c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_BR1</b>&#160;&#160;&#160;}</td></tr>
<tr class="separator:a2a1e4e1e81661f0d194cd52a9b77067c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5006dd70e399d546c5345142f72f6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a5c5006dd70e399d546c5345142f72f6d">kmr_create_kvs</a>(MR,  KF,  VF)&#160;&#160;&#160;<a class="el" href="kmrbase_8c.html#ade6559203d1471e48688314ba729758a">kmr_create_kvs7</a>((MR), (KF), (VF), kmr_noopt, __FILE__, __LINE__, __func__)</td></tr>
<tr class="memdesc:a5c5006dd70e399d546c5345142f72f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new key-value stream (of type KMR_KVS) with the specified field datatypes.  <a href="#a5c5006dd70e399d546c5345142f72f6d">More...</a><br /></td></tr>
<tr class="separator:a5c5006dd70e399d546c5345142f72f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8859b6257ddb9eb9e87d5b8b49b7f784"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a8859b6257ddb9eb9e87d5b8b49b7f784">kmr_create_kvs_</a>(MR,  IGNORE)</td></tr>
<tr class="memdesc:a8859b6257ddb9eb9e87d5b8b49b7f784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new key-value stream (of type KMR_KVS).  <a href="#a8859b6257ddb9eb9e87d5b8b49b7f784">More...</a><br /></td></tr>
<tr class="separator:a8859b6257ddb9eb9e87d5b8b49b7f784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c2d3225f6c9b2270a53aeda160b531"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a46c2d3225f6c9b2270a53aeda160b531">kmr_create_kvsx</a>(MR,  KF,  VF,  OPT)&#160;&#160;&#160;<a class="el" href="kmrbase_8c.html#ade6559203d1471e48688314ba729758a">kmr_create_kvs7</a>((MR), (KF), (VF), (OPT), __FILE__, __LINE__, __func__)</td></tr>
<tr class="memdesc:a46c2d3225f6c9b2270a53aeda160b531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new key-value stream (of type KMR_KVS) with the specified field datatypes.  <a href="#a46c2d3225f6c9b2270a53aeda160b531">More...</a><br /></td></tr>
<tr class="separator:a46c2d3225f6c9b2270a53aeda160b531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8f31c9b2c13ea21ab48cb5695be4e2"><td class="memItemLeft" align="right" valign="top"><a id="acf8f31c9b2c13ea21ab48cb5695be4e2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_H</b>&#160;&#160;&#160;20201116</td></tr>
<tr class="separator:acf8f31c9b2c13ea21ab48cb5695be4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dc005f93cbfdcdb0eebc302350a912"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a89dc005f93cbfdcdb0eebc302350a912">kmr_init</a>()&#160;&#160;&#160;kmr_init_2(KMR_API_ID)</td></tr>
<tr class="memdesc:a89dc005f93cbfdcdb0eebc302350a912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the environment.  <a href="#a89dc005f93cbfdcdb0eebc302350a912">More...</a><br /></td></tr>
<tr class="separator:a89dc005f93cbfdcdb0eebc302350a912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135b3a29854650734b621ef2322bf09a"><td class="memItemLeft" align="right" valign="top"><a id="a135b3a29854650734b621ef2322bf09a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_JOB_NAME_LEN</b>&#160;&#160;&#160;256</td></tr>
<tr class="separator:a135b3a29854650734b621ef2322bf09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47ccf24f10990ad5788292a4d94974e"><td class="memItemLeft" align="right" valign="top"><a id="ab47ccf24f10990ad5788292a4d94974e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_kv_cake</b>&#160;&#160;&#160;<a class="el" href="structkmr__kv__box.html">kmr_kv_box</a></td></tr>
<tr class="separator:ab47ccf24f10990ad5788292a4d94974e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381842d6d102e60fe54893745fc21cef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_KVS_MAGIC_OK</b>(X)</td></tr>
<tr class="separator:a381842d6d102e60fe54893745fc21cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb545fb804c554dfc05baab4c8abf8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a7bb545fb804c554dfc05baab4c8abf8d">kmr_map</a>(KVI,  KVO,  ARG,  OPT,  M)</td></tr>
<tr class="memdesc:a7bb545fb804c554dfc05baab4c8abf8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps simply.  <a href="#a7bb545fb804c554dfc05baab4c8abf8d">More...</a><br /></td></tr>
<tr class="separator:a7bb545fb804c554dfc05baab4c8abf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06cb9083e42011c9fa019add7bc228f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ae06cb9083e42011c9fa019add7bc228f">kmr_reduce</a>(KVI,  KVO,  ARG,  OPT,  R)</td></tr>
<tr class="memdesc:ae06cb9083e42011c9fa019add7bc228f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces key-value pairs.  <a href="#ae06cb9083e42011c9fa019add7bc228f">More...</a><br /></td></tr>
<tr class="separator:ae06cb9083e42011c9fa019add7bc228f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3638d8f491e2a9a52057d7e6d5c6e5da"><td class="memItemLeft" align="right" valign="top"><a id="a3638d8f491e2a9a52057d7e6d5c6e5da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_sort_a_batch</b>(X0,  X1,  X2,  X3)&#160;&#160;&#160;<a class="el" href="kmrbase_8c.html#a44b1acc032c1e378030ce36ed4ee68f9">kmr_sort_locally</a>(X0,X1,X2,X3)</td></tr>
<tr class="separator:a3638d8f491e2a9a52057d7e6d5c6e5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0d7bb53714dfbb01b35cfc3d58c299"><td class="memItemLeft" align="right" valign="top"><a id="aca0d7bb53714dfbb01b35cfc3d58c299"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_TAG_SPAWN_REPLY</b>&#160;&#160;&#160;500</td></tr>
<tr class="separator:aca0d7bb53714dfbb01b35cfc3d58c299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7af46bf7c01cb6fc45dae5c67dc6f2"><td class="memItemLeft" align="right" valign="top"><a id="ace7af46bf7c01cb6fc45dae5c67dc6f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_TAG_SPAWN_REPLY1</b>&#160;&#160;&#160;501</td></tr>
<tr class="separator:ace7af46bf7c01cb6fc45dae5c67dc6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6e8e5138878d6ba63b2de1900dcdd9fe"><td class="memItemLeft" align="right" valign="top"><a id="a6e8e5138878d6ba63b2de1900dcdd9fe"></a>
typedef struct <a class="el" href="structkmr__ctx.html">kmr_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>KMR</b></td></tr>
<tr class="separator:a6e8e5138878d6ba63b2de1900dcdd9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa61b758c6bb0685435625dce1d8df2"><td class="memItemLeft" align="right" valign="top"><a id="aafa61b758c6bb0685435625dce1d8df2"></a>
typedef union <a class="el" href="unionkmr__kvs.html">kmr_kvs</a>&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_KVS</b></td></tr>
<tr class="separator:aafa61b758c6bb0685435625dce1d8df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710ca6341d4cbe82f7e62d0f63c19ebb"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>) (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, const long index)</td></tr>
<tr class="memdesc:a710ca6341d4cbe82f7e62d0f63c19ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-function Type.  <a href="#a710ca6341d4cbe82f7e62d0f63c19ebb">More...</a><br /></td></tr>
<tr class="separator:a710ca6341d4cbe82f7e62d0f63c19ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e0b7a58968aad22188408a00131760"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a>) (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv[], const long n, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg)</td></tr>
<tr class="memdesc:af4e0b7a58968aad22188408a00131760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce-function Type.  <a href="#af4e0b7a58968aad22188408a00131760">More...</a><br /></td></tr>
<tr class="separator:af4e0b7a58968aad22188408a00131760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0d4f610f2dcd147372fc8798171da01b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a> { <br />
&#160;&#160;<b>KMR_KV_BAD</b>, 
<b>KMR_KV_OPAQUE</b>, 
<b>KMR_KV_CSTRING</b>, 
<b>KMR_KV_INTEGER</b>, 
<br />
&#160;&#160;<b>KMR_KV_FLOAT8</b>, 
<b>KMR_KV_POINTER_OWNED</b>, 
<b>KMR_KV_POINTER_UNMANAGED</b>
<br />
 }</td></tr>
<tr class="memdesc:a0d4f610f2dcd147372fc8798171da01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Datatypes of Keys or Values.  <a href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">More...</a><br /></td></tr>
<tr class="separator:a0d4f610f2dcd147372fc8798171da01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba361e1c83e8d5792e4bd5b2df2857b"><td class="memItemLeft" align="right" valign="top"><a id="aeba361e1c83e8d5792e4bd5b2df2857b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>kmr_kvs_magic</b> { <b>KMR_KVS_BAD</b>, 
<b>KMR_KVS_ONCORE</b>, 
<b>KMR_KVS_PUSHOFF</b>, 
<b>KMR_KVS_ONCORE_PACKED</b>
 }</td></tr>
<tr class="separator:aeba361e1c83e8d5792e4bd5b2df2857b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac90b01e2a5ec99a5146d71a48457c854"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ac90b01e2a5ec99a5146d71a48457c854">kmr_add_identity_fn</a> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, const long i)</td></tr>
<tr class="memdesc:ac90b01e2a5ec99a5146d71a48457c854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a given key-value pair unmodified.  <a href="#ac90b01e2a5ec99a5146d71a48457c854">More...</a><br /></td></tr>
<tr class="separator:ac90b01e2a5ec99a5146d71a48457c854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45076291f415e5137cecf882e77bcaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#af45076291f415e5137cecf882e77bcaa">kmr_add_kv</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv)</td></tr>
<tr class="memdesc:af45076291f415e5137cecf882e77bcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a key-value pair.  <a href="#af45076291f415e5137cecf882e77bcaa">More...</a><br /></td></tr>
<tr class="separator:af45076291f415e5137cecf882e77bcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cea104b2d349a035558de03b216476"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a59cea104b2d349a035558de03b216476">kmr_add_kv1</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, void *k, int klen, void *v, int vlen)</td></tr>
<tr class="memdesc:a59cea104b2d349a035558de03b216476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a key-value pair as given directly by a pointer.  <a href="#a59cea104b2d349a035558de03b216476">More...</a><br /></td></tr>
<tr class="separator:a59cea104b2d349a035558de03b216476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07e8d3c6b4a229295ed3f9d982d1a04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ac07e8d3c6b4a229295ed3f9d982d1a04">kmr_add_kv_done</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs)</td></tr>
<tr class="memdesc:ac07e8d3c6b4a229295ed3f9d982d1a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks finished adding key-value pairs.  <a href="#ac07e8d3c6b4a229295ed3f9d982d1a04">More...</a><br /></td></tr>
<tr class="separator:ac07e8d3c6b4a229295ed3f9d982d1a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeefc80eb39e18246008edbb4f10ff14"><td class="memItemLeft" align="right" valign="top"><a id="abeefc80eb39e18246008edbb4f10ff14"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_add_kv_quick_</b> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv)</td></tr>
<tr class="separator:abeefc80eb39e18246008edbb4f10ff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872983ca54c9e9eb46fe1d9537b0796d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a872983ca54c9e9eb46fe1d9537b0796d">kmr_add_kv_space</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, void **keyp, void **valuep)</td></tr>
<tr class="memdesc:a872983ca54c9e9eb46fe1d9537b0796d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a key-value pair, but only allocates a space and returns the pointers to the key and the value parts.  <a href="#a872983ca54c9e9eb46fe1d9537b0796d">More...</a><br /></td></tr>
<tr class="separator:a872983ca54c9e9eb46fe1d9537b0796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1292ef72b8ba6ed975e96887404d1281"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a1292ef72b8ba6ed975e96887404d1281">kmr_add_ntuple</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *k, int klen, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u)</td></tr>
<tr class="memdesc:a1292ef72b8ba6ed975e96887404d1281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an n-tuple U with a given key K and KLEN in a key-value stream KVO.  <a href="#a1292ef72b8ba6ed975e96887404d1281">More...</a><br /></td></tr>
<tr class="separator:a1292ef72b8ba6ed975e96887404d1281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf34ba4ed13b843adff4332d0dad8c8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#abf34ba4ed13b843adff4332d0dad8c8e">kmr_add_string</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, const char *k, const char *v)</td></tr>
<tr class="memdesc:abf34ba4ed13b843adff4332d0dad8c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a key-value pair of strings.  <a href="#abf34ba4ed13b843adff4332d0dad8c8e">More...</a><br /></td></tr>
<tr class="separator:abf34ba4ed13b843adff4332d0dad8c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb16f94c3684f127671a8112dbcd9747"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#aeb16f94c3684f127671a8112dbcd9747">kmr_assign_file</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:aeb16f94c3684f127671a8112dbcd9747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns files to ranks based on data locality.  <a href="#aeb16f94c3684f127671a8112dbcd9747">More...</a><br /></td></tr>
<tr class="separator:aeb16f94c3684f127671a8112dbcd9747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990395f4cb39cdd9d5b64da74765e717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a990395f4cb39cdd9d5b64da74765e717">kmr_check_pushoff_fast_notice_</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr)</td></tr>
<tr class="memdesc:a990395f4cb39cdd9d5b64da74765e717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if fast-notice works.  <a href="#a990395f4cb39cdd9d5b64da74765e717">More...</a><br /></td></tr>
<tr class="separator:a990395f4cb39cdd9d5b64da74765e717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00f09bbba752958cd1036ceb0aa5aad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#af00f09bbba752958cd1036ceb0aa5aad">kmr_choose_first_part</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, long n, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:af00f09bbba752958cd1036ceb0aa5aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses the first N entries from a key-value stream KVI.  <a href="#af00f09bbba752958cd1036ceb0aa5aad">More...</a><br /></td></tr>
<tr class="separator:af00f09bbba752958cd1036ceb0aa5aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d7bee0df5928f5700b3c6bbb31939"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a273d7bee0df5928f5700b3c6bbb31939">kmr_concatenate_kvs</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs[], int nkvs, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a273d7bee0df5928f5700b3c6bbb31939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a number of KVSes to one.  <a href="#a273d7bee0df5928f5700b3c6bbb31939">More...</a><br /></td></tr>
<tr class="separator:a273d7bee0df5928f5700b3c6bbb31939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55911779172dfab2a73ff811395b73f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ae55911779172dfab2a73ff811395b73f">kmr_copy_info_to_kvs</a> (MPI_Info src, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo)</td></tr>
<tr class="memdesc:ae55911779172dfab2a73ff811395b73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies mpi-info entires into kvs.  <a href="#ae55911779172dfab2a73ff811395b73f">More...</a><br /></td></tr>
<tr class="separator:ae55911779172dfab2a73ff811395b73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c36532f989557aef713397d3ea8b85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ab9c36532f989557aef713397d3ea8b85">kmr_copy_kvs_to_info</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, MPI_Info dst)</td></tr>
<tr class="memdesc:ab9c36532f989557aef713397d3ea8b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies kvs entires into mpi-info.  <a href="#ab9c36532f989557aef713397d3ea8b85">More...</a><br /></td></tr>
<tr class="separator:ab9c36532f989557aef713397d3ea8b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d03aa1b36d67910d6214c286553f9d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a4d03aa1b36d67910d6214c286553f9d5">kmr_copy_to_array_fn</a> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, const long i)</td></tr>
<tr class="memdesc:a4d03aa1b36d67910d6214c286553f9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the entry in the array.  <a href="#a4d03aa1b36d67910d6214c286553f9d5">More...</a><br /></td></tr>
<tr class="separator:a4d03aa1b36d67910d6214c286553f9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b105ad6655dbba1b821179bad3fdd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a41b105ad6655dbba1b821179bad3fdd4">kmr_create_context</a> (const MPI_Comm comm, const MPI_Info conf, const char *name)</td></tr>
<tr class="memdesc:a41b105ad6655dbba1b821179bad3fdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new KMR context (a context has type KMR).  <a href="#a41b105ad6655dbba1b821179bad3fdd4">More...</a><br /></td></tr>
<tr class="separator:a41b105ad6655dbba1b821179bad3fdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fea528e9643815e5f81cf4c8d33e802"><td class="memItemLeft" align="right" valign="top"><a id="a5fea528e9643815e5f81cf4c8d33e802"></a>
<a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_create_context_world</b> (void)</td></tr>
<tr class="separator:a5fea528e9643815e5f81cf4c8d33e802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4f8d7c1626c74f22957fb64fa6e0f8"><td class="memItemLeft" align="right" valign="top"><a id="a1f4f8d7c1626c74f22957fb64fa6e0f8"></a>
<a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_create_dummy_context</b> (void)</td></tr>
<tr class="separator:a1f4f8d7c1626c74f22957fb64fa6e0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1da5f26069d7daa2b1b88ae00b07a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#aab1da5f26069d7daa2b1b88ae00b07a0">kmr_create_kvs7</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a> k, enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a> v, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, const char *, const int, const char *)</td></tr>
<tr class="memdesc:aab1da5f26069d7daa2b1b88ae00b07a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new key-value stream with the specified field data-types.  <a href="#aab1da5f26069d7daa2b1b88ae00b07a0">More...</a><br /></td></tr>
<tr class="separator:aab1da5f26069d7daa2b1b88ae00b07a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486929819eaa18ce566911c8a2c17dd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a486929819eaa18ce566911c8a2c17dd9">kmr_create_pushoff_kvs</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a> kf, enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a> vf, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, const char *, const int, const char *)</td></tr>
<tr class="memdesc:a486929819eaa18ce566911c8a2c17dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new key-value stream with the specified field data-types.  <a href="#a486929819eaa18ce566911c8a2c17dd9">More...</a><br /></td></tr>
<tr class="separator:a486929819eaa18ce566911c8a2c17dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668e7b808fa3a039521964831825bb3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a668e7b808fa3a039521964831825bb3f">kmr_detach_swf_workers</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr)</td></tr>
<tr class="memdesc:a668e7b808fa3a039521964831825bb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disengages the workers from main processing and puts them in the service loop for spawning.  <a href="#a668e7b808fa3a039521964831825bb3f">More...</a><br /></td></tr>
<tr class="separator:a668e7b808fa3a039521964831825bb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058890c9ef6689deacfd9eda9d25e513"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a058890c9ef6689deacfd9eda9d25e513">kmr_distribute</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, _Bool cyclic, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a058890c9ef6689deacfd9eda9d25e513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes key-values so that each rank has approximately the same number of pairs.  <a href="#a058890c9ef6689deacfd9eda9d25e513">More...</a><br /></td></tr>
<tr class="separator:a058890c9ef6689deacfd9eda9d25e513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d35aaf2587d0e00cdb315a3ea591ecb"><td class="memItemLeft" align="right" valign="top"><a id="a7d35aaf2587d0e00cdb315a3ea591ecb"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_dummy_dummy_dummy_</b> (void)</td></tr>
<tr class="separator:a7d35aaf2587d0e00cdb315a3ea591ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c800daa2ad86b018ea27f268aab5726"><td class="memItemLeft" align="right" valign="top"><a id="a5c800daa2ad86b018ea27f268aab5726"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_dump_keyed_records</b> (const struct <a class="el" href="structkmr__keyed__record.html">kmr_keyed_record</a> *ev, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi)</td></tr>
<tr class="separator:a5c800daa2ad86b018ea27f268aab5726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab098ede35218931b5f256717042f8646"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ab098ede35218931b5f256717042f8646">kmr_dump_kv</a> (struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, char *buf, int buflen)</td></tr>
<tr class="memdesc:ab098ede35218931b5f256717042f8646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps contents of a key-value.  <a href="#ab098ede35218931b5f256717042f8646">More...</a><br /></td></tr>
<tr class="separator:ab098ede35218931b5f256717042f8646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835fbe3cbeddee74050f96e1fb1145a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a835fbe3cbeddee74050f96e1fb1145a9">kmr_dump_kvs</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, int flag)</td></tr>
<tr class="memdesc:a835fbe3cbeddee74050f96e1fb1145a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps contents of a KVS to stdout.  <a href="#a835fbe3cbeddee74050f96e1fb1145a9">More...</a><br /></td></tr>
<tr class="separator:a835fbe3cbeddee74050f96e1fb1145a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f947ac395ebff11ff1301a363e0fdf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a9f947ac395ebff11ff1301a363e0fdf9">kmr_dump_kvs_stats</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *, int level)</td></tr>
<tr class="memdesc:a9f947ac395ebff11ff1301a363e0fdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps contents of a key-value stream, with values are pairs.  <a href="#a9f947ac395ebff11ff1301a363e0fdf9">More...</a><br /></td></tr>
<tr class="separator:a9f947ac395ebff11ff1301a363e0fdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ce348f73e9cce1df6af7de726e7a1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#aa6ce348f73e9cce1df6af7de726e7a1c">kmr_dump_opaque</a> (const char *p, int siz, char *buf, int buflen)</td></tr>
<tr class="memdesc:aa6ce348f73e9cce1df6af7de726e7a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the string of the key or value field into a buffer BUF as printable string.  <a href="#aa6ce348f73e9cce1df6af7de726e7a1c">More...</a><br /></td></tr>
<tr class="separator:aa6ce348f73e9cce1df6af7de726e7a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91910ec11105345b5da1c33fa2eec561"><td class="memItemLeft" align="right" valign="top"><a id="a91910ec11105345b5da1c33fa2eec561"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_dump_slot</b> (union <a class="el" href="unionkmr__unit__sized.html">kmr_unit_sized</a> e, int len, enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a> data, char *buf, int buflen)</td></tr>
<tr class="separator:a91910ec11105345b5da1c33fa2eec561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a626663117f4a52acbccf45e6a4d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a74a626663117f4a52acbccf45e6a4d83">kmr_dump_swf_history</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr)</td></tr>
<tr class="memdesc:a74a626663117f4a52acbccf45e6a4d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the history of <a class="el" href="kmrwfmap_8c.html#a3df4a8125b1af6129fce5de92822202e" title="Maps with a simple workflow. ">kmr_map_swf()</a>, which is the start ordering the work-items.  <a href="#a74a626663117f4a52acbccf45e6a4d83">More...</a><br /></td></tr>
<tr class="separator:a74a626663117f4a52acbccf45e6a4d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1ca392e7e9052593253997e40968ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#acf1ca392e7e9052593253997e40968ee">kmr_dump_swf_lanes</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr)</td></tr>
<tr class="memdesc:acf1ca392e7e9052593253997e40968ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps lanes created by <a class="el" href="kmrwfmap_8c.html#aa2113e75854b4de98116829cf26b3a91" title="Initializes the lanes of simple workflow. ">kmr_init_swf()</a>.  <a href="#acf1ca392e7e9052593253997e40968ee">More...</a><br /></td></tr>
<tr class="separator:acf1ca392e7e9052593253997e40968ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048170a6ec1eb5712eaaf9fac8ae8c45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a048170a6ec1eb5712eaaf9fac8ae8c45">kmr_dump_swf_order_history</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, int *history, size_t length)</td></tr>
<tr class="memdesc:a048170a6ec1eb5712eaaf9fac8ae8c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of start ordering of the work-items.  <a href="#a048170a6ec1eb5712eaaf9fac8ae8c45">More...</a><br /></td></tr>
<tr class="separator:a048170a6ec1eb5712eaaf9fac8ae8c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a59cddb73580ce5eb53d1e48ba431e"><td class="memItemLeft" align="right" valign="top"><a id="ae7a59cddb73580ce5eb53d1e48ba431e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_file_enumerate</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, char **names, int n, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__file__option.html">kmr_file_option</a> fopt)</td></tr>
<tr class="separator:ae7a59cddb73580ce5eb53d1e48ba431e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617746ae8bd9b8bd6f8af9b4ca6e1733"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a617746ae8bd9b8bd6f8af9b4ca6e1733">kmr_fin</a> (void)</td></tr>
<tr class="memdesc:a617746ae8bd9b8bd6f8af9b4ca6e1733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the environment.  <a href="#a617746ae8bd9b8bd6f8af9b4ca6e1733">More...</a><br /></td></tr>
<tr class="separator:a617746ae8bd9b8bd6f8af9b4ca6e1733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8dc6485a44a31be59a8ed8a7892b33"><td class="memItemLeft" align="right" valign="top"><a id="acf8dc6485a44a31be59a8ed8a7892b33"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_fin_pushoff_fast_notice_</b> (void)</td></tr>
<tr class="separator:acf8dc6485a44a31be59a8ed8a7892b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d149dae481cdc7690c8268a8ee07a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ae1d149dae481cdc7690c8268a8ee07a4">kmr_find_key</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> ki, struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> *vo)</td></tr>
<tr class="memdesc:ae1d149dae481cdc7690c8268a8ee07a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a key-value pair for a key.  <a href="#ae1d149dae481cdc7690c8268a8ee07a4">More...</a><br /></td></tr>
<tr class="separator:ae1d149dae481cdc7690c8268a8ee07a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6134d913ad359d56c789a99fb668a0d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a6134d913ad359d56c789a99fb668a0d3">kmr_find_string</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, const char *k, const char **vq)</td></tr>
<tr class="memdesc:a6134d913ad359d56c789a99fb668a0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key K in the key-value stream KVS.  <a href="#a6134d913ad359d56c789a99fb668a0d3">More...</a><br /></td></tr>
<tr class="separator:a6134d913ad359d56c789a99fb668a0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f328ef113ef3d72d582ae2d91c888d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a9f328ef113ef3d72d582ae2d91c888d7">kmr_finish_swf</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr)</td></tr>
<tr class="memdesc:a9f328ef113ef3d72d582ae2d91c888d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the lanes of simple workflow.  <a href="#a9f328ef113ef3d72d582ae2d91c888d7">More...</a><br /></td></tr>
<tr class="separator:a9f328ef113ef3d72d582ae2d91c888d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d12efd914c8b60a54eb82b7a930ea7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ad7d12efd914c8b60a54eb82b7a930ea7">kmr_free_context</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr)</td></tr>
<tr class="memdesc:ad7d12efd914c8b60a54eb82b7a930ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a context created with <a class="el" href="kmrbase_8c.html#a562467c4832bfdb13027976e7eb9c5bf" title="Makes a new KMR context (a context has type KMR). ">kmr_create_context()</a>.  <a href="#ad7d12efd914c8b60a54eb82b7a930ea7">More...</a><br /></td></tr>
<tr class="separator:ad7d12efd914c8b60a54eb82b7a930ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642656490e91b16d31f4253e35d8e03c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a642656490e91b16d31f4253e35d8e03c">kmr_free_kvs</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs)</td></tr>
<tr class="memdesc:a642656490e91b16d31f4253e35d8e03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a key-value stream (type KMR_KVS).  <a href="#a642656490e91b16d31f4253e35d8e03c">More...</a><br /></td></tr>
<tr class="separator:a642656490e91b16d31f4253e35d8e03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb21fb4ad971112227ec9abc69dba222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#abb21fb4ad971112227ec9abc69dba222">kmr_free_swf_history</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr)</td></tr>
<tr class="memdesc:abb21fb4ad971112227ec9abc69dba222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the history recorded in <a class="el" href="kmrwfmap_8c.html#a3df4a8125b1af6129fce5de92822202e" title="Maps with a simple workflow. ">kmr_map_swf()</a>.  <a href="#abb21fb4ad971112227ec9abc69dba222">More...</a><br /></td></tr>
<tr class="separator:abb21fb4ad971112227ec9abc69dba222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231bcbf36132e5060fd738b9be937c3e"><td class="memItemLeft" align="right" valign="top"><a id="a231bcbf36132e5060fd738b9be937c3e"></a>
<a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_get_context_of_kvs</b> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> const *kvs)</td></tr>
<tr class="separator:a231bcbf36132e5060fd738b9be937c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161eaf42b3fb2855b6186ccf41fc72ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a161eaf42b3fb2855b6186ccf41fc72ab">kmr_get_element_count</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, long *v)</td></tr>
<tr class="memdesc:a161eaf42b3fb2855b6186ccf41fc72ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of key-value pairs.  <a href="#a161eaf42b3fb2855b6186ccf41fc72ab">More...</a><br /></td></tr>
<tr class="separator:a161eaf42b3fb2855b6186ccf41fc72ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47d401153aa4f75bc990384d9e78e74"><td class="memItemLeft" align="right" valign="top">MPI_Comm *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ae47d401153aa4f75bc990384d9e78e74">kmr_get_spawner_communicator</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, long index)</td></tr>
<tr class="memdesc:ae47d401153aa4f75bc990384d9e78e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains (a reference to) a parent inter-communicator of a spawned process.  <a href="#ae47d401153aa4f75bc990384d9e78e74">More...</a><br /></td></tr>
<tr class="separator:ae47d401153aa4f75bc990384d9e78e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e2c060cb87fa46364cae1e3038d47f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a40e2c060cb87fa46364cae1e3038d47f">kmr_histogram_count_by_ranks</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, long *frq, double *var, _Bool rankzeroonly)</td></tr>
<tr class="memdesc:a40e2c060cb87fa46364cae1e3038d47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an integer array FRQ[i] with the count of the elements of each rank.  <a href="#a40e2c060cb87fa46364cae1e3038d47f">More...</a><br /></td></tr>
<tr class="separator:a40e2c060cb87fa46364cae1e3038d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627632485088007e8b830231803e511f"><td class="memItemLeft" align="right" valign="top"><a id="a627632485088007e8b830231803e511f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_init_2</b> (int ignore)</td></tr>
<tr class="separator:a627632485088007e8b830231803e511f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577415d4b9c6db1113d099d712760097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a577415d4b9c6db1113d099d712760097">kmr_init_pushoff_fast_notice_</a> (MPI_Comm, _Bool verbose)</td></tr>
<tr class="memdesc:a577415d4b9c6db1113d099d712760097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes RDMA for fast-notice.  <a href="#a577415d4b9c6db1113d099d712760097">More...</a><br /></td></tr>
<tr class="separator:a577415d4b9c6db1113d099d712760097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95373baeff840380d1991cefad1c9556"><td class="memItemLeft" align="right" valign="top"><a id="a95373baeff840380d1991cefad1c9556"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_init_swf</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, MPI_Comm splitcomms[4], int master)</td></tr>
<tr class="separator:a95373baeff840380d1991cefad1c9556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b941c146f772ae389a84479d2ddcecc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a7b941c146f772ae389a84479d2ddcecc">kmr_initialize_mpi</a> (int *refargc, char ***refargv)</td></tr>
<tr class="memdesc:a7b941c146f772ae389a84479d2ddcecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the initialization state of MPI, and initializes MPI when not.  <a href="#a7b941c146f772ae389a84479d2ddcecc">More...</a><br /></td></tr>
<tr class="separator:a7b941c146f772ae389a84479d2ddcecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9680449d70d05834da4c0c44a2d8dc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#af9680449d70d05834da4c0c44a2d8dc5">kmr_legal_minimum_field_size</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a> f)</td></tr>
<tr class="memdesc:af9680449d70d05834da4c0c44a2d8dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a minimum byte size of the field: 8 for INTEGER and FLOAT8, 0 for others.  <a href="#af9680449d70d05834da4c0c44a2d8dc5">More...</a><br /></td></tr>
<tr class="separator:af9680449d70d05834da4c0c44a2d8dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb5934021b3cd6adc54ad66c615cbba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#acbb5934021b3cd6adc54ad66c615cbba">kmr_local_element_count</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, long *v)</td></tr>
<tr class="memdesc:acbb5934021b3cd6adc54ad66c615cbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of key-value pairs locally on each rank.  <a href="#acbb5934021b3cd6adc54ad66c615cbba">More...</a><br /></td></tr>
<tr class="separator:acbb5934021b3cd6adc54ad66c615cbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fa8ec979f8c9aa8c1b335595fea419"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a51fa8ec979f8c9aa8c1b335595fea419">kmr_map9</a> (_Bool stop_when_some_added, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m, const char *, const int, const char *)</td></tr>
<tr class="memdesc:a51fa8ec979f8c9aa8c1b335595fea419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps simply.  <a href="#a51fa8ec979f8c9aa8c1b335595fea419">More...</a><br /></td></tr>
<tr class="separator:a51fa8ec979f8c9aa8c1b335595fea419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc987ce7e41bef6c36346c5fb0eaf4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a0cc987ce7e41bef6c36346c5fb0eaf4b">kmr_map_file_names</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, char **names, int n, struct <a class="el" href="structkmr__file__option.html">kmr_file_option</a> fopt, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:a0cc987ce7e41bef6c36346c5fb0eaf4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps on file names.  <a href="#a0cc987ce7e41bef6c36346c5fb0eaf4b">More...</a><br /></td></tr>
<tr class="separator:a0cc987ce7e41bef6c36346c5fb0eaf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada07fb9d17822e3720c64976e3bc7fdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ada07fb9d17822e3720c64976e3bc7fdd">kmr_map_for_some</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:ada07fb9d17822e3720c64976e3bc7fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps until some key-value are added.  <a href="#ada07fb9d17822e3720c64976e3bc7fdd">More...</a><br /></td></tr>
<tr class="separator:ada07fb9d17822e3720c64976e3bc7fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82469cef31c4101143b5c012aac6da86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a82469cef31c4101143b5c012aac6da86">kmr_map_getline</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, FILE *f, long limit, _Bool largebuffering, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:a82469cef31c4101143b5c012aac6da86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a map-function M for each line by getline() on an input F.  <a href="#a82469cef31c4101143b5c012aac6da86">More...</a><br /></td></tr>
<tr class="separator:a82469cef31c4101143b5c012aac6da86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1332148da819ffba1b13699700b83c"><td class="memItemLeft" align="right" valign="top"><a id="adf1332148da819ffba1b13699700b83c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_map_getline_in_memory_</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, void *b, size_t sz, long limit, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="separator:adf1332148da819ffba1b13699700b83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d52c3c69250bf19dd28d5e38809df79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a9d52c3c69250bf19dd28d5e38809df79">kmr_map_ms</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:a9d52c3c69250bf19dd28d5e38809df79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps in master-worker mode.  <a href="#a9d52c3c69250bf19dd28d5e38809df79">More...</a><br /></td></tr>
<tr class="separator:a9d52c3c69250bf19dd28d5e38809df79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8a223da5a75d698ca59279bf1c7384"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a4f8a223da5a75d698ca59279bf1c7384">kmr_map_ms_commands</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> sopt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:a4f8a223da5a75d698ca59279bf1c7384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps in the master-worker mode, specialized to run serial commands.  <a href="#a4f8a223da5a75d698ca59279bf1c7384">More...</a><br /></td></tr>
<tr class="separator:a4f8a223da5a75d698ca59279bf1c7384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58641ce4b8c06e61f3e21606b7fed36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ab58641ce4b8c06e61f3e21606b7fed36">kmr_map_on_rank_zero</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:ab58641ce4b8c06e61f3e21606b7fed36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps on rank0 only.  <a href="#ab58641ce4b8c06e61f3e21606b7fed36">More...</a><br /></td></tr>
<tr class="separator:ab58641ce4b8c06e61f3e21606b7fed36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815a3eafd8bde396d34bbf5f39ba9783"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a815a3eafd8bde396d34bbf5f39ba9783">kmr_map_once</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, _Bool rank_zero_only, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:a815a3eafd8bde396d34bbf5f39ba9783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps once.  <a href="#a815a3eafd8bde396d34bbf5f39ba9783">More...</a><br /></td></tr>
<tr class="separator:a815a3eafd8bde396d34bbf5f39ba9783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309f2ef87bc5f4ec67d53a446cbb392e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a309f2ef87bc5f4ec67d53a446cbb392e">kmr_map_parallel_processes</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, MPI_Info info, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> mapfn)</td></tr>
<tr class="memdesc:a309f2ef87bc5f4ec67d53a446cbb392e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not communicate to the parent.  <a href="#a309f2ef87bc5f4ec67d53a446cbb392e">More...</a><br /></td></tr>
<tr class="separator:a309f2ef87bc5f4ec67d53a446cbb392e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ea39208f60d2f6ba895cafa0302a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a5b8ea39208f60d2f6ba895cafa0302a2">kmr_map_processes</a> (_Bool nonmpi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, MPI_Info info, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> mapfn)</td></tr>
<tr class="memdesc:a5b8ea39208f60d2f6ba895cafa0302a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps on processes started by MPI_Comm_spawn() to run independent processes.  <a href="#a5b8ea39208f60d2f6ba895cafa0302a2">More...</a><br /></td></tr>
<tr class="separator:a5b8ea39208f60d2f6ba895cafa0302a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ef3f88641461720d92c97ab4479be2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a40ef3f88641461720d92c97ab4479be2">kmr_map_rank_by_rank</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:a40ef3f88641461720d92c97ab4479be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps sequentially with rank by rank for debugging.  <a href="#a40ef3f88641461720d92c97ab4479be2">More...</a><br /></td></tr>
<tr class="separator:a40ef3f88641461720d92c97ab4479be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5120d3c93ea5a471ab040f94dbd29a41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a5120d3c93ea5a471ab040f94dbd29a41">kmr_map_serial_processes</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, MPI_Info info, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> mapfn)</td></tr>
<tr class="memdesc:a5120d3c93ea5a471ab040f94dbd29a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps on processes started by MPI_Comm_spawn() to run serial processes.  <a href="#a5120d3c93ea5a471ab040f94dbd29a41">More...</a><br /></td></tr>
<tr class="separator:a5120d3c93ea5a471ab040f94dbd29a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35056aed5f886230e5025acf35eda2ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a35056aed5f886230e5025acf35eda2ee">kmr_map_skipping</a> (long from, long stride, long limit, _Bool stop_when_some_added, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> m)</td></tr>
<tr class="memdesc:a35056aed5f886230e5025acf35eda2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps by skipping the number of entries.  <a href="#a35056aed5f886230e5025acf35eda2ee">More...</a><br /></td></tr>
<tr class="separator:a35056aed5f886230e5025acf35eda2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df4a8125b1af6129fce5de92822202e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a3df4a8125b1af6129fce5de92822202e">kmr_map_swf</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> mapfn)</td></tr>
<tr class="memdesc:a3df4a8125b1af6129fce5de92822202e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps with a simple workflow.  <a href="#a3df4a8125b1af6129fce5de92822202e">More...</a><br /></td></tr>
<tr class="separator:a3df4a8125b1af6129fce5de92822202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2502be0968e7f62404e02f8f445c7498"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a2502be0968e7f62404e02f8f445c7498">kmr_map_via_spawn</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, MPI_Info info, struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a> opt, <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a> mapfn)</td></tr>
<tr class="memdesc:a2502be0968e7f62404e02f8f445c7498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps on processes started by MPI_Comm_spawn().  <a href="#a2502be0968e7f62404e02f8f445c7498">More...</a><br /></td></tr>
<tr class="separator:a2502be0968e7f62404e02f8f445c7498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18d7541ca4f6e28c922edb006a388f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#af18d7541ca4f6e28c922edb006a388f4">kmr_match</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi0, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi1, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:af18d7541ca4f6e28c922edb006a388f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes key-value pairs as products of the two values in two key-value stream.  <a href="#af18d7541ca4f6e28c922edb006a388f4">More...</a><br /></td></tr>
<tr class="separator:af18d7541ca4f6e28c922edb006a388f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c607730747510fab9abcd2f8ed10fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a40c607730747510fab9abcd2f8ed10fe">kmr_move_kvs</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a40c607730747510fab9abcd2f8ed10fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the input KVI to the output KVO.  <a href="#a40c607730747510fab9abcd2f8ed10fe">More...</a><br /></td></tr>
<tr class="separator:a40c607730747510fab9abcd2f8ed10fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f319be6ce3801095704549460e36760"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structkmr__ntuple__entry.html">kmr_ntuple_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a3f319be6ce3801095704549460e36760">kmr_nth_ntuple</a> (struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u, int nth)</td></tr>
<tr class="memdesc:a3f319be6ce3801095704549460e36760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an NTH entry of an n-tuple.  <a href="#a3f319be6ce3801095704549460e36760">More...</a><br /></td></tr>
<tr class="separator:a3f319be6ce3801095704549460e36760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1ec5745abce4c3b711146b0d4f5ce6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#aea1ec5745abce4c3b711146b0d4f5ce6">kmr_pairing</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:aea1ec5745abce4c3b711146b0d4f5ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a value part with a key-value pairing.  <a href="#aea1ec5745abce4c3b711146b0d4f5ce6">More...</a><br /></td></tr>
<tr class="separator:aea1ec5745abce4c3b711146b0d4f5ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ca6a43e1cf0adc3210d06364ec104b"><td class="memItemLeft" align="right" valign="top"><a id="a22ca6a43e1cf0adc3210d06364ec104b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_print_statistics_on_pushoff</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, char *titlestring)</td></tr>
<tr class="separator:a22ca6a43e1cf0adc3210d06364ec104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93b6f23508e72e138849192235d17bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#aa93b6f23508e72e138849192235d17bb">kmr_product_ntuples</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> **vv[2], long cnt[2], int newmarker, int slots[][2], int nslots, int keys[][2], int nkeys)</td></tr>
<tr class="memdesc:aa93b6f23508e72e138849192235d17bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a direct product of the two sets of n-tuples VV[0] and VV[1] with their counts in CNT[0] and CNT[1].  <a href="#aa93b6f23508e72e138849192235d17bb">More...</a><br /></td></tr>
<tr class="separator:aa93b6f23508e72e138849192235d17bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcd7967a7d40208bcd55bd7f5ad1583"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a0bcd7967a7d40208bcd55bd7f5ad1583">kmr_put_ntuple</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u, const int sz, const void *v, const int vlen)</td></tr>
<tr class="memdesc:a0bcd7967a7d40208bcd55bd7f5ad1583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an entry V with LEN in an n-tuple U whose size is limited to SIZE.  <a href="#a0bcd7967a7d40208bcd55bd7f5ad1583">More...</a><br /></td></tr>
<tr class="separator:a0bcd7967a7d40208bcd55bd7f5ad1583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d88c46543a928148613cbe3ef3db8d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a8d88c46543a928148613cbe3ef3db8d1">kmr_put_ntuple_entry</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u, const int sz, struct <a class="el" href="structkmr__ntuple__entry.html">kmr_ntuple_entry</a> e)</td></tr>
<tr class="memdesc:a8d88c46543a928148613cbe3ef3db8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an n-tuple entry E in an n-tuple U whose size is limited to SIZE.  <a href="#a8d88c46543a928148613cbe3ef3db8d1">More...</a><br /></td></tr>
<tr class="separator:a8d88c46543a928148613cbe3ef3db8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683553c3f8d8cebecad43a2ec7ba858b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a683553c3f8d8cebecad43a2ec7ba858b">kmr_put_ntuple_long</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u, const int sz, long v)</td></tr>
<tr class="memdesc:a683553c3f8d8cebecad43a2ec7ba858b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an integer value in an n-tuple U whose size is limited to SIZE.  <a href="#a683553c3f8d8cebecad43a2ec7ba858b">More...</a><br /></td></tr>
<tr class="separator:a683553c3f8d8cebecad43a2ec7ba858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8d470979d2edbc1d1af235f150e89e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a7d8d470979d2edbc1d1af235f150e89e">kmr_ranking</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, long *count, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a7d8d470979d2edbc1d1af235f150e89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a ranking to key-value pairs, and returns the number of the total elements in COUNT.  <a href="#a7d8d470979d2edbc1d1af235f150e89e">More...</a><br /></td></tr>
<tr class="separator:a7d8d470979d2edbc1d1af235f150e89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa595f06609d414e074f50f3009a90c8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#aa595f06609d414e074f50f3009a90c8f">kmr_read_file_by_segments</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, char *file, int color, void **buffer, off_t *readsize)</td></tr>
<tr class="memdesc:aa595f06609d414e074f50f3009a90c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one file by segments and reassembles by all-gather.  <a href="#aa595f06609d414e074f50f3009a90c8f">More...</a><br /></td></tr>
<tr class="separator:aa595f06609d414e074f50f3009a90c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f87c0c3724460402376ef81d0efa76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a78f87c0c3724460402376ef81d0efa76">kmr_read_files_reassemble</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, char *file, int color, off_t offset, off_t bytes, void **buffer, off_t *readsize)</td></tr>
<tr class="memdesc:a78f87c0c3724460402376ef81d0efa76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reassembles files reading by ranks.  <a href="#a78f87c0c3724460402376ef81d0efa76">More...</a><br /></td></tr>
<tr class="separator:a78f87c0c3724460402376ef81d0efa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e4b71fc1aa9386021576dd9c186b85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a98e4b71fc1aa9386021576dd9c186b85">kmr_receive_kvs_from_spawned_fn</a> (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, const long index)</td></tr>
<tr class="memdesc:a98e4b71fc1aa9386021576dd9c186b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects key-value pairs generated by spawned processes.  <a href="#a98e4b71fc1aa9386021576dd9c186b85">More...</a><br /></td></tr>
<tr class="separator:a98e4b71fc1aa9386021576dd9c186b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12353f5489c900ad078fbd96d2a92e55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a12353f5489c900ad078fbd96d2a92e55">kmr_reduce9</a> (_Bool stop_when_some_added, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a> r, const char *, const int, const char *)</td></tr>
<tr class="memdesc:a12353f5489c900ad078fbd96d2a92e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces key-value pairs.  <a href="#a12353f5489c900ad078fbd96d2a92e55">More...</a><br /></td></tr>
<tr class="separator:a12353f5489c900ad078fbd96d2a92e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875e0b3ce874d08f5778854dc21eb70a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a875e0b3ce874d08f5778854dc21eb70a">kmr_reduce_as_one</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a> r)</td></tr>
<tr class="memdesc:a875e0b3ce874d08f5778854dc21eb70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a reduce-function once as if all key-value pairs had the same key.  <a href="#a875e0b3ce874d08f5778854dc21eb70a">More...</a><br /></td></tr>
<tr class="separator:a875e0b3ce874d08f5778854dc21eb70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860590f8d6fd3ac6a1ec80255d380aa2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a860590f8d6fd3ac6a1ec80255d380aa2">kmr_reduce_for_some</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt, <a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a> r)</td></tr>
<tr class="memdesc:a860590f8d6fd3ac6a1ec80255d380aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces until some key-value are added.  <a href="#a860590f8d6fd3ac6a1ec80255d380aa2">More...</a><br /></td></tr>
<tr class="separator:a860590f8d6fd3ac6a1ec80255d380aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d9a689d79d64bcfa10d61c1d335ee7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a64d9a689d79d64bcfa10d61c1d335ee7">kmr_replicate</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a64d9a689d79d64bcfa10d61c1d335ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicates key-value pairs to be visible on all ranks, that is, it has the effect of bcast or all-gather.  <a href="#a64d9a689d79d64bcfa10d61c1d335ee7">More...</a><br /></td></tr>
<tr class="separator:a64d9a689d79d64bcfa10d61c1d335ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b0a9f5e3679c03c283c97f99cfed59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ae6b0a9f5e3679c03c283c97f99cfed59">kmr_reply_to_spawner</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr)</td></tr>
<tr class="memdesc:ae6b0a9f5e3679c03c283c97f99cfed59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a reply message in the spawned process, which tells it is ready to finish and may have some data to send to the spawner in <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a>.  <a href="#ae6b0a9f5e3679c03c283c97f99cfed59">More...</a><br /></td></tr>
<tr class="separator:ae6b0a9f5e3679c03c283c97f99cfed59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ae0218d80610afda9c102dc3d19203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#af0ae0218d80610afda9c102dc3d19203">kmr_reset_ntuple</a> (struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u, int n, int marker)</td></tr>
<tr class="memdesc:af0ae0218d80610afda9c102dc3d19203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets an n-tuple U with N entries and a MARKER.  <a href="#af0ae0218d80610afda9c102dc3d19203">More...</a><br /></td></tr>
<tr class="separator:af0ae0218d80610afda9c102dc3d19203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc6c6968706bc28d58ad00391125754"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#aebc6c6968706bc28d58ad00391125754">kmr_restore_kvs</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *data, size_t sz, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:aebc6c6968706bc28d58ad00391125754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks locally the contents of a key-value stream from a byte array.  <a href="#aebc6c6968706bc28d58ad00391125754">More...</a><br /></td></tr>
<tr class="separator:aebc6c6968706bc28d58ad00391125754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45f26e655a43257fa25c65d429d89a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ad45f26e655a43257fa25c65d429d89a6">kmr_retrieve_keyed_records</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, struct <a class="el" href="structkmr__keyed__record.html">kmr_keyed_record</a> *ev, long n, _Bool shuffling, _Bool ranking)</td></tr>
<tr class="memdesc:ad45f26e655a43257fa25c65d429d89a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills keyed records in an array for sorting.  <a href="#ad45f26e655a43257fa25c65d429d89a6">More...</a><br /></td></tr>
<tr class="separator:ad45f26e655a43257fa25c65d429d89a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3a4ea5fb90e2ae731d6dc940534f3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a1f3a4ea5fb90e2ae731d6dc940534f3e">kmr_retrieve_kv_box_entries</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> *ev, long n)</td></tr>
<tr class="memdesc:a1f3a4ea5fb90e2ae731d6dc940534f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills local key-value entries in an array of <a class="el" href="structkmr__kv__box.html" title="Handy Copy of a Key-Value Field. ">kmr_kv_box</a> for inspection.  <a href="#a1f3a4ea5fb90e2ae731d6dc940534f3e">More...</a><br /></td></tr>
<tr class="separator:a1f3a4ea5fb90e2ae731d6dc940534f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989c9114805481b0eda194ba7098e442"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a989c9114805481b0eda194ba7098e442">kmr_retrieve_kvs_entries</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs, struct <a class="el" href="structkmr__kvs__entry.html">kmr_kvs_entry</a> **ev, long n)</td></tr>
<tr class="memdesc:a989c9114805481b0eda194ba7098e442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills local key-value entries in an array for inspection.  <a href="#a989c9114805481b0eda194ba7098e442">More...</a><br /></td></tr>
<tr class="separator:a989c9114805481b0eda194ba7098e442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50e7437f8d24e7c50927f21b0ad9d44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#aa50e7437f8d24e7c50927f21b0ad9d44">kmr_reverse</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:aa50e7437f8d24e7c50927f21b0ad9d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new pair by swapping the key and the value in each pair.  <a href="#aa50e7437f8d24e7c50927f21b0ad9d44">More...</a><br /></td></tr>
<tr class="separator:aa50e7437f8d24e7c50927f21b0ad9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab676a31f6cfd76b38ad5f86b4a09f81d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ab676a31f6cfd76b38ad5f86b4a09f81d">kmr_save_kvs</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, void **dataq, size_t *szq, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:ab676a31f6cfd76b38ad5f86b4a09f81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs locally the contents of a key-value stream to a byte array.  <a href="#ab676a31f6cfd76b38ad5f86b4a09f81d">More...</a><br /></td></tr>
<tr class="separator:ab676a31f6cfd76b38ad5f86b4a09f81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73f60e170d05de96b3dc5bb4878d9df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#aa73f60e170d05de96b3dc5bb4878d9df">kmr_scan_locally</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *carryin, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *carryout, <a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a> r)</td></tr>
<tr class="memdesc:aa73f60e170d05de96b3dc5bb4878d9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans every key-value with a reduce-function locally (independently on each rank).  <a href="#aa73f60e170d05de96b3dc5bb4878d9df">More...</a><br /></td></tr>
<tr class="separator:aa73f60e170d05de96b3dc5bb4878d9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73733e98faa5ee96665d415ef2044333"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a73733e98faa5ee96665d415ef2044333">kmr_scan_on_values</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *total, <a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a> r)</td></tr>
<tr class="memdesc:a73733e98faa5ee96665d415ef2044333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix-scans every key-value with a reduce-function (non-self-inclusively) and generates the final value in TOTAL (it generates the same value on all the ranks in the TOTAL).  <a href="#a73733e98faa5ee96665d415ef2044333">More...</a><br /></td></tr>
<tr class="separator:a73733e98faa5ee96665d415ef2044333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f2e46ad4e40fb0f7140ffbf6da58e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a14f2e46ad4e40fb0f7140ffbf6da58e7">kmr_send_kvs_to_spawner</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvs)</td></tr>
<tr class="memdesc:a14f2e46ad4e40fb0f7140ffbf6da58e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the KVS from a spawned process to the map-function of the spawner.  <a href="#a14f2e46ad4e40fb0f7140ffbf6da58e7">More...</a><br /></td></tr>
<tr class="separator:a14f2e46ad4e40fb0f7140ffbf6da58e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c13b06c526421dbe8499416fff0ced"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ab4c13b06c526421dbe8499416fff0ced">kmr_separate_ntuples</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv[], const long n, struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> **vv[2], long cnt[2], int markers[2], _Bool disallow_other_entries)</td></tr>
<tr class="memdesc:ab4c13b06c526421dbe8499416fff0ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates the n-tuples stored in the value part of KV into the two sets by their marker values.  <a href="#ab4c13b06c526421dbe8499416fff0ced">More...</a><br /></td></tr>
<tr class="separator:ab4c13b06c526421dbe8499416fff0ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34aac60d0099ad33e3c9746dc7b9be9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#af34aac60d0099ad33e3c9746dc7b9be9">kmr_set_swf_verbosity</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, int level)</td></tr>
<tr class="memdesc:af34aac60d0099ad33e3c9746dc7b9be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the verbosity of the spawn-library.  <a href="#af34aac60d0099ad33e3c9746dc7b9be9">More...</a><br /></td></tr>
<tr class="separator:af34aac60d0099ad33e3c9746dc7b9be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194686701b3c46a869fe9eb2cab93252"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a194686701b3c46a869fe9eb2cab93252">kmr_shuffle</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a194686701b3c46a869fe9eb2cab93252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles key-value pairs to the appropriate destination ranks.  <a href="#a194686701b3c46a869fe9eb2cab93252">More...</a><br /></td></tr>
<tr class="separator:a194686701b3c46a869fe9eb2cab93252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e89bd7e35b3d0a403c7fb61e3d8b087"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a6e89bd7e35b3d0a403c7fb61e3d8b087">kmr_shuffle_leveling_pair_count</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo)</td></tr>
<tr class="memdesc:a6e89bd7e35b3d0a403c7fb61e3d8b087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles key-values so that each rank has approximately the same number of pairs.  <a href="#a6e89bd7e35b3d0a403c7fb61e3d8b087">More...</a><br /></td></tr>
<tr class="separator:a6e89bd7e35b3d0a403c7fb61e3d8b087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d092c5a560c5df86729a383aa6e7fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a05d092c5a560c5df86729a383aa6e7fe">kmr_size_ntuple</a> (struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *u)</td></tr>
<tr class="memdesc:a05d092c5a560c5df86729a383aa6e7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the storage size of an n-tuple.  <a href="#a05d092c5a560c5df86729a383aa6e7fe">More...</a><br /></td></tr>
<tr class="separator:a05d092c5a560c5df86729a383aa6e7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae398c2918a0097eb20f50b1ffb21c1da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ae398c2918a0097eb20f50b1ffb21c1da">kmr_size_ntuple_by_lengths</a> (int n, int len[])</td></tr>
<tr class="memdesc:ae398c2918a0097eb20f50b1ffb21c1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the storage size of an n-tuple for N entries with LEN[i] size each.  <a href="#ae398c2918a0097eb20f50b1ffb21c1da">More...</a><br /></td></tr>
<tr class="separator:ae398c2918a0097eb20f50b1ffb21c1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dc49274f766b46b16ec77b0217c6ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a43dc49274f766b46b16ec77b0217c6ca">kmr_sort</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a43dc49274f766b46b16ec77b0217c6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a key-value stream globally.  <a href="#a43dc49274f766b46b16ec77b0217c6ca">More...</a><br /></td></tr>
<tr class="separator:a43dc49274f766b46b16ec77b0217c6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab020cce7e7f28f0937fc71a03bc759"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a6ab020cce7e7f28f0937fc71a03bc759">kmr_sort_by_one</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a6ab020cce7e7f28f0937fc71a03bc759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort by rank0, a degenerated case for small number of keys.  <a href="#a6ab020cce7e7f28f0937fc71a03bc759">More...</a><br /></td></tr>
<tr class="separator:a6ab020cce7e7f28f0937fc71a03bc759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee642a4f300cc31d6e86cdc6064d177"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a2ee642a4f300cc31d6e86cdc6064d177">kmr_sort_large</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a2ee642a4f300cc31d6e86cdc6064d177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a key-value stream by the regular or the random sampling-sort.  <a href="#a2ee642a4f300cc31d6e86cdc6064d177">More...</a><br /></td></tr>
<tr class="separator:a2ee642a4f300cc31d6e86cdc6064d177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b1acc032c1e378030ce36ed4ee68f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a44b1acc032c1e378030ce36ed4ee68f9">kmr_sort_locally</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, _Bool shuffling, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a44b1acc032c1e378030ce36ed4ee68f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders key-value pairs in a single rank.  <a href="#a44b1acc032c1e378030ce36ed4ee68f9">More...</a><br /></td></tr>
<tr class="separator:a44b1acc032c1e378030ce36ed4ee68f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4206dfa415bd8d42e836a4fbf0838f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a1f4206dfa415bd8d42e836a4fbf0838f">kmr_sort_small</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a1f4206dfa415bd8d42e836a4fbf0838f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a key-value stream, by partitioning to equal ranges.  <a href="#a1f4206dfa415bd8d42e836a4fbf0838f">More...</a><br /></td></tr>
<tr class="separator:a1f4206dfa415bd8d42e836a4fbf0838f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35aca080b4f3859be88dfae338e0e304"><td class="memItemLeft" align="right" valign="top"><a id="a35aca080b4f3859be88dfae338e0e304"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_split_swf_lanes</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, MPI_Comm splitcomms[4], int root, char *description[], _Bool dump)</td></tr>
<tr class="separator:a35aca080b4f3859be88dfae338e0e304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13c7751f37c093ffff038c9b600e766"><td class="memItemLeft" align="right" valign="top"><a id="aa13c7751f37c093ffff038c9b600e766"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_split_swf_lanes_a</b> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr, MPI_Comm splitcomms[4], int root, int *description[], _Bool dump)</td></tr>
<tr class="separator:aa13c7751f37c093ffff038c9b600e766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbeb040b750ed83c978d8f92570780b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a1dbeb040b750ed83c978d8f92570780b">kmr_stop_swf_workers</a> (<a class="el" href="structkmr__ctx.html">KMR</a> *mr)</td></tr>
<tr class="memdesc:a1dbeb040b750ed83c978d8f92570780b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes the workers of workflow.  <a href="#a1dbeb040b750ed83c978d8f92570780b">More...</a><br /></td></tr>
<tr class="separator:a1dbeb040b750ed83c978d8f92570780b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cc00c0639b9d904e1aca7035c30f47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a89cc00c0639b9d904e1aca7035c30f47">kmr_take_one</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> *kv)</td></tr>
<tr class="memdesc:a89cc00c0639b9d904e1aca7035c30f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a single key-value pair locally in the key-value stream KVI.  <a href="#a89cc00c0639b9d904e1aca7035c30f47">More...</a><br /></td></tr>
<tr class="separator:a89cc00c0639b9d904e1aca7035c30f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523095ec2296b560d815d7e082dcb4b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#a523095ec2296b560d815d7e082dcb4b1">kmr_unpairing</a> (<a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, struct <a class="el" href="structkmr__option.html">kmr_option</a> opt)</td></tr>
<tr class="memdesc:a523095ec2296b560d815d7e082dcb4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a key-value pair from a pairing in the value part, discarding the original key.  <a href="#a523095ec2296b560d815d7e082dcb4b1">More...</a><br /></td></tr>
<tr class="separator:a523095ec2296b560d815d7e082dcb4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8d55d5605bb8f808adde62ed9521d3b8"><td class="memItemLeft" align="right" valign="top"><a id="a8d55d5605bb8f808adde62ed9521d3b8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>KMR_API_ID</b></td></tr>
<tr class="separator:a8d55d5605bb8f808adde62ed9521d3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec3d37773a6f291ae070fd5311f740f"><td class="memItemLeft" align="right" valign="top"><a id="aeec3d37773a6f291ae070fd5311f740f"></a>
static const struct <a class="el" href="structkmr__file__option.html">kmr_file_option</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_fnoopt</b> = {0, 0, 0, 0}</td></tr>
<tr class="separator:aeec3d37773a6f291ae070fd5311f740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2029580cfd4571dcc35d86425a20100"><td class="memItemLeft" ><a id="ad2029580cfd4571dcc35d86425a20100"></a>
union {</td></tr>
<tr class="memitem:a6316466a993f389d6828bd103308f2a6"><td class="memItemLeft" >
&#160;&#160;&#160;unsigned long&#160;&#160;&#160;<b>bits</b></td></tr>
<tr class="separator:a6316466a993f389d6828bd103308f2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4210640cf475477e48e9cc5bcb3f7450"><td class="memItemLeft" >
&#160;&#160;&#160;struct <a class="el" href="structkmr__file__option.html">kmr_file_option</a>&#160;&#160;&#160;<b>o</b></td></tr>
<tr class="separator:a4210640cf475477e48e9cc5bcb3f7450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2029580cfd4571dcc35d86425a20100"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_foptmask</b> = {{1, 1, 1, 1}}</td></tr>
<tr class="separator:ad2029580cfd4571dcc35d86425a20100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf510962409606fc43d5450acfd970d"><td class="memItemLeft" align="right" valign="top"><a id="accf510962409606fc43d5450acfd970d"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_kvs_block_header</b> = offsetof(struct <a class="el" href="structkmr__kvs__block.html">kmr_kvs_block</a>, data)</td></tr>
<tr class="separator:accf510962409606fc43d5450acfd970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32d00f09d32a01e62b55a9444e23643"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmr_8h.html#ac32d00f09d32a01e62b55a9444e23643">kmr_kvs_entry_header</a> = offsetof(struct <a class="el" href="structkmr__kvs__entry.html">kmr_kvs_entry</a>, c)</td></tr>
<tr class="memdesc:ac32d00f09d32a01e62b55a9444e23643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of an Entry Header.  <a href="#ac32d00f09d32a01e62b55a9444e23643">More...</a><br /></td></tr>
<tr class="separator:ac32d00f09d32a01e62b55a9444e23643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f801cc6986c572efb0a33b3ca63790f"><td class="memItemLeft" align="right" valign="top"><a id="a1f801cc6986c572efb0a33b3ca63790f"></a>
static const struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_noopt</b> = {0, 0, 0, 0, 0, 0, 0}</td></tr>
<tr class="separator:a1f801cc6986c572efb0a33b3ca63790f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0811a57c8b9980940457937e0dbd95"><td class="memItemLeft" ><a id="aac0811a57c8b9980940457937e0dbd95"></a>
union {</td></tr>
<tr class="memitem:aff436c80d3d3c4ce0e2898526cb68f3c"><td class="memItemLeft" >
&#160;&#160;&#160;unsigned long&#160;&#160;&#160;<b>bits</b></td></tr>
<tr class="separator:aff436c80d3d3c4ce0e2898526cb68f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a45e803ea6477747806e49d92c0f82"><td class="memItemLeft" >
&#160;&#160;&#160;struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;&#160;&#160;<b>o</b></td></tr>
<tr class="separator:a08a45e803ea6477747806e49d92c0f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0811a57c8b9980940457937e0dbd95"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_optmask</b> = {{1, 1, 1, 1, 1, 1, 1}}</td></tr>
<tr class="separator:aac0811a57c8b9980940457937e0dbd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c927441a424ad0f25a18354636bf8fa"><td class="memItemLeft" align="right" valign="top"><a id="a4c927441a424ad0f25a18354636bf8fa"></a>
static const struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_snoopt</b> = {0, 0, 0, 0, 0}</td></tr>
<tr class="separator:a4c927441a424ad0f25a18354636bf8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99b777c7d7fa36ab9c0475672f1d735"><td class="memItemLeft" ><a id="ac99b777c7d7fa36ab9c0475672f1d735"></a>
union {</td></tr>
<tr class="memitem:a4e18b4730346b49e404c92e12c58aaba"><td class="memItemLeft" >
&#160;&#160;&#160;unsigned long&#160;&#160;&#160;<b>bits</b></td></tr>
<tr class="separator:a4e18b4730346b49e404c92e12c58aaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddffee3c23c77cb11c3486a7e027f36"><td class="memItemLeft" >
&#160;&#160;&#160;struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;&#160;&#160;<b>o</b></td></tr>
<tr class="separator:abddffee3c23c77cb11c3486a7e027f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99b777c7d7fa36ab9c0475672f1d735"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_soptmask</b> = {{1, 1, 1, 1, 1}}</td></tr>
<tr class="separator:ac99b777c7d7fa36ab9c0475672f1d735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e13852b4131896b618aa499b77548d"><td class="memItemLeft" align="right" valign="top"><a id="a88e13852b4131896b618aa499b77548d"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kmr_version</b></td></tr>
<tr class="separator:a88e13852b4131896b618aa499b77548d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>KMR Interface. </p>
<p>GENERAL NOTES. (1) The sizes of key-value fields are rounded up to 8-byte boundary. </p>

<p class="definition">Definition in file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a46c2d3225f6c9b2270a53aeda160b531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c2d3225f6c9b2270a53aeda160b531">&#9670;&nbsp;</a></span>kmr_create_kvsx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define kmr_create_kvsx</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">KF, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">VF, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OPT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="kmrbase_8c.html#ade6559203d1471e48688314ba729758a">kmr_create_kvs7</a>((MR), (KF), (VF), (OPT), __FILE__, __LINE__, __func__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a new key-value stream (of type KMR_KVS) with the specified field datatypes. </p>

<p class="definition">Definition at line <a class="el" href="kmr_8h_source.html#l00065">65</a> of file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>

</div>
</div>
<a id="a5c5006dd70e399d546c5345142f72f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5006dd70e399d546c5345142f72f6d">&#9670;&nbsp;</a></span>kmr_create_kvs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define kmr_create_kvs</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">KF, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">VF&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="kmrbase_8c.html#ade6559203d1471e48688314ba729758a">kmr_create_kvs7</a>((MR), (KF), (VF), kmr_noopt, __FILE__, __LINE__, __func__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a new key-value stream (of type KMR_KVS) with the specified field datatypes. </p>

<p class="definition">Definition at line <a class="el" href="kmr_8h_source.html#l00071">71</a> of file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>

</div>
</div>
<a id="a8859b6257ddb9eb9e87d5b8b49b7f784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8859b6257ddb9eb9e87d5b8b49b7f784">&#9670;&nbsp;</a></span>kmr_create_kvs_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define kmr_create_kvs_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">IGNORE&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="kmr_8h.html#aab1da5f26069d7daa2b1b88ae00b07a0">kmr_create_kvs7</a>((MR), KMR_KV_BAD, KMR_KV_BAD, kmr_noopt, \</div><div class="line">                    __FILE__, __LINE__, __func__)</div><div class="ttc" id="kmr_8h_html_aab1da5f26069d7daa2b1b88ae00b07a0"><div class="ttname"><a href="kmr_8h.html#aab1da5f26069d7daa2b1b88ae00b07a0">kmr_create_kvs7</a></div><div class="ttdeci">KMR_KVS * kmr_create_kvs7(KMR *mr, enum kmr_kv_field k, enum kmr_kv_field v, struct kmr_option opt, const char *, const int, const char *)</div><div class="ttdoc">Makes a new key-value stream with the specified field data-types. </div><div class="ttdef"><b>Definition:</b> <a href="kmrbase_8c_source.html#l00568">kmrbase.c:568</a></div></div>
</div><!-- fragment -->
<p>Makes a new key-value stream (of type KMR_KVS). </p>

<p class="definition">Definition at line <a class="el" href="kmr_8h_source.html#l00076">76</a> of file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>

</div>
</div>
<a id="a7bb545fb804c554dfc05baab4c8abf8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb545fb804c554dfc05baab4c8abf8d">&#9670;&nbsp;</a></span>kmr_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define kmr_map</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">KVI, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">KVO, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ARG, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OPT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="kmr_8h.html#a51fa8ec979f8c9aa8c1b335595fea419">kmr_map9</a>(0, (KVI), (KVO), (ARG), (OPT), (M), \</div><div class="line">             __FILE__, __LINE__, __func__)</div><div class="ttc" id="kmr_8h_html_a51fa8ec979f8c9aa8c1b335595fea419"><div class="ttname"><a href="kmr_8h.html#a51fa8ec979f8c9aa8c1b335595fea419">kmr_map9</a></div><div class="ttdeci">int kmr_map9(_Bool stop_when_some_added, KMR_KVS *kvi, KMR_KVS *kvo, void *arg, struct kmr_option opt, kmr_mapfn_t m, const char *, const int, const char *)</div><div class="ttdoc">Maps simply. </div><div class="ttdef"><b>Definition:</b> <a href="kmrbase_8c_source.html#l01347">kmrbase.c:1347</a></div></div>
</div><!-- fragment -->
<p>Maps simply. </p>
<p>See <a class="el" href="kmr_8h.html#a51fa8ec979f8c9aa8c1b335595fea419" title="Maps simply. ">kmr_map9()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmr_8h_source.html#l00082">82</a> of file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>

</div>
</div>
<a id="ae06cb9083e42011c9fa019add7bc228f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06cb9083e42011c9fa019add7bc228f">&#9670;&nbsp;</a></span>kmr_reduce</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define kmr_reduce</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">KVI, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">KVO, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ARG, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OPT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">R&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="kmr_8h.html#a12353f5489c900ad078fbd96d2a92e55">kmr_reduce9</a>(0, (KVI), (KVO), (ARG), (OPT), (R), \</div><div class="line">                __FILE__, __LINE__, __func__)</div><div class="ttc" id="kmr_8h_html_a12353f5489c900ad078fbd96d2a92e55"><div class="ttname"><a href="kmr_8h.html#a12353f5489c900ad078fbd96d2a92e55">kmr_reduce9</a></div><div class="ttdeci">int kmr_reduce9(_Bool stop_when_some_added, KMR_KVS *kvi, KMR_KVS *kvo, void *arg, struct kmr_option opt, kmr_redfn_t r, const char *, const int, const char *)</div><div class="ttdoc">Reduces key-value pairs. </div><div class="ttdef"><b>Definition:</b> <a href="kmrbase_8c_source.html#l02607">kmrbase.c:2607</a></div></div>
</div><!-- fragment -->
<p>Reduces key-value pairs. </p>
<p>See <a class="el" href="kmr_8h.html#a12353f5489c900ad078fbd96d2a92e55" title="Reduces key-value pairs. ">kmr_reduce9()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmr_8h_source.html#l00088">88</a> of file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>

</div>
</div>
<a id="a381842d6d102e60fe54893745fc21cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381842d6d102e60fe54893745fc21cef">&#9670;&nbsp;</a></span>KMR_KVS_MAGIC_OK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KMR_KVS_MAGIC_OK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((X) == KMR_KVS_ONCORE || (X) == KMR_KVS_ONCORE_PACKED \</div><div class="line">     || (X) == KMR_KVS_PUSHOFF)</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="kmr_8h_source.html#l00442">442</a> of file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>

</div>
</div>
<a id="a89dc005f93cbfdcdb0eebc302350a912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89dc005f93cbfdcdb0eebc302350a912">&#9670;&nbsp;</a></span>kmr_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define kmr_init</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;kmr_init_2(KMR_API_ID)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the environment. </p>
<p>Currently it does nothing. </p>

<p class="definition">Definition at line <a class="el" href="kmr_8h_source.html#l00794">794</a> of file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a710ca6341d4cbe82f7e62d0f63c19ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710ca6341d4cbe82f7e62d0f63c19ebb">&#9670;&nbsp;</a></span>kmr_mapfn_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* kmr_mapfn_t) (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg, const long index)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map-function Type. </p>
<p>A map-function gets a key-value pair as struct <a class="el" href="structkmr__kv__box.html" title="Handy Copy of a Key-Value Field. ">kmr_kv_box</a> KV. KVI is the input key-value stream, but it can be usually ignored (its potential usage is to check the content type of the key and value fields). KVO is the output key-value stream. The pointer ARG is one just passed to <a class="el" href="kmr_8h.html#a7bb545fb804c554dfc05baab4c8abf8d" title="Maps simply. ">kmr_map()</a>, which has no specific purpose and is used to pass any argument to a map-function. INDEX is the count of map-function calls, and it usually equals to the index of a key-value pair in the input. It is assured distinct, and can be used for race-free accesses to the pointer ARG. </p>

<p class="definition">Definition at line <a class="el" href="kmr_8h_source.html#l00736">736</a> of file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>

</div>
</div>
<a id="af4e0b7a58968aad22188408a00131760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e0b7a58968aad22188408a00131760">&#9670;&nbsp;</a></span>kmr_redfn_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* kmr_redfn_t) (const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> kv[], const long n, const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvi, <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *kvo, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce-function Type. </p>
<p>A reduce-function gets key-value pairs as an array KV of struct <a class="el" href="structkmr__kv__box.html" title="Handy Copy of a Key-Value Field. ">kmr_kv_box</a>. N is the number of key-value pairs. KVI is the the input key-value stream, but it can be usually ignored. KVO is the output key-value stream. The pointer ARG is one just passed to <a class="el" href="kmr_8h.html#ae06cb9083e42011c9fa019add7bc228f" title="Reduces key-value pairs. ">kmr_reduce()</a>, which has no specific purpose and is used to pass any argument to a reduce-function. </p>

<p class="definition">Definition at line <a class="el" href="kmr_8h_source.html#l00747">747</a> of file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0d4f610f2dcd147372fc8798171da01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4f610f2dcd147372fc8798171da01b">&#9670;&nbsp;</a></span>kmr_kv_field</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Datatypes of Keys or Values. </p>
<p>It indicates the field data of keys or values. KMR_KV_OPAQUE is a variable-sized byte vector, and KMR_KV_CSTRING is a non-wide C string, and they are dealt with in exactly the same way. KMR_KV_INTEGER is a long integer, and KMR_KV_FLOAT8 is a double. The datatypes are mostly uninterpreted in mapping/reducing, except for in sorting. There are two other types for pointers. Pointers can be stored as they are (unlike opaque data, which are embedded in the field), but converted to opaque ones before communication. KMR_KV_POINTER_OWNED is an allocated pointer, and the data will be freed on consuming a key-value stream. KMR_KV_POINTER_UNMANAGED is a pointer to a possibly shared data. </p>

<p class="definition">Definition at line <a class="el" href="kmr_8h_source.html#l00368">368</a> of file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a617746ae8bd9b8bd6f8af9b4ca6e1733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617746ae8bd9b8bd6f8af9b4ca6e1733">&#9670;&nbsp;</a></span>kmr_fin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_fin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the environment. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00124">124</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a7b941c146f772ae389a84479d2ddcecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b941c146f772ae389a84479d2ddcecc">&#9670;&nbsp;</a></span>kmr_initialize_mpi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_initialize_mpi </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>refargc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>refargv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the initialization state of MPI, and initializes MPI when not. </p>
<p>It returns 1, or 0 when something is wrong. It is for the Python binding. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00134">134</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a41b105ad6655dbba1b821179bad3fdd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b105ad6655dbba1b821179bad3fdd4">&#9670;&nbsp;</a></span>kmr_create_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkmr__ctx.html">KMR</a>* kmr_create_context </td>
          <td>(</td>
          <td class="paramtype">const MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Info&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>identifying_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a new KMR context (a context has type KMR). </p>
<p>A KMR context is a record of common information to all key-value streams. COMM is a communicator for use inside. It dups the given communicator inside, to avoid conflicts with other calls to MPI functions. MPI should be initialized with a thread support level of either MPI_THREAD_SERIALIZED or MPI_THREAD_MULTIPLE. CONF specifies configuration options. It should be freed after a call. The options can differ on each rank, (in this version). The configuration options are first taken from a file with a name specified by the environment variable "KMROPTION" on rank0, and they are merged with the explicitly given ones. The KMROPTION file has the file format of Java properties (but only in Latin characters). Refer to JDK documents on "java.util.Properties" (on "load" method) for the file format. The explicitly given ones have precedence. IDENTIFYING_NAME is just recorded in the context, and has no specific use. It may be null. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00168">168</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="ad7d12efd914c8b60a54eb82b7a930ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d12efd914c8b60a54eb82b7a930ea7">&#9670;&nbsp;</a></span>kmr_free_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_free_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a context created with <a class="el" href="kmrbase_8c.html#a562467c4832bfdb13027976e7eb9c5bf" title="Makes a new KMR context (a context has type KMR). ">kmr_create_context()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00367">367</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="aab1da5f26069d7daa2b1b88ae00b07a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1da5f26069d7daa2b1b88ae00b07a0">&#9670;&nbsp;</a></span>kmr_create_kvs7()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a>* kmr_create_kvs7 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a>&#160;</td>
          <td class="paramname"><em>kf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a>&#160;</td>
          <td class="paramname"><em>vf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a new key-value stream with the specified field data-types. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00568">568</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a642656490e91b16d31f4253e35d8e03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642656490e91b16d31f4253e35d8e03c">&#9670;&nbsp;</a></span>kmr_free_kvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_free_kvs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a key-value stream (type KMR_KVS). </p>
<p>Normally, mapper/shuffler/reducer consumes and frees the input key-value stream, and explicit calls are unnecessary. Here, mapper/shuffler/reducer includes <a class="el" href="kmr_8h.html#a7bb545fb804c554dfc05baab4c8abf8d" title="Maps simply. ">kmr_map()</a>, <a class="el" href="kmrbase_8c.html#ab58641ce4b8c06e61f3e21606b7fed36" title="Maps on rank0 only. ">kmr_map_on_rank_zero()</a>, <a class="el" href="kmr_8h.html#a9d52c3c69250bf19dd28d5e38809df79" title="Maps in master-worker mode. ">kmr_map_ms()</a>, <a class="el" href="kmrbase_8c.html#a194686701b3c46a869fe9eb2cab93252" title="Shuffles key-value pairs to the appropriate destination ranks. ">kmr_shuffle()</a>, <a class="el" href="kmrbase_8c.html#a64d9a689d79d64bcfa10d61c1d335ee7" title="Replicates key-value pairs to be visible on all ranks, that is, it has the effect of bcast or all-gat...">kmr_replicate()</a>, <a class="el" href="kmr_8h.html#ae06cb9083e42011c9fa019add7bc228f" title="Reduces key-value pairs. ">kmr_reduce()</a>, and <a class="el" href="kmrbase_8c.html#a875e0b3ce874d08f5778854dc21eb70a" title="Calls a reduce-function once as if all key-value pairs had the same key. ">kmr_reduce_as_one()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00679">679</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a40c607730747510fab9abcd2f8ed10fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c607730747510fab9abcd2f8ed10fe">&#9670;&nbsp;</a></span>kmr_move_kvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_move_kvs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of the input KVI to the output KVO. </p>
<p>It consumes the input KVI. Calling <a class="el" href="kmr_8h.html#a7bb545fb804c554dfc05baab4c8abf8d" title="Maps simply. ">kmr_map()</a> with a null map-function has the same effect. Effective-options: TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00592">592</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a273d7bee0df5928f5700b3c6bbb31939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273d7bee0df5928f5700b3c6bbb31939">&#9670;&nbsp;</a></span>kmr_concatenate_kvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_concatenate_kvs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nkvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates a number of KVSes to one. </p>
<p>Inputs are consumed. (It is fast because the key-value data is stored internally as a list of data blocks, and this routine just links them). Note that concatenating KVS can in effect be performed by consecutive calls to <a class="el" href="kmr_8h.html#a7bb545fb804c554dfc05baab4c8abf8d" title="Maps simply. ">kmr_map()</a> with the KEEP_OPEN option using the same output KVS. Effective-options: none. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l02754">2754</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="af45076291f415e5137cecf882e77bcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45076291f415e5137cecf882e77bcaa">&#9670;&nbsp;</a></span>kmr_add_kv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_add_kv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>kv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a key-value pair. </p>
<p>(It is with serialization when a map-function is threaded). </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00809">809</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a59cea104b2d349a035558de03b216476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cea104b2d349a035558de03b216476">&#9670;&nbsp;</a></span>kmr_add_kv1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_add_kv1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>klen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a key-value pair as given directly by a pointer. </p>
<p>An integer or a double be passed by a pointer (thus like &amp;v). </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00837">837</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a872983ca54c9e9eb46fe1d9537b0796d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872983ca54c9e9eb46fe1d9537b0796d">&#9670;&nbsp;</a></span>kmr_add_kv_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_add_kv_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>kv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>keyp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>valuep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a key-value pair, but only allocates a space and returns the pointers to the key and the value parts. </p>
<p>It may enable to create a large key/value data directly in the space. It does not return a proper value if a key/value field is not a pointer. (It cannot be used with a "push-off" key-value stream, because its buffer will be sent out and late fill-in the buffer causes a race). </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00901">901</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="ac07e8d3c6b4a229295ed3f9d982d1a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07e8d3c6b4a229295ed3f9d982d1a04">&#9670;&nbsp;</a></span>kmr_add_kv_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_add_kv_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks finished adding key-value pairs. </p>
<p>Further addition will be prohibited. Normally, mapper/shuffler/reducer finishes the output key-value stream by itself, and explicit calls are unnecessary. Here, mapper/shuffler/reducer includes <a class="el" href="kmr_8h.html#a7bb545fb804c554dfc05baab4c8abf8d" title="Maps simply. ">kmr_map()</a>, <a class="el" href="kmrbase_8c.html#ab58641ce4b8c06e61f3e21606b7fed36" title="Maps on rank0 only. ">kmr_map_on_rank_zero()</a>, <a class="el" href="kmr_8h.html#a9d52c3c69250bf19dd28d5e38809df79" title="Maps in master-worker mode. ">kmr_map_ms()</a>, <a class="el" href="kmrbase_8c.html#a194686701b3c46a869fe9eb2cab93252" title="Shuffles key-value pairs to the appropriate destination ranks. ">kmr_shuffle()</a>, <a class="el" href="kmrbase_8c.html#a64d9a689d79d64bcfa10d61c1d335ee7" title="Replicates key-value pairs to be visible on all ranks, that is, it has the effect of bcast or all-gat...">kmr_replicate()</a>, and <a class="el" href="kmr_8h.html#ae06cb9083e42011c9fa019add7bc228f" title="Reduces key-value pairs. ">kmr_reduce()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00939">939</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="abf34ba4ed13b843adff4332d0dad8c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf34ba4ed13b843adff4332d0dad8c8e">&#9670;&nbsp;</a></span>kmr_add_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_add_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a key-value pair of strings. </p>
<p>The key and value fields should be of opaque data. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00971">971</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a51fa8ec979f8c9aa8c1b335595fea419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fa8ec979f8c9aa8c1b335595fea419">&#9670;&nbsp;</a></span>kmr_map9()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map9 </td>
          <td>(</td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>stop_when_some_added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps simply. </p>
<p>It consumes the input key-value stream KVI unless INSPECT option is marked. The output key-value stream KVO can be null, but in that case, a map-function cannot add key-value pairs. The pointer ARG is just passed to a map-function as a general argument, where accesses to it should be race-free, since a map-function is called by threads by default. M is the map-function. See the description on the type <a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb" title="Map-function Type. ">kmr_mapfn_t</a>. It copeis the contents of the input KVI to the output KVO, when a map-function is null. During processing, it first makes an array pointing to the key-value entries in each data block, and works on it for ease threading/parallelization. Effective-options: NOTHREADING, INSPECT, KEEP_OPEN, COLLAPSE, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l01347">1347</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a35056aed5f886230e5025acf35eda2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35056aed5f886230e5025acf35eda2ee">&#9670;&nbsp;</a></span>kmr_map_skipping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_skipping </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>stop_when_some_added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps by skipping the number of entries. </p>
<p>It calls a map-function on entries from FROM, skipping by STRIDE, up to LIMIT non-inclusive. See <a class="el" href="kmr_8h.html#a7bb545fb804c554dfc05baab4c8abf8d" title="Maps simply. ">kmr_map()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l01192">1192</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a815a3eafd8bde396d34bbf5f39ba9783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815a3eafd8bde396d34bbf5f39ba9783">&#9670;&nbsp;</a></span>kmr_map_once()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>rank_zero_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps once. </p>
<p>It calls a map-function once with a dummy key-value stream and a dummy key-value pair. See <a class="el" href="kmr_8h.html#a7bb545fb804c554dfc05baab4c8abf8d" title="Maps simply. ">kmr_map()</a>. Effective-options: KEEP_OPEN, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l01460">1460</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="ab58641ce4b8c06e61f3e21606b7fed36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58641ce4b8c06e61f3e21606b7fed36">&#9670;&nbsp;</a></span>kmr_map_on_rank_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_on_rank_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps on rank0 only. </p>
<p>It calls a map-function once with a dummy key-value stream and a dummy key-value pair. It is used to avoid low-level conditionals like (myrank==0). See <a class="el" href="kmr_8h.html#a7bb545fb804c554dfc05baab4c8abf8d" title="Maps simply. ">kmr_map()</a>. Effective-options: KEEP_OPEN, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l01514">1514</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a40ef3f88641461720d92c97ab4479be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ef3f88641461720d92c97ab4479be2">&#9670;&nbsp;</a></span>kmr_map_rank_by_rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_rank_by_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps sequentially with rank by rank for debugging. </p>
<p>See kmr_map. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l01397">1397</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a9d52c3c69250bf19dd28d5e38809df79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d52c3c69250bf19dd28d5e38809df79">&#9670;&nbsp;</a></span>kmr_map_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps in master-worker mode. </p>
<p>The input key-value stream should be empty except on rank0 where the master is running (the contents on the worker ranks are ignored). It consumes the input key-value stream. The master does delivery only. The master returns frequently to give a chance to check-pointing, etc. The master returns immaturely each time one pair is delivered, and those returns are marked by MPI_ERR_ROOT indicating more tasks remain. In contrast, workers return only after all tasks done. The enough state to have to keep during <a class="el" href="kmrmapms_8c.html#a9d52c3c69250bf19dd28d5e38809df79" title="Maps in master-worker mode. ">kmr_map_ms()</a> for check-pointing is in the key-value streams KVI and KVO on the master. Note that this totally diverges from bulk-synchronous execution. It does not accept key-value field types KMR_KV_POINTER_OWNED or KMR_KV_POINTER_UNMANAGED. Effective-options: NOTHREADING, KEEP_OPEN. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l00344">344</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a4f8a223da5a75d698ca59279bf1c7384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8a223da5a75d698ca59279bf1c7384">&#9670;&nbsp;</a></span>kmr_map_ms_commands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_ms_commands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td>
          <td class="paramname"><em>sopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps in the master-worker mode, specialized to run serial commands. </p>
<p>It executes a command specified by a key-value, then calls a map-function at finishes of the command. It takes the commands in the same way as <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a>. The commands never be MPI programs. It uses system(3C) or fork-exec, switching to fork-exec either when the SEPARATOR_SPACE option is specified, a command string includes null characters, or the MAP_MS_USE_EXEC option to KMR is specified. It is implemented with <a class="el" href="kmrmapms_8c.html#a9d52c3c69250bf19dd28d5e38809df79" title="Maps in master-worker mode. ">kmr_map_ms()</a>; see the comments on <a class="el" href="kmrmapms_8c.html#a9d52c3c69250bf19dd28d5e38809df79" title="Maps in master-worker mode. ">kmr_map_ms()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02432">2432</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="ada07fb9d17822e3720c64976e3bc7fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada07fb9d17822e3720c64976e3bc7fdd">&#9670;&nbsp;</a></span>kmr_map_for_some()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_for_some </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps until some key-value are added. </p>
<p>It stops processing, when the output is non-empty. It does not guarantee singleness. Existence/emptiness be checked by <a class="el" href="kmrmoreops_8c.html#a161eaf42b3fb2855b6186ccf41fc72ab" title="Gets the total number of key-value pairs. ">kmr_get_element_count()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01170">1170</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a2502be0968e7f62404e02f8f445c7498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2502be0968e7f62404e02f8f445c7498">&#9670;&nbsp;</a></span>kmr_map_via_spawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_via_spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Info&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>mapfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps on processes started by MPI_Comm_spawn(). </p>
<p>It is intended to run custom MPI programs which will return a reply as MPI messages. Consider other variations to run independent processes, when the spawned processes will not interact with the parent: <a class="el" href="kmrmapms_8c.html#a5120d3c93ea5a471ab040f94dbd29a41" title="Maps on processes started by MPI_Comm_spawn() to run serial processes. ">kmr_map_serial_processes()</a>, <a class="el" href="kmrmapms_8c.html#a309f2ef87bc5f4ec67d53a446cbb392e" title="Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not commun...">kmr_map_parallel_processes()</a>, or <a class="el" href="kmrmapms_8c.html#a4f8a223da5a75d698ca59279bf1c7384" title="Maps in the master-worker mode, specialized to run serial commands. ">kmr_map_ms_commands()</a>.<br />
 A spawner (parent) spawns processes specified by key-value pairs. The key part is ignored, and the value part is a list of null-separated strings which constitutes a command and arguments. The option SEPARATOR_SPACE changes the separator character to whitespaces. If the first string is "maxprocs=n", then the number of processes is taken from this string. Or, an MPI_Info entry "maxprocs" in INFO is used, in which case "maxprocs" is common to all spawns. It is an error if neither is specified. A spawner tries to control the simultaneously running processes limited to the number of processes in the universe. When multiple spawners are active (more than one ranks have the entries to spawn), they divide the universe evenly among them.<br />
 The option REPLY_EACH or REPLY_ROOT lets a spawner wait for reply messages from the spawned processes, and then the spawner calls a map-function. A reply message is of the tag KMR_TAG_SPAWN_REPLY=500 and length zero, and <a class="el" href="kmrmapms_8c.html#ae6b0a9f5e3679c03c283c97f99cfed59" title="Sends a reply message in the spawned process, which tells it is ready to finish and may have some dat...">kmr_reply_to_spawner()</a> can be used to send this reply. When none of REPLY_EACH or REPLY_ROOT are specified, the spawner immediately calls a map-function one-by-one in the FIFO order (before the spawned processes finish). In that case, no load-balance is taken. Thus, the map-function should wait for the spawned processes to finish, otherwise, a spawner starts next spawns continuously and runs out the processes, which causes the MPI runtime to signal an error.<br />
 Communication between the spawned processes and a map-function of a spawner is through an inter-communicator. The parent inter-communicator of the spawned processes can be taken by MPI_Comm_get_parent() as usual. The inter-communicator at the spawner side can be obtained by calling <a class="el" href="kmrmapms_8c.html#ae47d401153aa4f75bc990384d9e78e74" title="Obtains (a reference to) a parent inter-communicator of a spawned process. ">kmr_get_spawner_communicator()</a> inside a map-function.<br />
 The INFO argument is passed to MPI_Comm_spawn() after inserting the entries which appear in the command line, when the command line has prefixes of the form "key=value". Insertion of the prefixes can be terminated by an empty entry "=". Use of info is discouraged, because it is not portable and may contradicts to the implicit assumption of the KMR implementation.<br />
 NOTE: There is no way to check the availability of processes for spawning in the MPI specification and MPI implementations. And, the MPI runtime signals errors when it runs out the processes. Thus, it puts a sleep (1 sec) in between MPI_Comm_spawn() calls to allow clean-ups in the MPI runtime and to avoid timing issues.<br />
 INTERFACE CHANGE: Set mr-&gt;spawn_pass_intercomm_in_argument=1 to enables the old interface, where the map-function MAPFN is called with the <a class="el" href="structkmr__spawn__state.html" title="State of each Spawning. ">kmr_spawn_state</a> structure as the general argument. The argument ARG passed to the mapper is stored in the MAPARG slot in the <a class="el" href="structkmr__spawn__state.html" title="State of each Spawning. ">kmr_spawn_state</a> structure. When TAKE_CKPT option is specified, a checkpoint data file of the output key-value stream is saved if both CKPT_ENABLE and CKPT_SELECTIVE global options are set. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l01992">1992</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="ae6b0a9f5e3679c03c283c97f99cfed59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b0a9f5e3679c03c283c97f99cfed59">&#9670;&nbsp;</a></span>kmr_reply_to_spawner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_reply_to_spawner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a reply message in the spawned process, which tells it is ready to finish and may have some data to send to the spawner in <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l01893">1893</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="ae47d401153aa4f75bc990384d9e78e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47d401153aa4f75bc990384d9e78e74">&#9670;&nbsp;</a></span>kmr_get_spawner_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm* kmr_get_spawner_communicator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains (a reference to) a parent inter-communicator of a spawned process. </p>
<p>It is used inside a map-function of <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a>; Pass INDEX the same argument to a map-function. It returns a reference for the side-effect of freeing a communicator in a map-function. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l01916">1916</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a5b8ea39208f60d2f6ba895cafa0302a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8ea39208f60d2f6ba895cafa0302a2">&#9670;&nbsp;</a></span>kmr_map_processes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_processes </td>
          <td>(</td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>nonmpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Info&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>mapfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps on processes started by MPI_Comm_spawn() to run independent processes. </p>
<p>It either calls <a class="el" href="kmrmapms_8c.html#a309f2ef87bc5f4ec67d53a446cbb392e" title="Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not commun...">kmr_map_parallel_processes()</a> or <a class="el" href="kmrmapms_8c.html#a5120d3c93ea5a471ab040f94dbd29a41" title="Maps on processes started by MPI_Comm_spawn() to run serial processes. ">kmr_map_serial_processes()</a> with regard to the NONMPI argument. See the comments of <a class="el" href="kmrmapms_8c.html#a309f2ef87bc5f4ec67d53a446cbb392e" title="Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not commun...">kmr_map_parallel_processes()</a> and <a class="el" href="kmrmapms_8c.html#a5120d3c93ea5a471ab040f94dbd29a41" title="Maps on processes started by MPI_Comm_spawn() to run serial processes. ">kmr_map_serial_processes()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02087">2087</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a309f2ef87bc5f4ec67d53a446cbb392e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309f2ef87bc5f4ec67d53a446cbb392e">&#9670;&nbsp;</a></span>kmr_map_parallel_processes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_parallel_processes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Info&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>mapfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not communicate to the parent. </p>
<p>The programs need to be MPI. It is a variation of <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a>, and refer to the comments on it for the basic usage. Since the spawned program does not know the parent, there is no way to communicate from the spawner. The map-function is called after the processes have exited, so that the map-function can check the result files created by the spawned processes.<br />
This function detects the end of spawned processes using a watch-program "kmrwatch0", by checking a closure of a socket to which "kmrwatch0" connected.<br />
 NOTE THAT THIS OPERATION WILL BLOCK INDEFINITELY AND FAIL, DEPENDING ON THE BEHAVIOR OF AN MPI IMPLEMENTATION. It is checked to work with Open MPI (1.6) and MPICH2 (1.5), but not with Intel MPI (4.1) and YAMPI2 (GridMPI 2.1). It depends on the behavior that MPI_Comm_free() on the parent and MPI_Finalize() on the child do not synchronize. The quote of the standard (MPI 2.x) says: "Though collective, MPI_Comm_free is anticipated that this operation will normally be implemented to be local, ..." The blocking situation can be checked by enabling tracing around calls to MPI_Comm_free() by (mr-&gt;trace_map_spawn=1).<br />
 NOTE (on MPI spawn implementations): Open MPI (1.6) allows to spawn non-MPI processes by passing an special MPI_Info. MPICH2 (1.5) does not allow to spawn non-MPI processes, because MPI_Comm_spawn() of the parent and MPI_Init() of the child synchronize. In Intel MPI (4.1) and YAMPI2 (GridMPI), the calls of MPI_Comm_free() on the parent and MPI_Finalize() or MPI_Comm_free() on the child synchronize, and thus, they require to call MPI_Comm_free() at an appropriate time on the parent.<br />
 Options REPLY_ROOT and REPLY_EACH have no effect. When TAKE_CKPT option is specified, a checkpoint data file of the output key-value stream is saved if both CKPT_ENABLE and CKPT_SELECTIVE global options are set. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02037">2037</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a5120d3c93ea5a471ab040f94dbd29a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5120d3c93ea5a471ab040f94dbd29a41">&#9670;&nbsp;</a></span>kmr_map_serial_processes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_serial_processes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Info&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>mapfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps on processes started by MPI_Comm_spawn() to run serial processes. </p>
<p>This should NOT be used; Use <a class="el" href="kmrmapms_8c.html#a4f8a223da5a75d698ca59279bf1c7384" title="Maps in the master-worker mode, specialized to run serial commands. ">kmr_map_ms_commands()</a>, instead. Fork-execing in <a class="el" href="kmrmapms_8c.html#a4f8a223da5a75d698ca59279bf1c7384" title="Maps in the master-worker mode, specialized to run serial commands. ">kmr_map_ms_commands()</a> is simpler than spawning. See also the comments on <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a> and <a class="el" href="kmrmapms_8c.html#a309f2ef87bc5f4ec67d53a446cbb392e" title="Maps on processes started by MPI_Comm_spawn() to run independent MPI processes, which will not commun...">kmr_map_parallel_processes()</a>. The map-function is called after the processes have exited, thus, there is no way to communicate from the map-function. Instead, the map-function can check the result files created by the spawned processes.<br />
 This function detects the end of spawned processes using a watch-program "kmrwatch0" which sends a reply to the parent in place of the serial program. Options REPLY_ROOT and REPLY_EACH have no effect. When TAKE_CKPT option is specified, a checkpoint data file of the output key-value stream is saved if both CKPT_ENABLE and CKPT_SELECTIVE global options are set. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02067">2067</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a14f2e46ad4e40fb0f7140ffbf6da58e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f2e46ad4e40fb0f7140ffbf6da58e7">&#9670;&nbsp;</a></span>kmr_send_kvs_to_spawner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_send_kvs_to_spawner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the KVS from a spawned process to the map-function of the spawner. </p>
<p>It is paired with <a class="el" href="kmrmapms_8c.html#a98e4b71fc1aa9386021576dd9c186b85" title="Collects key-value pairs generated by spawned processes. ">kmr_receive_kvs_from_spawned_fn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02127">2127</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a98e4b71fc1aa9386021576dd9c186b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e4b71fc1aa9386021576dd9c186b85">&#9670;&nbsp;</a></span>kmr_receive_kvs_from_spawned_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_receive_kvs_from_spawned_fn </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>kv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects key-value pairs generated by spawned processes. </p>
<p>It is a map-function to be used with <a class="el" href="kmrmapms_8c.html#a2502be0968e7f62404e02f8f445c7498" title="Maps on processes started by MPI_Comm_spawn(). ">kmr_map_via_spawn()</a> with the REPLY_EACH option. The spawned processes call <a class="el" href="kmrmapms_8c.html#a14f2e46ad4e40fb0f7140ffbf6da58e7" title="Sends the KVS from a spawned process to the map-function of the spawner. ">kmr_send_kvs_to_spawner()</a> to send generated key-value pairs, and this function receives and puts them into KVO. PROTOCOL: The reply consists of one or two messages with the tag KMR_TAG_SPAWN_REPLY1=501. One is the data size, which is followed by a marshaled key-value stream when the data size is non-zero. </p>

<p class="definition">Definition at line <a class="el" href="kmrmapms_8c_source.html#l02161">2161</a> of file <a class="el" href="kmrmapms_8c_source.html">kmrmapms.c</a>.</p>

</div>
</div>
<a id="a44b1acc032c1e378030ce36ed4ee68f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b1acc032c1e378030ce36ed4ee68f9">&#9670;&nbsp;</a></span>kmr_sort_locally()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_sort_locally </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>shuffling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders key-value pairs in a single rank. </p>
<p>It sorts pairs when SHUFFLING is false, or gathers pairs with the same hashed keys adjacent when SHUFFLING is true. It only respects for not ordering but just equality when shuffling. The sort-keys for shuffling are destination ranks for shuffling (taking a modulo of the hashed key with nprocs). As a sorting, it is NOT-STABLE due to quick-sort used inside. It converts pointer keys and values to opaque ones for sending.<br />
Sorting on a key-value stream is by memcmp(), unless the keys are integer or floating-point numbers (ordering on integers and memcmp() are different). Sorting on non-numbers is performed in two steps: the first step sorts by the integer rankings, and the second by the specified comparator. And thus, the comparator is required to have a corresponding generator of integer rankings. It consumes the input key-value stream. Effective-options: NOTHREADING, INSPECT, KEY_AS_RANK. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l02051">2051</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a194686701b3c46a869fe9eb2cab93252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194686701b3c46a869fe9eb2cab93252">&#9670;&nbsp;</a></span>kmr_shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles key-value pairs to the appropriate destination ranks. </p>
<p>It first sorts pairs by the destination ranks of the keys, and then exchanges pairs with all-to-all communication. It converts pointer keys and values to opaque ones for sending during the sorting stage. Note that the key-value pairs are sorted by the hash-values prior to exchange. Effective-options: INSPECT, KEY_AS_RANK, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l02094">2094</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a64d9a689d79d64bcfa10d61c1d335ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d9a689d79d64bcfa10d61c1d335ee7">&#9670;&nbsp;</a></span>kmr_replicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replicates key-value pairs to be visible on all ranks, that is, it has the effect of bcast or all-gather. </p>
<p>It gathers pairs on rank0 only by the option RANK_ZERO. It moves stably, keeping the ordering of ranks and the ordering of local key-value pairs. Effective-options: INSPECT, RANK_ZERO, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l02240">2240</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a12353f5489c900ad078fbd96d2a92e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12353f5489c900ad078fbd96d2a92e55">&#9670;&nbsp;</a></span>kmr_reduce9()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_reduce9 </td>
          <td>(</td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>stop_when_some_added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces key-value pairs. </p>
<p>It does not include shuffling, and thus, it requires being preceded by shuffling. Or, it works on local data (as a local combiner), if it is not preceded by shuffling. It always consumes the input key-value stream KVI. An output key-value stream KVO can be null. It passes an array of key-value pairs to a reduce-function whose keys are all equal (equality is by bits). The pointer ARG is just passed to a reduce-function as a general argument, where accesses to it should be race-free, since a reduce-function is called by threads by default. R is a reduce-function. See the description on the type <a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760" title="Reduce-function Type. ">kmr_redfn_t</a>. A reduce-function may see a different input key-value stream (internally created one) instead of the one given. During reduction, it first scans adjacent equal keys, then calls a given reduce-function. Effective-options: NOTHREADING, INSPECT, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l02607">2607</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a875e0b3ce874d08f5778854dc21eb70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875e0b3ce874d08f5778854dc21eb70a">&#9670;&nbsp;</a></span>kmr_reduce_as_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_reduce_as_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a reduce-function once as if all key-value pairs had the same key. </p>
<p>See <a class="el" href="kmr_8h.html#ae06cb9083e42011c9fa019add7bc228f" title="Reduces key-value pairs. ">kmr_reduce()</a>. Effective-options: INSPECT, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l02683">2683</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a860590f8d6fd3ac6a1ec80255d380aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860590f8d6fd3ac6a1ec80255d380aa2">&#9670;&nbsp;</a></span>kmr_reduce_for_some()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_reduce_for_some </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces until some key-value are added. </p>
<p>It stops processing, when the output is non-empty. It does not guarantee singleness. Existence/emptiness be checked by <a class="el" href="kmrmoreops_8c.html#a161eaf42b3fb2855b6186ccf41fc72ab" title="Gets the total number of key-value pairs. ">kmr_get_element_count()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01183">1183</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a0cc987ce7e41bef6c36346c5fb0eaf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc987ce7e41bef6c36346c5fb0eaf4b">&#9670;&nbsp;</a></span>kmr_map_file_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_file_names </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__file__option.html">kmr_file_option</a>&#160;</td>
          <td class="paramname"><em>fopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps on file names. </p>
<p>NAMES specifies N file names. The map-function gets a file name in the key field (the value field is integer zero). File-option EACH_RANK specifies each rank independently to enumerate file names, otherwise to work on rank0 only. File-option SUBDIRECTORIES specifies to descend to subdirectories. It ignores files/directories whose name starting with dots. File-option LIST_FILE specifies to read contents of each file for file names. File consists of one file name per line, and ignores a line beginning with a "#". Whitespaces are trimed at the beginning and the end. LIST_FILE implies SUBDIRECTORIES. It enumerates names of regular files only. File-option SHUFFLE_FILES runs shuffling file names among ranks. </p>

<p class="definition">Definition at line <a class="el" href="kmrfiles_8c_source.html#l01372">1372</a> of file <a class="el" href="kmrfiles_8c_source.html">kmrfiles.c</a>.</p>

</div>
</div>
<a id="a82469cef31c4101143b5c012aac6da86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82469cef31c4101143b5c012aac6da86">&#9670;&nbsp;</a></span>kmr_map_getline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_getline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>largebuffering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a map-function M for each line by getline() on an input F. </p>
<p>A map-function gets a line number in key and a string in value (the index argument is the same as the key). Calls to getline() is limited to LIMIT lines (0 for unlimited). It is multi-threaded and the call order is arbitrary. ARG and OPT are passed verbatim to a map-function. Effective-options: NOTHREADING, KEEP_OPEN, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrfiles_8c_source.html#l01561">1561</a> of file <a class="el" href="kmrfiles_8c_source.html">kmrfiles.c</a>.</p>

</div>
</div>
<a id="a89cc00c0639b9d904e1aca7035c30f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cc00c0639b9d904e1aca7035c30f47">&#9670;&nbsp;</a></span>kmr_take_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_take_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> *&#160;</td>
          <td class="paramname"><em>kv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a single key-value pair locally in the key-value stream KVI. </p>
<p>It is an error when zero or more than one entries are in the KVI. It does not consume the input KVS (INSPECT IMPLIED). The returned key-value entry must be used before freeing the input KVS, when it points to an opaque data. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l01427">1427</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="ae1d149dae481cdc7690c8268a8ee07a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d149dae481cdc7690c8268a8ee07a4">&#9670;&nbsp;</a></span>kmr_find_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_find_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>ki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> *&#160;</td>
          <td class="paramname"><em>ko</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a key-value pair for a key. </p>
<p>It is an error when not exactly one entry is found. It does not consume the input KVS KVI. The returned key-value entry must be used before freeing the input KVS, when it points to an opaque data. It maps internally, so it is slow. It is tricky that the internally created KVS KVS0 points to the key-value area in the input KVS KVI. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00043">43</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a6134d913ad359d56c789a99fb668a0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6134d913ad359d56c789a99fb668a0d3">&#9670;&nbsp;</a></span>kmr_find_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_find_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>vq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the key K in the key-value stream KVS. </p>
<p>It returns a pointer pointing inside the key-value stream. It is an error when not exactly one entry is found. It does not consume the input KVS. It maps internally, so slow. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00073">73</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="ae55911779172dfab2a73ff811395b73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55911779172dfab2a73ff811395b73f">&#9670;&nbsp;</a></span>kmr_copy_info_to_kvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_copy_info_to_kvs </td>
          <td>(</td>
          <td class="paramtype">MPI_Info&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies mpi-info entires into kvs. </p>

<p class="definition">Definition at line <a class="el" href="kmrutil_8c_source.html#l00997">997</a> of file <a class="el" href="kmrutil_8c_source.html">kmrutil.c</a>.</p>

</div>
</div>
<a id="ab9c36532f989557aef713397d3ea8b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c36532f989557aef713397d3ea8b85">&#9670;&nbsp;</a></span>kmr_copy_kvs_to_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_copy_kvs_to_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Info&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies kvs entires into mpi-info. </p>
<p>It assumes keys/values are strings (no checks). It consumes KVI. </p>

<p class="definition">Definition at line <a class="el" href="kmrutil_8c_source.html#l01049">1049</a> of file <a class="el" href="kmrutil_8c_source.html">kmrutil.c</a>.</p>

</div>
</div>
<a id="a161eaf42b3fb2855b6186ccf41fc72ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161eaf42b3fb2855b6186ccf41fc72ab">&#9670;&nbsp;</a></span>kmr_get_element_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_get_element_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the total number of key-value pairs. </p>
<p>It uses replication and reduction. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00114">114</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="acbb5934021b3cd6adc54ad66c615cbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb5934021b3cd6adc54ad66c615cbba">&#9670;&nbsp;</a></span>kmr_local_element_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_local_element_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of key-value pairs locally on each rank. </p>

<p class="definition">Definition at line <a class="el" href="kmrutil_8c_source.html#l00349">349</a> of file <a class="el" href="kmrutil_8c_source.html">kmrutil.c</a>.</p>

</div>
</div>
<a id="ac90b01e2a5ec99a5146d71a48457c854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90b01e2a5ec99a5146d71a48457c854">&#9670;&nbsp;</a></span>kmr_add_identity_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_add_identity_fn </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>kv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a given key-value pair unmodified. </p>
<p>It is a map-function. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l00995">995</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a4d03aa1b36d67910d6214c286553f9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d03aa1b36d67910d6214c286553f9d5">&#9670;&nbsp;</a></span>kmr_copy_to_array_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_copy_to_array_fn </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>kv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the entry in the array. </p>
<p>It should be used with the INSPECT option for map, because the array entries may point into the input key-value stream. It is a map-function. </p>

<p class="definition">Definition at line <a class="el" href="kmrutil_8c_source.html#l00949">949</a> of file <a class="el" href="kmrutil_8c_source.html">kmrutil.c</a>.</p>

</div>
</div>
<a id="ab676a31f6cfd76b38ad5f86b4a09f81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab676a31f6cfd76b38ad5f86b4a09f81d">&#9670;&nbsp;</a></span>kmr_save_kvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_save_kvs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>dataq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>szq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs locally the contents of a key-value stream to a byte array. </p>
<p>It is used to save or to send a key-value stream. It returns the allocated memory with its size, and it should be freed by the user. It may fail on allocating a buffer, and then it returns MPI_ERR_BUFFER. Its reverse is performed by <a class="el" href="kmrbase_8c.html#a8ab6a2480c2159719a697627e1fb4d00" title="Unpacks locally the contents of a key-value stream from a byte array. ">kmr_restore_kvs()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l01026">1026</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="aebc6c6968706bc28d58ad00391125754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc6c6968706bc28d58ad00391125754">&#9670;&nbsp;</a></span>kmr_restore_kvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_restore_kvs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpacks locally the contents of a key-value stream from a byte array. </p>
<p>It is a reverse of <a class="el" href="kmrbase_8c.html#a3923c00210d6e66c02fc718633fe96d7" title="Packs locally the contents of a key-value stream to a byte array. ">kmr_save_kvs()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l01092">1092</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="aa50e7437f8d24e7c50927f21b0ad9d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50e7437f8d24e7c50927f21b0ad9d44">&#9670;&nbsp;</a></span>kmr_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a new pair by swapping the key and the value in each pair. </p>
<p>That is, it makes new pairs (v0,k0) from (k0,v0). This is a simple mapper. Effective-options: NOTHREADING, INSPECT, KEEP_OPEN, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00159">159</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="aea1ec5745abce4c3b711146b0d4f5ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1ec5745abce4c3b711146b0d4f5ce6">&#9670;&nbsp;</a></span>kmr_pairing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_pairing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a value part with a key-value pairing. </p>
<p>That is, it makes new pairs (k0,(k0,v0)) from (k0,v0). See <a class="el" href="kmrmoreops_8c.html#a5ef882f82ea273da7b31a2de5c922d57" title="Extracts a key-value pair from a pairing in the value part, discarding the original key...">kmr_unpairing()</a>. This is a simple mapper. Effective-options: NOTHREADING, INSPECT, KEEP_OPEN, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00212">212</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a523095ec2296b560d815d7e082dcb4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523095ec2296b560d815d7e082dcb4b1">&#9670;&nbsp;</a></span>kmr_unpairing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_unpairing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a key-value pair from a pairing in the value part, discarding the original key. </p>
<p>It is the inverse of kmr_pairing. That is, it makes new pairs (k1,v1) from (k0,(k1,v1)). See <a class="el" href="kmrmoreops_8c.html#aea1ec5745abce4c3b711146b0d4f5ce6" title="Replaces a value part with a key-value pairing. ">kmr_pairing()</a>. This is a simple mapper. Effective-options: NOTHREADING, INSPECT, KEEP_OPEN, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00234">234</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a43dc49274f766b46b16ec77b0217c6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43dc49274f766b46b16ec77b0217c6ca">&#9670;&nbsp;</a></span>kmr_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a key-value stream globally. </p>
<p>It is NOT-STABLE due to quick-sort used inside. It consumes an input key-value stream unless INSPECT is specified. It selects a sorting routine on the total number of keys. See <a class="el" href="kmrmoreops_8c.html#a2ee642a4f300cc31d6e86cdc6064d177" title="Sorts a key-value stream by the regular or the random sampling-sort. ">kmr_sort_large()</a>, <a class="el" href="kmrmoreops_8c.html#a1f4206dfa415bd8d42e836a4fbf0838f" title="Sorts a key-value stream, by partitioning to equal ranges. ">kmr_sort_small()</a>, or <a class="el" href="kmrmoreops_8c.html#a6ab020cce7e7f28f0937fc71a03bc759" title="Sort by rank0, a degenerated case for small number of keys. ">kmr_sort_by_one()</a>. The results are stored as ascending ranks, thus the rank0 holds the minimum. Effective-options: INSPECT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00575">575</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a1f4206dfa415bd8d42e836a4fbf0838f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4206dfa415bd8d42e836a4fbf0838f">&#9670;&nbsp;</a></span>kmr_sort_small()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_sort_small </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a key-value stream, by partitioning to equal ranges. </p>
<p>It is NOT-STABLE due to quick-sort used inside. It consumes an input key-value stream unless INSPECT is specified. It assumes uniform distribution, and partioning is simply determined by the range of keys (MIN-MAX range is divided by nprocs). Effective-options: NOTHREADING, INSPECT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00388">388</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a2ee642a4f300cc31d6e86cdc6064d177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee642a4f300cc31d6e86cdc6064d177">&#9670;&nbsp;</a></span>kmr_sort_large()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_sort_large </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a key-value stream by the regular or the random sampling-sort. </p>
<p>It is NOT-STABLE due to quick-sort used inside. It consumes an input key-value stream unless INSPECT is specified. It can be used for "GraySort". Effective-options: NOTHREADING, INSPECT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00469">469</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a6ab020cce7e7f28f0937fc71a03bc759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab020cce7e7f28f0937fc71a03bc759">&#9670;&nbsp;</a></span>kmr_sort_by_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_sort_by_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort by rank0, a degenerated case for small number of keys. </p>
<p>It is NOT-STABLE due to quick-sort used inside. It consumes an input key-value stream unless INSPECT is specified. Effective-options: INSPECT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00544">544</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="af18d7541ca4f6e28c922edb006a388f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18d7541ca4f6e28c922edb006a388f4">&#9670;&nbsp;</a></span>kmr_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes key-value pairs as products of the two values in two key-value stream. </p>
<p>It creates a set of key-value pairs (ai,bj) of the pairs (key,ai) from KVS0 and (key,bj) from KVS1 for the matching key. It makes a direct-product of the values when multiple values exist for a matching key. That is, for example, given a set {(k,a0), (k,a1), (k,a2)} in KVS0 and {(k,b3), (k,b4)} in KVS1 for some distinct key, it creates {(a0,b3), (a0,b4), (a1,b3), (a1,b4), (a2,b3), (a2,b4)}. Effective-options: NOTHREADNG. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00696">696</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a7d8d470979d2edbc1d1af235f150e89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8d470979d2edbc1d1af235f150e89e">&#9670;&nbsp;</a></span>kmr_ranking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_ranking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a ranking to key-value pairs, and returns the number of the total elements in COUNT. </p>
<p>Ranking is a position in the key-value stream. That is, for example, given a sequence {(k0,v0), (k1,v1), (k2,v2)}, it creates {(0,(k0,v0)), (1,(k1,v1)), (2,(k2,v2))}. Effective-options: NOTHREADING, INSPECT, KEEP_OPEN. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00764">764</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a058890c9ef6689deacfd9eda9d25e513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058890c9ef6689deacfd9eda9d25e513">&#9670;&nbsp;</a></span>kmr_distribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_distribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>cyclic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distributes key-values so that each rank has approximately the same number of pairs. </p>
<p>It is used to level the load of mapping among ranks by calling it before mapping. <a class="el" href="kmr_8h.html#a194686701b3c46a869fe9eb2cab93252" title="Shuffles key-value pairs to the appropriate destination ranks. ">kmr_shuffle()</a> can be sufficient to distribute pairs in most cases, but sometimes it results in uneven distribution because shuffling is based on hashing on the keys. Effective-options: NOTHREADING, INSPECT, KEEP_OPEN. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00835">835</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a6e89bd7e35b3d0a403c7fb61e3d8b087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e89bd7e35b3d0a403c7fb61e3d8b087">&#9670;&nbsp;</a></span>kmr_shuffle_leveling_pair_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_shuffle_leveling_pair_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles key-values so that each rank has approximately the same number of pairs. </p>
<p>It collects the same keys on a rank (cf. <a class="el" href="kmrmoreops_8c.html#a058890c9ef6689deacfd9eda9d25e513" title="Distributes key-values so that each rank has approximately the same number of pairs. ">kmr_distribute()</a>). </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01074">1074</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="aa73f60e170d05de96b3dc5bb4878d9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73f60e170d05de96b3dc5bb4878d9df">&#9670;&nbsp;</a></span>kmr_scan_locally()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_scan_locally </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>carryin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>carryout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans every key-value with a reduce-function locally (independently on each rank). </p>
<p>It works in the order in the KVS. It ignores differences of the keys. It gets the start value from CARRYIN and puts the final value to CARRYOUT. The output has the same number of entries as the input. The carry-in and carry-out have one entry. The carry-out can be null. The reduce-function is called on each key-value pair as the right operand with the previous value as the left operand, and it should output a single value. The key part of the output is ignored and a pair is stored under the original key. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l02962">2962</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a73733e98faa5ee96665d415ef2044333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73733e98faa5ee96665d415ef2044333">&#9670;&nbsp;</a></span>kmr_scan_on_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_scan_on_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#af4e0b7a58968aad22188408a00131760">kmr_redfn_t</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefix-scans every key-value with a reduce-function (non-self-inclusively) and generates the final value in TOTAL (it generates the same value on all the ranks in the TOTAL). </p>
<p>The key-values are scanned in the order in the KVS as they are concatenated in the rank-order. The reduce-function should be associative and free of side-effects (because it is called multiple times on the same data). The reduce-function should output a single key-value when given any number of key-value pairs. Furthermore, it should output an identity element when it is given zero key-value pairs. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l00943">943</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="af00f09bbba752958cd1036ceb0aa5aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00f09bbba752958cd1036ceb0aa5aad">&#9670;&nbsp;</a></span>kmr_choose_first_part()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_choose_first_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chooses the first N entries from a key-value stream KVI. </p>
<p>The option nothreading is implied to keep the ordering. Effective-options: INSPECT, KEEP_OPEN. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01145">1145</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="af9680449d70d05834da4c0c44a2d8dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9680449d70d05834da4c0c44a2d8dc5">&#9670;&nbsp;</a></span>kmr_legal_minimum_field_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_legal_minimum_field_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a minimum byte size of the field: 8 for INTEGER and FLOAT8, 0 for others. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l02929">2929</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a40e2c060cb87fa46364cae1e3038d47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e2c060cb87fa46364cae1e3038d47f">&#9670;&nbsp;</a></span>kmr_histogram_count_by_ranks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_histogram_count_by_ranks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>frq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>rankzeroonly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an integer array FRQ[i] with the count of the elements of each rank. </p>
<p>The array FRQ be as large as nprocs. It also fills VAR[0]=average, VAR[1]=variance, VAR[2]=min, and VAR[3]=max. FRQ or VAR can be null. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01569">1569</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a78f87c0c3724460402376ef81d0efa76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f87c0c3724460402376ef81d0efa76">&#9670;&nbsp;</a></span>kmr_read_files_reassemble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_read_files_reassemble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reassembles files reading by ranks. </p>
<p>It is intended to reassembles a file from files split into segments. FILE is a file name. A file name can be null, when the rank does not participate reading (COLOR=-1). COLOR groups ranks (be COLOR&gt;=-1). The files on the ranks with the same COLOR are concatenated, where concatenation is ordered by the rank-order. Read is performed for OFFSET and BYTES on each file. BYTES can be -1 to read an entire file. BUFFER and SIZE are set to the malloced buffer and the size on return. Ranks with non-null FILE retrieve a file (ingest), while ranks with non-zero BUFFER receive contents (digest). Ranks with COLOR=-1 do not participate in file reading. REMARK ON K: It reads a specified file by each rank, assuming the files reside in specific I/O-groups to the ranks. </p>

<p class="definition">Definition at line <a class="el" href="kmrfiles_8c_source.html#l00653">653</a> of file <a class="el" href="kmrfiles_8c_source.html">kmrfiles.c</a>.</p>

</div>
</div>
<a id="aa595f06609d414e074f50f3009a90c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa595f06609d414e074f50f3009a90c8f">&#9670;&nbsp;</a></span>kmr_read_file_by_segments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_read_file_by_segments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads one file by segments and reassembles by all-gather. </p>
<p>FILE is a file name. COLOR groups ranks (be COLOR&gt;=-1). The ranks with the same COLOR collaborate to read a file, and thus, they must specify the same file (with an identical inode number). BUFFER and SIZE are set to the malloced buffer and the size on return. Ranks with non-zero FILE retrieve a file (ingest). Ranks with non-zero BUFFER receive contents (digest). Ranks with COLOR=-1 do not participate in file reading, and then arguments should be FILE=0 and BUFFER=0. </p>

<p class="definition">Definition at line <a class="el" href="kmrfiles_8c_source.html#l01021">1021</a> of file <a class="el" href="kmrfiles_8c_source.html">kmrfiles.c</a>.</p>

</div>
</div>
<a id="a989c9114805481b0eda194ba7098e442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989c9114805481b0eda194ba7098e442">&#9670;&nbsp;</a></span>kmr_retrieve_kvs_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_retrieve_kvs_entries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__kvs__entry.html">kmr_kvs_entry</a> **&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills local key-value entries in an array for inspection. </p>
<p>The returned pointers point to the inside of the KVS. It returns up to N entries, and the array EV should be as large as N. It implies inspect. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l02860">2860</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="a1f3a4ea5fb90e2ae731d6dc940534f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3a4ea5fb90e2ae731d6dc940534f3e">&#9670;&nbsp;</a></span>kmr_retrieve_kv_box_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_retrieve_kv_box_entries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills local key-value entries in an array of <a class="el" href="structkmr__kv__box.html" title="Handy Copy of a Key-Value Field. ">kmr_kv_box</a> for inspection. </p>
<p>While <a class="el" href="kmrbase_8c.html#a989c9114805481b0eda194ba7098e442" title="Fills local key-value entries in an array for inspection. ">kmr_retrieve_kvs_entries()</a> returns raw entries but <a class="el" href="kmrbase_8c.html#a1f3a4ea5fb90e2ae731d6dc940534f3e" title="Fills local key-value entries in an array of kmr_kv_box for inspection. ">kmr_retrieve_kv_box_entries()</a> returns entries of <a class="el" href="structkmr__kv__box.html" title="Handy Copy of a Key-Value Field. ">kmr_kv_box</a>. The returned pointers point to the inside of the KVS. It returns up to N entries, and the array EV should be as large as N. It implies inspect. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l02883">2883</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="ad45f26e655a43257fa25c65d429d89a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45f26e655a43257fa25c65d429d89a6">&#9670;&nbsp;</a></span>kmr_retrieve_keyed_records()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_retrieve_keyed_records </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__keyed__record.html">kmr_keyed_record</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>shuffling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>ranking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills keyed records in an array for sorting. </p>
<p>The array EV should be as large as N. It implies inspect. </p>

<p class="definition">Definition at line <a class="el" href="kmrbase_8c_source.html#l02902">2902</a> of file <a class="el" href="kmrbase_8c_source.html">kmrbase.c</a>.</p>

</div>
</div>
<a id="ab098ede35218931b5f256717042f8646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab098ede35218931b5f256717042f8646">&#9670;&nbsp;</a></span>kmr_dump_kv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_dump_kv </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>kv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps contents of a key-value. </p>

<p class="definition">Definition at line <a class="el" href="kmrutil_8c_source.html#l01684">1684</a> of file <a class="el" href="kmrutil_8c_source.html">kmrutil.c</a>.</p>

</div>
</div>
<a id="a835fbe3cbeddee74050f96e1fb1145a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835fbe3cbeddee74050f96e1fb1145a9">&#9670;&nbsp;</a></span>kmr_dump_kvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_dump_kvs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps contents of a KVS to stdout. </p>
<p>Argument FLAG is nothing, and ignored. It prints each content as a string or as a hex-dump. Each content is truncated to 45 characters. Ellipses may appear if the content is truncated, or, "???" appears if the content is a string but includes null in the middle. </p>

<p class="definition">Definition at line <a class="el" href="kmrutil_8c_source.html#l01711">1711</a> of file <a class="el" href="kmrutil_8c_source.html">kmrutil.c</a>.</p>

</div>
</div>
<a id="a9f947ac395ebff11ff1301a363e0fdf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f947ac395ebff11ff1301a363e0fdf9">&#9670;&nbsp;</a></span>kmr_dump_kvs_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_dump_kvs_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps contents of a key-value stream, with values are pairs. </p>
<p>Prints the total number of key-value pairs. It prints on the rank0 only. </p>

<p class="definition">Definition at line <a class="el" href="kmrutil_8c_source.html#l01761">1761</a> of file <a class="el" href="kmrutil_8c_source.html">kmrutil.c</a>.</p>

</div>
</div>
<a id="aa6ce348f73e9cce1df6af7de726e7a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ce348f73e9cce1df6af7de726e7a1c">&#9670;&nbsp;</a></span>kmr_dump_opaque()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kmr_dump_opaque </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the string of the key or value field into a buffer BUF as printable string. </p>

<p class="definition">Definition at line <a class="el" href="kmrutil_8c_source.html#l01596">1596</a> of file <a class="el" href="kmrutil_8c_source.html">kmrutil.c</a>.</p>

</div>
</div>
<a id="af0ae0218d80610afda9c102dc3d19203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ae0218d80610afda9c102dc3d19203">&#9670;&nbsp;</a></span>kmr_reset_ntuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kmr_reset_ntuple </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>marker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets an n-tuple U with N entries and a MARKER. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01234">1234</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a0bcd7967a7d40208bcd55bd7f5ad1583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcd7967a7d40208bcd55bd7f5ad1583">&#9670;&nbsp;</a></span>kmr_put_ntuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_put_ntuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an entry V with LEN in an n-tuple U whose size is limited to SIZE. </p>
<p>An n-tuple should be initialized by <a class="el" href="kmrmoreops_8c.html#af0ae0218d80610afda9c102dc3d19203" title="Resets an n-tuple U with N entries and a MARKER. ">kmr_reset_ntuple()</a> first. Note it fills with zeros the gap of the alignment padding, allowing the n-tuples be used as opaque keys. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01252">1252</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a683553c3f8d8cebecad43a2ec7ba858b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683553c3f8d8cebecad43a2ec7ba858b">&#9670;&nbsp;</a></span>kmr_put_ntuple_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_put_ntuple_long </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an integer value in an n-tuple U whose size is limited to SIZE. </p>
<p>See <a class="el" href="kmrmoreops_8c.html#a5b7f6b32ff70600389005fb8cf85939c" title="Adds an entry V with LEN in an n-tuple U whose size is limited to SIZE. ">kmr_put_ntuple()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01274">1274</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a8d88c46543a928148613cbe3ef3db8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d88c46543a928148613cbe3ef3db8d1">&#9670;&nbsp;</a></span>kmr_put_ntuple_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_put_ntuple_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple__entry.html">kmr_ntuple_entry</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an n-tuple entry E in an n-tuple U whose size is limited to SIZE. </p>
<p>See <a class="el" href="kmrmoreops_8c.html#a5b7f6b32ff70600389005fb8cf85939c" title="Adds an entry V with LEN in an n-tuple U whose size is limited to SIZE. ">kmr_put_ntuple()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01284">1284</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a3f319be6ce3801095704549460e36760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f319be6ce3801095704549460e36760">&#9670;&nbsp;</a></span>kmr_nth_ntuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structkmr__ntuple__entry.html">kmr_ntuple_entry</a> kmr_nth_ntuple </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an NTH entry of an n-tuple. </p>
<p>It returns a pair of a length and a pointer. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01197">1197</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a05d092c5a560c5df86729a383aa6e7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d092c5a560c5df86729a383aa6e7fe">&#9670;&nbsp;</a></span>kmr_size_ntuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_size_ntuple </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the storage size of an n-tuple. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01211">1211</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="ae398c2918a0097eb20f50b1ffb21c1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae398c2918a0097eb20f50b1ffb21c1da">&#9670;&nbsp;</a></span>kmr_size_ntuple_by_lengths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_size_ntuple_by_lengths </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the storage size of an n-tuple for N entries with LEN[i] size each. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01221">1221</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a1292ef72b8ba6ed975e96887404d1281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1292ef72b8ba6ed975e96887404d1281">&#9670;&nbsp;</a></span>kmr_add_ntuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_add_ntuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>klen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an n-tuple U with a given key K and KLEN in a key-value stream KVO. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01295">1295</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="ab4c13b06c526421dbe8499416fff0ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c13b06c526421dbe8499416fff0ced">&#9670;&nbsp;</a></span>kmr_separate_ntuples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_separate_ntuples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structkmr__kv__box.html">kmr_kv_box</a>&#160;</td>
          <td class="paramname"><em>kv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> **&#160;</td>
          <td class="paramname"><em>vv</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cnt</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markers</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>disallow_other_entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates the n-tuples stored in the value part of KV into the two sets by their marker values. </p>
<p>It is intended to be used in reduce functions. It separates the n-tuples to the first set by marker=MARKERS[0] and to the second set by marker=MARKERS[1]. It returns two malloced arrays in VV with their sizes in CNT. The arrays VV[0] and VV[1] should be freed by the caller. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01318">1318</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="aa93b6f23508e72e138849192235d17bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93b6f23508e72e138849192235d17bb">&#9670;&nbsp;</a></span>kmr_product_ntuples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_product_ntuples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__ntuple.html">kmr_ntuple</a> **&#160;</td>
          <td class="paramname"><em>vv</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cnt</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slots</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nslots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keys</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nkeys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a direct product of the two sets of n-tuples VV[0] and VV[1] with their counts in CNT[0] and CNT[1]. </p>
<p>It is intended to be used in reduce functions. The resulting n-tuples are created by SLOTS, which chooses i-th entry of the n-tuples by the SLOTS[i][0]-th entry from the the SLOTS[i][1] set, 0 from the first set and 1 from the second set. The product n-tuples have MARKER and are inserted into KVO under the new key. The new key is selected like values using KEYS[j][0] and KEYS[j][1]. The key is not an n-tuple when NKEYS=1, or an n-tuple of KEYS[j] entries. The n-tuple key has zero as a marker. Note that it does not remove duplicate entries. </p>

<p class="definition">Definition at line <a class="el" href="kmrmoreops_8c_source.html#l01528">1528</a> of file <a class="el" href="kmrmoreops_8c_source.html">kmrmoreops.c</a>.</p>

</div>
</div>
<a id="a486929819eaa18ce566911c8a2c17dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486929819eaa18ce566911c8a2c17dd9">&#9670;&nbsp;</a></span>kmr_create_pushoff_kvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a>* kmr_create_pushoff_kvs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a>&#160;</td>
          <td class="paramname"><em>kf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="kmr_8h.html#a0d4f610f2dcd147372fc8798171da01b">kmr_kv_field</a>&#160;</td>
          <td class="paramname"><em>vf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a new key-value stream with the specified field data-types. </p>
<p>It cannot be used with checkpointing. It allocates by the size of the union, which is larger than the necessary for replacement later by an on-core KVS at <a class="el" href="kmr_8h.html#ac07e8d3c6b4a229295ed3f9d982d1a04" title="Marks finished adding key-value pairs. ">kmr_add_kv_done()</a>. See <a class="el" href="kmraltkvs_8c.html#af5b81854ab94edbf383575ca2a5bd54b" title="Marks finished adding key-value pairs, called from kmr_add_kv_done(). ">kmr_add_kv_done_pushoff()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmraltkvs_8c_source.html#l00085">85</a> of file <a class="el" href="kmraltkvs_8c_source.html">kmraltkvs.c</a>.</p>

</div>
</div>
<a id="a577415d4b9c6db1113d099d712760097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577415d4b9c6db1113d099d712760097">&#9670;&nbsp;</a></span>kmr_init_pushoff_fast_notice_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kmr_init_pushoff_fast_notice_ </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes RDMA for fast-notice. </p>
<p>Fast-notice is RDMA-based event notification to tell readiness of MPI messages. It is only usable with communicators having the same processes. </p>

<p class="definition">Definition at line <a class="el" href="kmraltkvs_8c_source.html#l00726">726</a> of file <a class="el" href="kmraltkvs_8c_source.html">kmraltkvs.c</a>.</p>

</div>
</div>
<a id="a990395f4cb39cdd9d5b64da74765e717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990395f4cb39cdd9d5b64da74765e717">&#9670;&nbsp;</a></span>kmr_check_pushoff_fast_notice_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kmr_check_pushoff_fast_notice_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if fast-notice works. </p>
<p>Check be at immediately after initialization. </p>

<p class="definition">Definition at line <a class="el" href="kmraltkvs_8c_source.html#l00808">808</a> of file <a class="el" href="kmraltkvs_8c_source.html">kmraltkvs.c</a>.</p>

</div>
</div>
<a id="aeb16f94c3684f127671a8112dbcd9747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb16f94c3684f127671a8112dbcd9747">&#9670;&nbsp;</a></span>kmr_assign_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_assign_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__option.html">kmr_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns files to ranks based on data locality. </p>
<p>It assumes that values of key-value pairs in the input KVS are file paths and it shuffles the key-value pairs and writes results to the output KVS so that the files are assigned to near ranks. If the value of a key-value pair is file paths separated by '\0', it will find a rank near from all the files specified in the value. Currently, it only works on the K computer. On the other systems, it just performs <a class="el" href="kmr_8h.html#a194686701b3c46a869fe9eb2cab93252" title="Shuffles key-value pairs to the appropriate destination ranks. ">kmr_shuffle()</a>. Effective-options: INSPECT, TAKE_CKPT. See struct <a class="el" href="structkmr__option.html" title="Options to Mapping, Shuffling, and Reduction. ">kmr_option</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmriolb_8c_source.html#l00257">257</a> of file <a class="el" href="kmriolb_8c_source.html">kmriolb.c</a>.</p>

</div>
</div>
<a id="a668e7b808fa3a039521964831825bb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668e7b808fa3a039521964831825bb3f">&#9670;&nbsp;</a></span>kmr_detach_swf_workers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_detach_swf_workers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disengages the workers from main processing and puts them in the service loop for spawning. </p>
<p>Only the master rank returns from this call and continues processing, but the worker ranks never return as if they call exit(). It replaces the communicator in the KMR context with a self-communicator after saving the old communicator for workflow. Replacing the communicator makes the context independent from the other ranks and safe to free it. It finalizes the context of workers. </p>

<p class="definition">Definition at line <a class="el" href="kmrwfmap_8c_source.html#l00659">659</a> of file <a class="el" href="kmrwfmap_8c_source.html">kmrwfmap.c</a>.</p>

</div>
</div>
<a id="a3df4a8125b1af6129fce5de92822202e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df4a8125b1af6129fce5de92822202e">&#9670;&nbsp;</a></span>kmr_map_swf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_map_swf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionkmr__kvs.html">KMR_KVS</a> *&#160;</td>
          <td class="paramname"><em>kvo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structkmr__spawn__option.html">kmr_spawn_option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmr_8h.html#a710ca6341d4cbe82f7e62d0f63c19ebb">kmr_mapfn_t</a>&#160;</td>
          <td class="paramname"><em>mapfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps with a simple workflow. </p>
<p>The ranks are configured as lanes, which should be initialized by <a class="el" href="kmrwfmap_8c.html#aa2113e75854b4de98116829cf26b3a91" title="Initializes the lanes of simple workflow. ">kmr_init_swf()</a> in advance. The key part specifies the lane like "3.3.3", and the value part specifies the command-line arguments. The work-items in a lane run in the FIFO order. The lane specification can be an any-lane using a wildcard like "3.3.*". The higher level lane blocks the sublanes, thus, for example, an entry with the lane "3.3" blocks the following entries with the lanes "3.3.*". </p>

<p class="definition">Definition at line <a class="el" href="kmrwfmap_8c_source.html#l02112">2112</a> of file <a class="el" href="kmrwfmap_8c_source.html">kmrwfmap.c</a>.</p>

</div>
</div>
<a id="a1dbeb040b750ed83c978d8f92570780b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbeb040b750ed83c978d8f92570780b">&#9670;&nbsp;</a></span>kmr_stop_swf_workers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_stop_swf_workers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes the workers of workflow. </p>
<p>It stops the service loop of the workers and lets them exit. It should be called (immediately) before MPI_Finalize() at the master rank. </p>

<p class="definition">Definition at line <a class="el" href="kmrwfmap_8c_source.html#l00731">731</a> of file <a class="el" href="kmrwfmap_8c_source.html">kmrwfmap.c</a>.</p>

</div>
</div>
<a id="a9f328ef113ef3d72d582ae2d91c888d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f328ef113ef3d72d582ae2d91c888d7">&#9670;&nbsp;</a></span>kmr_finish_swf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmr_finish_swf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the lanes of simple workflow. </p>

<p class="definition">Definition at line <a class="el" href="kmrwfmap_8c_source.html#l00750">750</a> of file <a class="el" href="kmrwfmap_8c_source.html">kmrwfmap.c</a>.</p>

</div>
</div>
<a id="acf1ca392e7e9052593253997e40968ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1ca392e7e9052593253997e40968ee">&#9670;&nbsp;</a></span>kmr_dump_swf_lanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kmr_dump_swf_lanes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps lanes created by <a class="el" href="kmrwfmap_8c.html#aa2113e75854b4de98116829cf26b3a91" title="Initializes the lanes of simple workflow. ">kmr_init_swf()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrwfmap_8c_source.html#l02054">2054</a> of file <a class="el" href="kmrwfmap_8c_source.html">kmrwfmap.c</a>.</p>

</div>
</div>
<a id="a74a626663117f4a52acbccf45e6a4d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a626663117f4a52acbccf45e6a4d83">&#9670;&nbsp;</a></span>kmr_dump_swf_history()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kmr_dump_swf_history </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the history of <a class="el" href="kmrwfmap_8c.html#a3df4a8125b1af6129fce5de92822202e" title="Maps with a simple workflow. ">kmr_map_swf()</a>, which is the start ordering the work-items. </p>
<p>The work-items are given sequence numbers from zero in the order in the KVS. </p>

<p class="definition">Definition at line <a class="el" href="kmrwfmap_8c_source.html#l02874">2874</a> of file <a class="el" href="kmrwfmap_8c_source.html">kmrwfmap.c</a>.</p>

</div>
</div>
<a id="a048170a6ec1eb5712eaaf9fac8ae8c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048170a6ec1eb5712eaaf9fac8ae8c45">&#9670;&nbsp;</a></span>kmr_dump_swf_order_history()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kmr_dump_swf_order_history </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of start ordering of the work-items. </p>
<p>The work-items are given sequence numbers from zero in the order in the KVS, and the HISTORY vector is filled by them in the order of the starts of the work-items. The COUNT specifies the allocated length of the history vector. </p>

<p class="definition">Definition at line <a class="el" href="kmrwfmap_8c_source.html#l02904">2904</a> of file <a class="el" href="kmrwfmap_8c_source.html">kmrwfmap.c</a>.</p>

</div>
</div>
<a id="abb21fb4ad971112227ec9abc69dba222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb21fb4ad971112227ec9abc69dba222">&#9670;&nbsp;</a></span>kmr_free_swf_history()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kmr_free_swf_history </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the history recorded in <a class="el" href="kmrwfmap_8c.html#a3df4a8125b1af6129fce5de92822202e" title="Maps with a simple workflow. ">kmr_map_swf()</a>. </p>
<p>The history is also automatically cleared when a next call to <a class="el" href="kmrwfmap_8c.html#a3df4a8125b1af6129fce5de92822202e" title="Maps with a simple workflow. ">kmr_map_swf()</a>. </p>

<p class="definition">Definition at line <a class="el" href="kmrwfmap_8c_source.html#l02933">2933</a> of file <a class="el" href="kmrwfmap_8c_source.html">kmrwfmap.c</a>.</p>

</div>
</div>
<a id="af34aac60d0099ad33e3c9746dc7b9be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34aac60d0099ad33e3c9746dc7b9be9">&#9670;&nbsp;</a></span>kmr_set_swf_verbosity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kmr_set_swf_verbosity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmr__ctx.html">KMR</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the verbosity of the spawn-library. </p>
<p>LEVEL is 1 to 3, where 3 is the most verbose. It should be called after <a class="el" href="kmrwfmap_8c.html#aa2113e75854b4de98116829cf26b3a91" title="Initializes the lanes of simple workflow. ">kmr_init_swf()</a> and before detaching by <a class="el" href="kmrwfmap_8c.html#a668e7b808fa3a039521964831825bb3f" title="Disengages the workers from main processing and puts them in the service loop for spawning...">kmr_detach_swf_workers()</a> to affect worker ranks. </p>

<p class="definition">Definition at line <a class="el" href="kmrwfmap_8c_source.html#l00505">505</a> of file <a class="el" href="kmrwfmap_8c_source.html">kmrwfmap.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac32d00f09d32a01e62b55a9444e23643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32d00f09d32a01e62b55a9444e23643">&#9670;&nbsp;</a></span>kmr_kvs_entry_header</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t kmr_kvs_entry_header = offsetof(struct <a class="el" href="structkmr__kvs__entry.html">kmr_kvs_entry</a>, c)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of an Entry Header. </p>
<p>It is the size of the length fields of a key-value. It is also the size of the slack space for an end-of-block marker, where the end of entries in a block is marded by klen=-1 and vlen=-1. </p>

<p class="definition">Definition at line <a class="el" href="kmr_8h_source.html#l00425">425</a> of file <a class="el" href="kmr_8h_source.html">kmr.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
