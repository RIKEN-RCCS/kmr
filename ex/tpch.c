/* tpch.c (2014-02-04) */

/* It performs SQL queries defined in TPC-H (2.17.0) by map-reduce.
   See "http://www.tpc.org/tpch/", for references to TPC-H by the
   Transaction Processing Performance Council. */

/* HOW TO RUN:
   (1) Make database tables.
   (1.1) Get and unzip "tpch_2_17_0.zip".
   (1.2) Make in the directory "tpch_2_17_0/dbgen" with:
   "make -f makefile.suite CC=gcc DATABASE=DB2 MACHINE=LINUX WORKLOAD=TPCH"
   (1.3) Run "dbgen -f -s 1" ("-s 1" for approximately 1GB of tables).
   (2) mpirun -np 8 a.out directory-of-tables 7 (for QUERY-7).
   Queries implemented are 7, 9, 10, 13, 21.  See the comment below.
   (3) Compare with the answer sets in "tpch_2_17_0/dbgen/answers/". */

/* The selected queries are Q7, Q9, Q10, Q13, and Q21.  The parameters
   for queries are the given ones in the benchmark for validation
   runs.  Q9 is said to be the most complex one.  The others are
   selected considering the clustering by characteristics of the
   queries in the paper "Building and Validating a Reduced TPC-H
   Benchmark (MASCOTS 2006)", although the criteria in the paper are
   not relevant to the workings of map-reduce.  Table name "H" is used
   instead of "PS", preferring to a one character.  */

/* MEMO: The "lineitem" table has no primary key, and "l_orderkey" is
   not one.  MEMO: It makes printing/filling in a string a bit
   difficult. */

/* INPUT TABLES:

   N/nation : {n_nationkey, n_name, n_regionkey, n_comment}
   R/region : {r_regionkey, r_name, r_comment}
   P/part : {p_partkey, p_name, p_mfgr, p_brand, p_type, p_size,
	p_container, p_retailprice, p_comment}
   S/supplier : {s_suppkey, s_name, s_address, s_nationkey, s_phone,
	s_acctbal, s_comment}
   H/partsupp : {ps_partkey, ps_suppkey, ps_availqty, ps_supplycost,
	ps_comment}
   C/customer : {c_custkey, c_name, c_address, c_nationkey, c_phone,
	c_acctbal, c_mktsegment, c_comment}
   O/orders : {o_orderkey, o_custkey, o_orderstatus, o_totalprice,
	o_orderdate, o_orderpriority, o_clerk, o_shippriority,
	o_comment}
   L/lineitem : {l_orderkey, l_partkey, l_suppkey, l_linenumber,
	l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag,
	l_linestatus, l_shipdate, l_commitdate, l_receiptdate,
	l_shipinstruct, l_shipmode, l_comment}

   * RECORDS OF 1 GB DATA SET (Data rows generated by "dbgen -s 1")
   region.tbl: 5
   nation.tbl: 25
   supplier.tbl: 10,000
   customer.tbl: 150,000
   part.tbl: 200,000
   partsupp.tbl: 800,000
   orders.tbl: 1,500,000
   lineitem.tbl: 6,001,215 */

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <inttypes.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/resource.h>
#include <netinet/in.h>
#include <time.h>
#include <sys/time.h>
#include <assert.h>
#include "kmr.h"

#define MIN(a,b) (((a)<(b))?(a):(b))
#define NEVERHERE 0

struct RUN {
    int query;
    int pushoff;
    _Bool load_tables_in_advance;
    _Bool hang_out_communication;
    _Bool redistribute_loaded_tables;
    _Bool use_small_block_size;
    size_t pushoff_block_size_in_kilo;
};

_Bool load_tables_in_advance_;
_Bool redistribute_loaded_tables_;

_Bool files_in_rank_directory = 0;

_Bool report_count_in_messages = 0;
_Bool report_time_to_read = 0;
_Bool report_pushoff_statistics = 0;

#undef USE_TIME_FUNCTIONS

#define MAXCOLS (16)
#define NAME_SIZE (25)

/* Join argument: first (left) or second (right). */

enum {T_FST = 0, T_SND = 1};
#define FST ((int)T_FST)
#define SND ((int)T_SND)

/* MEMO: strnstr() and htonll() are not POSIX */

/* strnlen() in BSD. */

static size_t
strnlen_(const char *s, size_t n)
{
    if (s == 0) {
	return 0;
    }
    const char *p = s;
    const char *limit = (s + n);
    while (*p != 0 && p < limit) {
	p++;
    }
    return (size_t)(p - s);
}

/* strnstr() in BSD. */

static char *
strnstr_(const char *s1, const char *s2, size_t n)
{
    if (s1 == 0 || s2 == 0 || *s2 == 0) {
	return (char *)s1;
    }
    size_t len = strnlen_(s2, n);
    const char *limit = (s1 + n - len + 1);
    int c0 = *s2;
    const char *p = s1;
    while (*p != 0 && p < limit) {
	if (*p == c0 && strncmp(p, s2, len) == 0) {
	    return (char *)p;
	}
	p++;
    }
    return 0;
}

/* htonll() in SOLARIS. */

static uint64_t
htonll_(uint64_t x)
{
    union {uint64_t ll; uint32_t i[2];} v;
    uint32_t lo = (uint32_t)x;
    uint32_t hi = (uint32_t)(x >> 32);
    v.i[0] = htonl(hi);
    v.i[1] = htonl(lo);
    return v.ll;
}

/* getopt() reduced. */

static char *xxx_optarg;
static int xxx_optind = 1;
static int xxx_optopt;
/*static int xxx_opterr;*/

static int
xxx_getopt(int argc, char **argv, char *optstring)
{

    if (xxx_optind >= argc) {
	return -1;
    }
    char *p = argv[xxx_optind];
    if (p[0] != '-') {
	xxx_optopt = p[0];
	return -1;
    } else if (strcmp(p, "-") == 0) {
	xxx_optopt = p[0];
	return -1;
    } else if (strcmp(p, "--") == 0) {
	xxx_optopt = p[0];
	xxx_optind++;
	return -1;
    } else {
	xxx_optopt = p[1];
	char *o = strchr(optstring, xxx_optopt);
	if (o == 0) {
	    return '?';
	} else if (o[1] != ':') {
	    xxx_optarg = 0;
	    if (p[2] == 0) {
		xxx_optind++;
	    }
	    return xxx_optopt;
	} else {
	    if (p[2] == 0) {
		xxx_optind++;
		if (xxx_optind < argc) {
		    xxx_optarg = argv[xxx_optind];
		    xxx_optind++;
		    return xxx_optopt;
		} else {
		    return '?';
		}
	    } else {
		xxx_optarg = &p[2];
		xxx_optind++;
		return xxx_optopt;
	    }
	}
    }
}

enum TABLE {
    TAB_NIL = 0,

    TAB_N, TAB_R, TAB_P, TAB_S, TAB_H, TAB_C, TAB_O, TAB_L,

    TAB_Q7_N1, TAB_Q7_NN, TAB_Q7_S1, TAB_Q7_NNS,
    TAB_Q7_C1, TAB_Q7_O1, TAB_Q7_CO, TAB_Q7_L1,
    TAB_Q7_CLO, TAB_Q7_CLNNOS0, TAB_Q7_CLNNOS1, TAB_Q7_REVENUE,

    TAB_Q9, TAB_Q9_PH, TAB_Q9_NS, TAB_Q9_PHSN,
    TAB_Q9_LO, TAB_Q9_PHSNLO, TAB_Q9_AMOUNT,

    TAB_Q10_L1, TAB_Q10_O1, TAB_Q10_LO, TAB_Q10_C1,
    TAB_Q10_N1, TAB_Q10_CN, TAB_Q10_CLNO0, TAB_Q10_CLNO1,

    TAB_Q13_O1, TAB_Q13_CO0, TAB_Q13_CO1,

    TAB_Q21_N1, TAB_Q21_NS, TAB_Q21_L1, TAB_Q21_O1,
    TAB_Q21_L3, TAB_Q21_LNS, TAB_Q21_NAME,
    TAB_Q21_NUMWAIT
};

KMR_KVS *N0, *R0, *P0, *S0, *H0, *C0, *O0, *L0;

enum FIELD {F_NIL, F_ZAHL, F_REAL, F_TEXT, F_DATE};

struct COLUMN {
    char *label;
    enum FIELD field;
};

struct RECORD {
    int ncolumns;
    struct COLUMN columns[MAXCOLS];
    int nkeys;
    struct COLUMN keys[MAXCOLS];
};

/* Byte Count Limit to Store a Record. */

#define RECORD_SIZE (1024)

struct TABLE_INFO {
    enum TABLE name;
    struct {
	KMR_KVS **variable;
	char *file;
	int nread;
	int nfiles;
	int nb;
	void **buffers;
	size_t *sizes;
    } data;
    struct RECORD description;
} tables[] = {
    {TAB_N, {&N0, "nation.tbl", 1, 0, 0, 0, 0},
     {4, {{"n_nationkey", F_ZAHL},
	  {"n_name", F_TEXT},
	  {"n_regionkey", F_ZAHL},
	  {"n_comment", F_TEXT}},
      1, {{"n_nationkey", F_ZAHL}}}},
    {TAB_R, {&R0, "region.tbl", 1, 0, 0, 0, 0},
     {3, {{"r_regionkey", F_ZAHL},
	  {"r_name", F_TEXT},
	  {"r_comment", F_TEXT}},
      1, {{"r_regionkey", F_ZAHL}}}},
    {TAB_P, {&P0, "part.tbl", 2, 0, 0, 0, 0},
     {9, {{"p_partkey", F_ZAHL},
	  {"p_name", F_TEXT},
	  {"p_mfgr", F_TEXT},
	  {"p_brand", F_TEXT},
	  {"p_type", F_TEXT},
	  {"p_size", F_ZAHL},
	  {"p_container", F_TEXT},
	  {"p_retailprice", F_REAL},
	  {"p_comment", F_TEXT}},
      1, {{"p_partkey", F_ZAHL}}}},
    {TAB_S, {&S0, "supplier.tbl", 2, 0, 0, 0, 0},
     {7, {{"s_suppkey", F_ZAHL},
	  {"s_name", F_TEXT},
	  {"s_address", F_TEXT},
	  {"s_nationkey", F_ZAHL},
	  {"s_phone", F_TEXT},
	  {"s_acctbal", F_REAL},
	  {"s_comment", F_TEXT}},
      1, {{"s_suppkey", F_ZAHL}}}},
    {TAB_H, {&H0, "partsupp.tbl", 2, 0, 0, 0, 0},
     {5, {{"ps_partkey", F_ZAHL},
	  {"ps_suppkey", F_ZAHL},
	  {"ps_availqty", F_ZAHL},
	  {"ps_supplycost", F_REAL},
	  {"ps_comment", F_TEXT}},
      1, {{"ps_partkey", F_ZAHL}}}},
    {TAB_C, {&C0, "customer.tbl", 2, 0, 0, 0, 0},
     {8, {{"c_custkey", F_ZAHL},
	  {"c_name", F_TEXT},
	  {"c_address", F_TEXT},
	  {"c_nationkey", F_ZAHL},
	  {"c_phone", F_TEXT},
	  {"c_acctbal", F_REAL},
	  {"c_mktsegment", F_TEXT},
	  {"c_comment", F_TEXT}},
      1, {{"c_custkey", F_ZAHL}}}},
    {TAB_O, {&O0, "orders.tbl", 2, 0, 0, 0, 0},
     {9, {{"o_orderkey", F_ZAHL},
	  {"o_custkey", F_ZAHL},
	  {"o_orderstatus", F_TEXT},
	  {"o_totalprice", F_REAL},
	  {"o_orderdate", F_DATE},
	  {"o_orderpriority", F_TEXT},
	  {"o_clerk", F_TEXT},
	  {"o_shippriority", F_ZAHL},
	  {"o_comment", F_TEXT}},
      1, {{"o_orderkey", F_ZAHL}}}},
    {TAB_L, {&L0, "lineitem.tbl", 2, 0, 0, 0, 0},
     {16, {{"l_orderkey", F_ZAHL},
	   {"l_partkey", F_ZAHL},
	   {"l_suppkey", F_ZAHL},
	   {"l_linenumber", F_REAL},
	   {"l_quantity", F_REAL},
	   {"l_extendedprice", F_REAL},
	   {"l_discount", F_REAL},
	   {"l_tax", F_REAL},
	   {"l_returnflag", F_TEXT},
	   {"l_linestatus", F_TEXT},
	   {"l_shipdate", F_DATE},
	   {"l_commitdate", F_DATE},
	   {"l_receiptdate", F_DATE},
	   {"l_shipinstruct", F_TEXT},
	   {"l_shipmode", F_TEXT},
	   {"l_comment", F_TEXT}},
      1, {{"l_orderkey", F_ZAHL}}}},

    /*(Q7)*/

    {TAB_Q7_N1, {0},
     {2, {{"n_nationkey", F_ZAHL},
	  {"n_name", F_TEXT}},
      0, {{0, F_NIL}}}},
    {TAB_Q7_NN, {0},
     {4, {{"n1.n_nationkey", F_ZAHL},
	  {"n1.n_name", F_TEXT},
	  {"n2.n_nationkey", F_ZAHL},
	  {"n2.n_name", F_TEXT}},
      1, {{"n1.n_nationkey", F_ZAHL}}}},
    {TAB_Q7_S1, {0},
     {2, {{"s_nationkey", F_ZAHL},
	  {"s_suppkey", F_ZAHL}},
      1, {{"s_nationkey", F_ZAHL}}}},
    {TAB_Q7_NNS, {0},
     {4, {{"n2.n_nationkey", F_ZAHL},
	  {"s_suppkey", F_ZAHL},
	  {"n1.n_name", F_TEXT},
	  {"n2.n_name", F_TEXT}},
      2, {{"n2.s_nationkey", F_ZAHL},
	  {"s_suppkey", F_ZAHL}}}},
    {TAB_Q7_C1, {0},
     {2, {{"c_custkey", F_ZAHL},
	  {"c_nationkey", F_ZAHL}},
      1, {{"c_custkey", F_ZAHL}}}},
    {TAB_Q7_O1, {0},
     {2, {{"o_custkey", F_ZAHL},
	  {"o_orderkey", F_ZAHL}},
      1, {{"o_custkey", F_ZAHL}}}},
    {TAB_Q7_CO, {0},
     {2, {{"o_orderkey", F_ZAHL},
	  {"c_nationkey", F_ZAHL}},
      1, {{"o_orderkey", F_ZAHL}}}},
    {TAB_Q7_L1, {0},
     {4, {{"l_orderkey", F_ZAHL},
	  {"l_suppkey", F_ZAHL},
	  {"year", F_DATE},
	  {"volume", F_REAL}},
      1, {{"l_orderkey", F_ZAHL}}}},
    {TAB_Q7_CLO, {0},
     {4, {{"c_nationkey", F_ZAHL},
	  {"l_suppkey", F_ZAHL},
	  {"year", F_DATE},
	  {"volume", F_REAL}},
      2, {{"c_nationkey", F_ZAHL},
	  {"l_suppkey", F_ZAHL}}}},
    {TAB_Q7_CLNNOS0, {0},
     {4, {{"n1.n_name", F_TEXT},
	  {"n2.n_name", F_TEXT},
	  {"year", F_DATE},
	  {"volume", F_REAL}},
      0, {{0, F_NIL}}}},
    {TAB_Q7_CLNNOS1, {0},
     {4, {{"n1.n_name", F_TEXT},
	  {"n2.n_name", F_TEXT},
	  {"year", F_DATE},
	  {"volume", F_REAL}},
      3, {{"n1.n_name", F_TEXT},
	  {"n2.n_name", F_TEXT},
	  {"year", F_DATE}}}},
    {TAB_Q7_REVENUE, {0},
     {4, {{"n1.n_name", F_TEXT},
	  {"n2.n_name", F_TEXT},
	  {"year", F_DATE},
	  {"revenue", F_REAL}},
      3, {{"n1.n_name", F_TEXT},
	  {"n2.n_name", F_TEXT},
	  {"year", F_DATE}}}},

    /*(Q9)*/

    {TAB_Q9, {0},
     {3, {{"n_name", F_TEXT},
	  {"o_orderdate", F_DATE},
	  {"amount", F_REAL}},
      1, {{"nation+year", F_NIL}}}},
    {TAB_Q9_PH, {0},
     {3, {{"ps_partkey", F_ZAHL},
	  {"ps_suppkey", F_ZAHL},
	  {"ps_supplycost", F_REAL}},
      1, {{"ps_suppkey", F_ZAHL}}}},
    {TAB_Q9_NS, {0},
     {2, {{"n_name", F_TEXT},
	  {"s_suppkey", F_ZAHL}},
      1, {{"s_suppkey", F_ZAHL}}}},
    {TAB_Q9_PHSN, {0},
     {4, {{"n_name", F_TEXT},
	  {"ps_partkey", F_ZAHL},
	  {"ps_suppkey", F_ZAHL},
	  {"ps_supplycost", F_REAL}},
      2, {{"ps_partkey", F_ZAHL},
	  {"ps_suppkey", F_ZAHL}}}},
    {TAB_Q9_LO, {0},
     {6, {{"l_discount", F_REAL},
	  {"l_extendedprice", F_REAL},
	  {"l_partkey", F_ZAHL},
	  {"l_quantity", F_REAL},
	  {"l_suppkey", F_ZAHL},
	  {"o_orderdate", F_DATE}},
      2, {{"l_partkey", F_ZAHL},
	  {"l_suppkey", F_ZAHL}}}},
    {TAB_Q9_PHSNLO, {0},
     {6, {{"l_discount", F_REAL},
	  {"l_extendedprice", F_REAL},
	  {"l_quantity", F_REAL},
	  {"n_name", F_TEXT},
	  {"o_orderdate", F_DATE},
	  {"ps_supplycost", F_REAL}},
      1, {{"o_orderdate", F_DATE}}}},
    {TAB_Q9_AMOUNT, {0},
     {3, {{"nation", F_TEXT},
	  {"year", F_DATE},
	  {"amount", F_REAL}},
      2, {{"nation", F_TEXT},
	  {"year", F_DATE}}}},

    /*(Q10)*/

    {TAB_Q10_L1, {0},
     {2, {{"l_orderkey", F_ZAHL},
	  {"volume", F_REAL}},
      1, {{"l_orderkey", F_ZAHL}}}},
    {TAB_Q10_O1, {0},
     {2, {{"o_orderkey", F_ZAHL},
	  {"o_custkey", F_ZAHL}},
      1, {{"o_orderkey", F_ZAHL}}}},
    {TAB_Q10_LO, {0},
     {2, {{"o_custkey", F_ZAHL},
	  {"volume", F_REAL}},
      1, {{"o_custkey", F_ZAHL}}}},
    {TAB_Q10_C1, {0},
     {7, {{"c_nationkey", F_ZAHL},
	  {"c_custkey", F_ZAHL},
	  {"c_name", F_TEXT},
	  {"c_acctbal", F_REAL},
	  {"c_phone", F_TEXT},
	  {"c_address", F_TEXT},
	  {"c_comment", F_TEXT}},
      1, {{"c_nationkey", F_ZAHL}}}},
    {TAB_Q10_N1, {0},
     {7, {{"n_nationkey", F_ZAHL},
	  {"n_name", F_TEXT}},
      1, {{"n_nationkey", F_ZAHL}}}},
    {TAB_Q10_CN, {0},
     {7, {{"c_custkey", F_ZAHL},
	  {"c_name", F_TEXT},
	  {"c_acctbal", F_REAL},
	  {"c_phone", F_TEXT},
	  {"n_name", F_TEXT},
	  {"c_address", F_TEXT},
	  {"c_comment", F_TEXT}},
      1, {{"c_custkey", F_ZAHL}}}},
    {TAB_Q10_CLNO0, {0},
     {8, {{"c_custkey", F_ZAHL},
	  {"c_name", F_TEXT},
	  {"c_acctbal", F_REAL},
	  {"c_phone", F_TEXT},
	  {"n_name", F_TEXT},
	  {"c_address", F_TEXT},
	  {"c_comment", F_TEXT},
	  {"volume", F_REAL}},
      7, {{"c_custkey", F_ZAHL},
	  {"c_name", F_TEXT},
	  {"c_acctbal", F_REAL},
	  {"c_phone", F_TEXT},
	  {"n_name", F_TEXT},
	  {"c_address", F_TEXT},
	  {"c_comment", F_TEXT}}}},
    {TAB_Q10_CLNO1, {0},
     {8, {{"c_custkey", F_ZAHL},
	  {"c_name", F_TEXT},
	  {"revenue", F_REAL},
	  {"c_acctbal", F_REAL},
	  {"n_name", F_TEXT},
	  {"c_address", F_TEXT},
	  {"c_phone", F_TEXT},
	  {"c_comment", F_TEXT}},
      1, {{"revenue", F_REAL}}}},

    /*(Q13)*/

    {TAB_Q13_O1, {0},
     {1, {{"o_orderkey", F_ZAHL}},
      1, {{"o_custkey", F_ZAHL}}}},
    {TAB_Q13_CO0, {0},
     {1, {{"c_custkey", F_ZAHL}},
      1, {{"q13_count", F_ZAHL}}}},
    {TAB_Q13_CO1, {0},
     {2, {{"q13_custdist", F_ZAHL},
	  {"q13_count", F_ZAHL}},
      2, {{"q13_custdist", F_ZAHL},
	  {"q13_count", F_ZAHL}}}},

    /*(Q21)*/

    {TAB_Q21_N1, {0},
     {1, {{"n_nationkey", F_ZAHL}},
      1, {{"n_nationkey", F_ZAHL}}}},
    {TAB_Q21_NS, {0},
     {1, {{"s_suppkey", F_ZAHL},
	  {"s_name", F_TEXT}},
      1, {{"s_suppkey", F_ZAHL}}}},
    {TAB_Q21_L1, {0},
     {2, {{"l_orderkey", F_ZAHL},
	  {"l_suppkey", F_ZAHL}},
      1, {{"l_suppkey", F_ZAHL}}}},
    {TAB_Q21_L3, {0},
     {2, {{"l_orderkey", F_ZAHL},
	  {"l_suppkey", F_ZAHL}},
      1, {{"l_orderkey", F_ZAHL}}}},
    {TAB_Q21_LNS, {0},
     {3, {{"l_orderkey", F_ZAHL},
	  {"l_suppkey", F_ZAHL},
	  {"s_name", F_TEXT}},
      1, {{"l_orderkey", F_ZAHL}}}},
    {TAB_Q21_O1, {0},
     {1, {{"o_orderkey", F_ZAHL}},
      1, {{"o_orderkey", F_ZAHL}}}},
    {TAB_Q21_NAME, {0},
     {1, {{"s_name", F_TEXT}},
      1, {{"s_name", F_TEXT}}}},
    {TAB_Q21_NUMWAIT, {0},
     {2, {{"s_name", F_TEXT},
	  {"numwait", F_ZAHL}},
      1, {{"numwait", F_ZAHL},
	  {"s_name", F_TEXT}}}}};

/* Simple Join Command to join_by_fields(). */

struct PRODUCT {
    int /*enum TABLE*/ inputs[2];
    int /*enum TABLE*/ output;
    int ncolumns;
    int columns[MAXCOLS][2];
    int nkeys;
    int keys[MAXCOLS][2];
    _Bool trace_product;
    _Bool trace_product_nonempty;
    _Bool cnt0_zero;
    _Bool cnt1_zero;
    _Bool cnt0_one;
    _Bool cnt1_one;
    _Bool cnt0_zero_one;
    _Bool cnt1_zero_one;
    _Bool cnt0_nonzero;
    _Bool cnt1_nonzero;
};

/* Simple Select Command to select_by_fields(). */

struct SELECT {
    int /*enum TABLE*/ input;
    int /*enum TABLE*/ output;
    int ncolumns;
    int columns[MAXCOLS];
    int nkeys;
    int keys[MAXCOLS];
};

struct SELECT_BY_NAME {
    enum TABLE input;
    enum TABLE output;
    int ncolumns;
    char *columns[MAXCOLS];
    int nkeys;
    char *keys[MAXCOLS];
};

struct SCAN_OP {
    struct TABLE_INFO *tbl;
    kmr_mapfn_t fn;
    void *arg;
};

static double
wtime()
{
    static struct timeval tv0 = {.tv_sec = 0};
    struct timeval tv;
    int cc;
    cc = gettimeofday(&tv, 0);
    assert(cc == 0);
    if (tv0.tv_sec == 0) {
	tv0 = tv;
	assert(tv0.tv_sec != 0);
    }
    double dt = ((double)(tv.tv_sec - tv0.tv_sec)
		 + ((double)(tv.tv_usec - tv0.tv_usec) * 1e-6));
    return dt;
}

/* NOTE: IT IS SYNCHRONIZING WHEN report_count_in_messages. */

static void
pcount(KMR_KVS *kvs0, KMR_KVS *kvs1, char *msg, _Bool before0after1)
{
    KMR *mr = kvs0->c.mr;
    if (report_count_in_messages) {
	long c0;
	kmr_get_element_count(kvs0, &c0);
	long c1 = 0;
	if (kvs1 != 0) {
	    kmr_get_element_count(kvs1, &c1);
	}
	if (mr->rank == 0) {
	    char *s0 = (before0after1 == 0 ? "before" : "after");
	    char *s1 = (before0after1 == 0 ? "..." : "");
	    if (kvs1 != 0) {
		printf("%s %s #=%ld #=%ld%s\n", msg, s0, c0, c1, s1);
		fflush(0);
	    } else {
		printf("%s %s #=%ld%s\n", msg, s0, c0, s1);
		fflush(0);
	    }
	}
    } else {
	if (mr->rank == 0) {
	    char *s0 = (before0after1 == 0 ? "before" : "after");
	    char *s1 = (before0after1 == 0 ? "..." : "");
	    printf("%s %s%s\n", msg, s0, s1);
	    fflush(0);
	}
    }
}

/* NOTE: IT IS SYNCHRONIZING WHEN report_count_in_messages. */

static void
ptime(KMR_KVS *kvs0, KMR_KVS *kvs1, char *func, char *msg, double dt)
{
    KMR *mr = kvs0->c.mr;
    if (report_count_in_messages) {
	if (func == 0) {
	    /* Just synchronize. */
	    long c0;
	    kmr_get_element_count(kvs0, &c0);
	} else {
	    long c0;
	    kmr_get_element_count(kvs0, &c0);
	    long c1 = 0;
	    if (kvs1 != 0) {
		kmr_get_element_count(kvs1, &c1);
	    }
	    if (mr->rank == 0) {
		if (kvs1 != 0) {
		    printf("%s (%s) #=%ld #=%ld in %f sec\n",
			   func, msg, c0, c1, dt);
		    fflush(0);
		} else {
		    printf("%s (%s) #=%ld in %f sec\n",
			   func, msg, c0, dt);
		    fflush(0);
		}
	    }
	}
    } else {
	if (func == 0) {
	    /* nothing. */
	} else if (mr->rank == 0) {
	    printf("%s (%s) in %f sec\n", func, msg, dt);
	    fflush(0);
	}
    }
}

static void
phisto(KMR_KVS *kvs, char *msg)
{
    KMR *mr = kvs->c.mr;
    int nprocs = mr->nprocs;
    long histo[nprocs];
    double var[4];
    kmr_histogram_count_by_ranks(kvs, histo, var, 1);
    if (mr->rank == 0) {
	for (int r = 0; r < nprocs; r++) {
	    printf("%s histo[%d]=%ld\n", msg, r, histo[r]);
	}
	fflush(0);
    }
}

/* Adds a record into KVO.  It strips off a tuple wrapping a key, when
   it is a single-entry to let sorting compare properly. */

static void
add_record(KMR_KVS *kvo, struct kmr_ntuple *k, struct kmr_ntuple *v)
{
    if (k->n == 1) {
	struct kmr_ntuple_entry e = kmr_nth_ntuple(k, 0);
	union kmr_unit_sized k1;
	switch (kvo->c.key_data) {
	case KMR_KV_BAD:
	    assert(kvo->c.key_data != KMR_KV_BAD);
	    k1.i = 0;
	    break;
	case KMR_KV_INTEGER:
	    k1.i = *(long *)e.p;
	    break;
	case KMR_KV_FLOAT8:
	    k1.d = *(double *)e.p;
	    break;
	case KMR_KV_OPAQUE:
	case KMR_KV_POINTER_OWNED:
	case KMR_KV_POINTER_UNMANAGED:
	    k1.p = e.p;
	    break;
	default:
	    assert(NEVERHERE);
	    k1.i = 0;
	    break;
	}
	struct kmr_kv_box kv = {
	    .klen = e.len,
	    .k = k1,
	    .vlen = kmr_size_ntuple(v),
	    .v.p = (void *)v
	};
	kmr_add_kv(kvo, kv);
    } else {
	struct kmr_kv_box kv = {
	    .klen = kmr_size_ntuple(k),
	    .k.p = (void *)k,
	    .vlen = kmr_size_ntuple(v),
	    .v.p = (void *)v
	};
	kmr_add_kv(kvo, kv);
    }
}

static struct TABLE_INFO *
find_table(enum TABLE table)
{
    int ntables = (sizeof(tables) / sizeof(tables[0]));
    for (int i = 0; i < ntables; i++) {
	if (tables[i].name == table) {
	    return &(tables[i]);
	}
    }
    assert(NEVERHERE);
    return 0;
}

static struct RECORD *
find_description(enum TABLE table)
{
    struct TABLE_INFO *tbl = find_table(table);
    return &(tbl->description);
}

static int
column_index_by_name(struct RECORD *description, char *name)
{
    for (int i = 0; i < MAXCOLS; i++) {
	if (description->columns[i].label == 0) {
	    break;
	}
	if (strcmp(description->columns[i].label, name) == 0) {
	    return i;
	}
    }
    assert(NEVERHERE);
    return 0;
}

static struct kmr_ntuple_entry
column_by_name(struct kmr_ntuple *u, struct RECORD *description, char *name)
{
    int c = column_index_by_name(description, name);
    struct kmr_ntuple_entry e = kmr_nth_ntuple(u, c);
    return e;
}

static void
put_columns_by_indexes(KMR *mr, struct kmr_ntuple *v, size_t vsz,
		       struct kmr_ntuple *u, int *cols, int ncols)
{
    for (int i = 0; i < ncols; i++) {
	struct kmr_ntuple_entry e = kmr_nth_ntuple(u, cols[i]);
	kmr_put_ntuple_entry(mr, v, (int)vsz, e);
    }
}

static void
put_columns_by_names(KMR *mr, struct kmr_ntuple *v, size_t vsz,
		     struct kmr_ntuple *u, struct RECORD *d,
		     char **columns, int ncolumns)
{
    for (int i = 0; i < ncolumns; i++) {
	char *name = columns[i];
	struct kmr_ntuple_entry e = column_by_name(u, d, name);
	kmr_put_ntuple_entry(mr, v, (int)vsz, e);
    }
}

#if 0
static void
assert_column_fields(int inputs[2], int output,
		     int columns[][2], int ncolumns,
		     int keys[][2], int nkeys)
{
    struct RECORD *a = find_description((enum TABLE)inputs[0]);
    struct RECORD *b = find_description((enum TABLE)inputs[1]);
    struct RECORD *o = find_description((enum TABLE)output);
    assert(o->ncolumns == ncolumns);
    for (int i = 0; i < ncolumns; i++) {
	int *choice = columns[i];
	assert(choice[0] < (choice[1] == 0 ? a : b)->ncolumns);
	enum FIELD fi = ((choice[1] == 0 ? a : b)->columns[choice[0]]).field;
	enum FIELD fo = o->columns[i].field;
	assert(fi == fo);
    }
    assert(o->nkeys == nkeys);
    for (int i = 0; i < nkeys; i++) {
	int *choice = keys[i];
	assert(choice[0] < (choice[1] == 0 ? a : b)->ncolumns);
	enum FIELD fi = ((choice[1] == 0 ? a : b)->columns[choice[0]]).field;
	enum FIELD fo = o->keys[i].field;
	assert(fi == fo);
    }
}
#endif

/* It returns an integer for a date string, which keeps ordering and
   is invertible.  (Returns time_t for a date string (ISO) or -1). */

static time_t
decode_date(char *p)
{
#ifdef USE_TIME_FUNCTIONS
    {
	struct tm tm;
	char *end = strptime(p, "%F", &tm);
	time_t tv = mktime(&tm);
	if ((tv == (time_t)-1) || ((end - p) != 10)) {
	    return (time_t)-1;
	}
	return tv;
    }
#else
    {
	assert(sizeof(time_t) >= 8);
	/*'1995-03-15'*/
	if ((p[4] != '-') || (p[7] != '-')) {
	    return (time_t)-1;
	}
	for (int i = 0; i < 10; i++) {
	    if ((i != 4 && i != 7) && !('0' <= p[i] && p[i] <= '9')) {
		return (time_t)-1;
	    }
	}
	long v = (((long)p[0] << 8*7) | ((long)p[1] << 8*6)
		  | ((long)p[2] << 8*5) | ((long)p[3] << 8*4)
		  | ((long)p[5] << 8*3) | ((long)p[6] << 8*2)
		  | ((long)p[8] << 8*1) | ((long)p[9] << 8*0));
	time_t tv = v;
	return tv;
    }
#endif /*USE_TIME_FUNCTIONS*/
}

/* Fills a string for a date and returns its length or returns 0. */

static size_t
format_date(char *s, size_t sz, time_t tv)
{
#ifdef USE_TIME_FUNCTIONS
    {
	struct tm tmbuf;
	struct tm *tm = localtime_r(&tv, &tmbuf);
	if (tm == 0) {
	    return 0;
	}
	size_t cx = strftime(s, sz, "%F", tm);
	return cx;
    }
#else
    {
	assert(sz >= 10);
	long v = tv;
	s[0] = (char)((v >> 8*7) & 0xff);
	s[1] = (char)((v >> 8*6) & 0xff);
	s[2] = (char)((v >> 8*5) & 0xff);
	s[3] = (char)((v >> 8*4) & 0xff);
	s[4] = '-';
	s[5] = (char)((v >> 8*3) & 0xff);
	s[6] = (char)((v >> 8*2) & 0xff);
	s[7] = '-';
	s[8] = (char)((v >> 8*1) & 0xff);
	s[9] = (char)((v >> 8*0) & 0xff);
	return 10;
    }
#endif /*USE_TIME_FUNCTIONS*/
}

/* Returns the year part (as January first) of the date. */

static time_t
year_value(time_t date)
{
#ifdef USE_TIME_FUNCTIONS
    {
	struct tm tm;
	struct tm *tmx = localtime_r(&date, &tm);
	assert(tmx != 0);
	tm.tm_sec = 0;
	tm.tm_min = 0;
	tm.tm_hour = 0;
	tm.tm_mday = 1;
	tm.tm_mon = 0;
	/*tm.tm_year*/
	/*tm.tm_wday*/
	/*tm.tm_yday*/
	/*tm.tm_isdst*/
	time_t year = mktime(&tm);
	assert(year != (time_t)-1);

#if 0
	char tv0[32], tv1[32];
	struct tm tm0, tm1;
	localtime_r(&date, &tm0);
	strftime(tv0, sizeof(tv0), "%F", &tm0);
	localtime_r(&year, &tm1);
	strftime(tv1, sizeof(tv1), "%F", &tm1);
	printf("date=%s year=%s\n", tv0, tv1); fflush(0);
#endif

	return year;
    }
#else
    {
	long m = (((long)0xff << 8*3) | ((long)0xff << 8*2)
		  | ((long)0xff << 8*1) | ((long)0xff << 8*0));
	long z = (((long)'0' << 8*3) | ((long)'1' << 8*2)
		  | ((long)'0' << 8*1) | ((long)'1' << 8*0));
	long v = ((date & ~m) | z);
	time_t year = v;
	return year;
    }
#endif /*USE_TIME_FUNCTIONS*/
}

static long
get_int_column_by_index(struct kmr_ntuple *u, struct COLUMN *columns, int nth)
{
    assert(columns[nth].field == F_ZAHL);
    struct kmr_ntuple_entry e = kmr_nth_ntuple(u, nth);
    long v = *(long *)(e.p);
    return v;
}

static double
get_real_column_by_index(struct kmr_ntuple *u, struct COLUMN *columns, int nth)
{
    assert(columns[nth].field == F_REAL);
    struct kmr_ntuple_entry e = kmr_nth_ntuple(u, nth);
    double v = *(double *)(e.p);
    return v;
}

static double
get_real_column(struct kmr_ntuple *u, struct RECORD *description,
		char *name)
{
    int nth = column_index_by_name(description, name);
    assert(description->columns[nth].field == F_REAL);
    struct kmr_ntuple_entry e = kmr_nth_ntuple(u, nth);
    double v = *(double *)(e.p);
    return v;
}

#if 0
static char *
get_text_column_by_index(struct kmr_ntuple *u, struct COLUMN *columns, int nth)
{
    assert(columns[nth].field == F_TEXT);
    struct kmr_ntuple_entry e = kmr_nth_ntuple(u, nth);
    char *v = e.p;
    return v;
}
#endif

static time_t
get_date_column_by_index(struct kmr_ntuple *u, struct COLUMN *columns, int nth)
{
    assert(columns[nth].field == F_DATE);
    struct kmr_ntuple_entry e = kmr_nth_ntuple(u, nth);
    time_t v = *(time_t *)(e.p);
    return v;
}

static time_t
get_date_column(struct kmr_ntuple *u, struct RECORD *description, char *name)
{
    int nth = column_index_by_name(description, name);
    assert(description->columns[nth].field == F_DATE);
    struct kmr_ntuple_entry e = kmr_nth_ntuple(u, nth);
    time_t v = *(time_t *)(e.p);
    return v;
}

/* Scans a (newline-terminated) input line and fills an n-tuple U, in
   accordance with datatypes given by descriptions DESCS[column]. */

static void
scan_columns(KMR *mr, struct kmr_ntuple *u, int bufsz,
	     char *line, size_t linesz, struct TABLE_INFO *tbl)
{
    int cc;

    int marker = (int)tbl->name;
    struct RECORD *description = &(tbl->description);
    struct COLUMN *descs = description->columns;
    int ndescs = description->ncolumns;

    kmr_reset_ntuple(u, ndescs, marker);
    char * const end = (line + linesz);
    char *p = line;
    for (int i = 0; i < ndescs; i++) {
	char *s = p;
	while (s < end && *s != '|') {
	    s++;
	}
	char * const q = ((s == end) ? 0 : s);
	if (q == 0) {
	    fprintf(stderr, "Fewer fields in line (%s)\n", line);
	    MPI_Abort(MPI_COMM_WORLD, 1);
	    return;
	}

	assert(*q == '|');
	*q = 0;
	switch (descs[i].field) {
	default:
	case F_NIL:
	    assert(NEVERHERE);
	    break;
	case F_ZAHL: {
	    long v;
	    char gomi[4];
	    cc = sscanf(p, "%ld%c", &v, gomi);
	    if (cc != 1) {
		*q = '|';
		fprintf(stderr, "Bad integer in %d-th field in line (%s)\n",
			i, line);
		MPI_Abort(MPI_COMM_WORLD, 1);
		return;
	    }
	    kmr_put_ntuple(mr, u, bufsz, &v, (int)sizeof(v));
	    break;
	}
	case F_REAL: {
	    double v;
	    char gomi[4];
	    cc = sscanf(p, "%lf%c", &v, gomi);
	    if (cc != 1) {
		*q = '|';
		fprintf(stderr, "Bad real in %d-th field in line (%s)\n",
			i, line);
		MPI_Abort(MPI_COMM_WORLD, 1);
		return;
	    }
	    kmr_put_ntuple(mr, u, bufsz, &v, (int)sizeof(v));
	    break;
	}
	case F_TEXT: {
	    char *v = p;
	    int len = (int)(q - p);
	    kmr_put_ntuple(mr, u, bufsz, v, len);
	    break;
	}
	case F_DATE: {
	    time_t tv = decode_date(p);
	    if (tv == (time_t)-1) {
		*q = '|';
		fprintf(stderr, "Bad date in %d-th field in line (%s)\n",
			i, line);
		MPI_Abort(MPI_COMM_WORLD, 1);
		return;
	    }
	    long v = tv;
	    kmr_put_ntuple(mr, u, bufsz, &v, (int)sizeof(v));
	    break;
	}
	}
	*q = '|';
	p = (q + 1);
    }
    if (*p != '\n') {
	fprintf(stderr, "(warning) Extra characters in line (%s)\n", line);
	fflush(0);
    }
}

static int
scan_line(const struct kmr_kv_box kv0,
	  const KMR_KVS *kvi, KMR_KVS *kvo, void *p0,
	  const long index)
{
    char line[RECORD_SIZE];
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    KMR *mr = kvo->c.mr;

    struct SCAN_OP *scanner = p0;
    struct TABLE_INFO *tbl = scanner->tbl;
    char *p = (void *)kv0.v.p;
    size_t linesz = (size_t)kv0.vlen;

    assert(linesz < sizeof(line));
    memcpy(line, p, linesz);
    line[linesz] = 0;

    scan_columns(mr, v, sizeof(vbuf), line, linesz, tbl);

    struct kmr_ntuple_entry key = kmr_nth_ntuple(v, 0);
    struct kmr_kv_box kv = {
	.klen = key.len,
	.k.p = key.p,
	.vlen = kmr_size_ntuple(v),
	.v.p = (void *)v
    };

    if (scanner->fn == 0) {
	kmr_add_kv(kvo, kv);
    } else {
	(*scanner->fn)(kv, kvi, kvo, scanner->arg, index);
    }
    return MPI_SUCCESS;
}

static void load_table_files_in_memory(int nprocs, int rank, char *directory,
				       struct TABLE_INFO *tbl);
static void load_one_table_file_in_memory(int nprocs, int rank,
					  struct TABLE_INFO *tbl,
					  char *filename, _Bool singlefile);

static void
load_input_tables(int nprocs, int rank, char *directory,
		  enum TABLE *tbls, int ntbls)
{
    assert(directory != 0);

    if (rank == 0) {
	printf("reading table files (in advance)...\n");
	fflush(0);
    }
    MPI_Barrier(MPI_COMM_WORLD);
    double t0 = wtime();

    for (int i = 0; i < ntbls; i++) {
	struct TABLE_INFO *tbl = find_table(tbls[i]);
	assert(tbl->data.nread != 0);
	load_table_files_in_memory(nprocs, rank, directory, tbl);
    }

    MPI_Barrier(MPI_COMM_WORLD);
    double t1 = wtime();
    if (rank == 0) {
	printf("reading table files (in advance) in %f sec\n", (t1 - t0));
	fflush(0);
    }
}

static void
load_table_files_in_memory(int nprocs, int rank, char *directory,
			   struct TABLE_INFO *tbl)
{
    char filename[256];
    int cc;

    assert(directory != 0);

    if (tbl->data.nread == 0) {
	assert(NEVERHERE);
    } else if (tbl->data.nread == 1) {
	if (rank == 0) {
	    cc = snprintf(filename, sizeof(filename), "%s/%s",
			  directory, tbl->data.file);
	    assert(cc < (int)sizeof(filename));
	    load_one_table_file_in_memory(nprocs, rank, tbl, filename, 1);
	}
    } else if (tbl->data.nread == 2) {
	cc = snprintf(filename, sizeof(filename), "%s/%s",
		      directory, tbl->data.file);
	assert(cc < (int)sizeof(filename));
	cc = access(filename, R_OK);
	if (cc == 0) {
	    /* Single file. */
	    if (rank == 0) {
		load_one_table_file_in_memory(nprocs, rank, tbl, filename, 1);
	    }
	} else if (errno == ENOENT) {
	    /* Multiple files, load by suffix for ranks. */
	    int count = 0;
	    for (int j = 0; j < 50; j++) {
		/* (Start from 1 because 1-origin). */
		int n = (1 + (j * nprocs) + rank);
		cc = snprintf(filename, sizeof(filename), "%s/%s.%d",
			      directory, tbl->data.file, n);
		assert(cc < (int)sizeof(filename));
		cc = access(filename, R_OK);
		if (cc == 0) {
		    load_one_table_file_in_memory(nprocs, rank, tbl, filename, 0);
		    count++;
		} else if (errno == ENOENT) {
		    break;
		} else {
		    perror("access tbl file");
		    MPI_Abort(MPI_COMM_WORLD, 1);
		    return;
		}
	    }
	} else {
	    perror("access tbl file");
	    MPI_Abort(MPI_COMM_WORLD, 1);
	    return;
	}
    } else {
	assert(NEVERHERE);
    }
}

static void
load_one_table_file_in_memory(int nprocs, int rank, struct TABLE_INFO *tbl,
			      char *filename, _Bool singlefile)
{
    int cc;

    int nth = tbl->data.nfiles;
    if (!(nth < tbl->data.nb)) {
	int nb = (singlefile ? 1 : (((nth + 1) + 7) & ~7));
	assert(nth < nb);
	void **bb = realloc(tbl->data.buffers, (sizeof(void *) * (size_t)nb));
	if (bb == 0) {
	    perror("realloc tbl buffer");
	    MPI_Abort(MPI_COMM_WORLD, 1);
	    return;
	}
	for (int i = 0; i < nb; i++) {
	    if (i < tbl->data.nfiles) {
		assert(bb[i] != 0);
	    } else {
		bb[i] = 0;
	    }
	}
	tbl->data.buffers = bb;

	size_t *ss = realloc(tbl->data.sizes, (sizeof(size_t) * (size_t)nb));
	if (ss == 0) {
	    perror("realloc tbl buffer");
	    MPI_Abort(MPI_COMM_WORLD, 1);
	    return;
	}
	for (int i = 0; i < nb; i++) {
	    if (i < tbl->data.nfiles) {
		assert(ss[i] != 0);
	    } else {
		ss[i] = 0;
	    }
	}
	tbl->data.sizes = ss;

	tbl->data.nb = nb;
    }

    assert((nth < tbl->data.nb) && (tbl->data.buffers != 0)
	   && (tbl->data.buffers[nth] == 0));

    {
	int fd = open(filename, O_RDONLY, 0);
	if (fd == -1) {
	    char ee[80];
	    snprintf(ee, sizeof(ee), "open(%s) failed", filename);
	    perror(ee);
	    MPI_Abort(MPI_COMM_WORLD, 1);
	    return;
	}

	struct stat s;
	cc = fstat(fd, &s);
	if (cc != 0) {
	    char ee[80];
	    snprintf(ee, sizeof(ee), "fstat(%s) failed", filename);
	    perror(ee);
	    MPI_Abort(MPI_COMM_WORLD, 1);
	    return;
	}

	off_t fsz = s.st_size;
	assert(fsz > 0);

	/* TAKE CEILING FOR BUFFER SIZE. */

	size_t bsz = (size_t)(((fsz + 8) + (1024 - 1)) & (~(1024 - 1)));
	assert(bsz >= (size_t)fsz);
	char *b = malloc(bsz);
	if (b == 0) {
	    char ee[80];
	    snprintf(ee, sizeof(ee), "malloc(%ld) failed", fsz);
	    perror(ee);
	    MPI_Abort(MPI_COMM_WORLD, 1);
	    return;
	}

	double t0 = wtime();

	off_t chunk = (8 * 1024 * 1024);
	off_t rd = 0;
	while (rd < fsz) {
	    size_t rr = (size_t)MIN((fsz - rd), chunk);
	    ssize_t cx = read(fd, (b + rd), rr);
	    if (cx <= 0) {
		char ee[80];
		snprintf(ee, sizeof(ee), "read(%s) failed", filename);
		perror(ee);
		MPI_Abort(MPI_COMM_WORLD, 1);
		return;
	    }
	    rd += cx;
	}
	cc = close(fd);
	assert(cc == 0);

	double t1 = wtime();

	assert((nth == tbl->data.nfiles) && (tbl->data.buffers[nth] == 0));
	tbl->data.buffers[nth] = b;
	tbl->data.sizes[nth] = (size_t)fsz;
	tbl->data.nfiles++;

	if (report_time_to_read) {
	    fprintf(stderr, "[%05d] reading (%s) sz=%ld in %f sec\n",
		    rank, filename, fsz, (t1 - t0));
	    fflush(0);
	}
    }

#if 0
    long cnt = kvo->c.element_count;
    printf("[%d] reading partial table (%s) n=%ld %f sec\n",
	   rank, filename, cnt, (t1 - t0));
    fflush(0);
#endif

    return;
}

static void scan_table_in_memory(KMR_KVS *kvo, struct TABLE_INFO *tbl,
				 struct SCAN_OP *scanner);

static void
scan_table_files(KMR_KVS *kvo, enum TABLE table, kmr_mapfn_t kvput, void *arg,
		 struct RUN *run)
{
    KMR *mr = kvo->c.mr;

    struct TABLE_INFO *tbl = find_table(table);
    assert(tbl->data.nread != 0);

    if (mr->rank == 0) {
	printf("scanning table file (%s)...\n", tbl->data.file);
	fflush(0);
    }

    double t0 = wtime();

    KMR_KVS *kvs0;
    if (run->redistribute_loaded_tables) {
	kvs0 = kmr_create_kvs(mr, KMR_KV_OPAQUE, KMR_KV_OPAQUE);
    } else {
	kvs0 = kvo;
    }
    struct SCAN_OP scanner = {
	.tbl = tbl,
	.fn = kvput,
	.arg = arg
    };
    scan_table_in_memory(kvs0, tbl, &scanner);

    if (run->redistribute_loaded_tables) {
	assert(kvs0 != kvo);
	kmr_distribute(kvs0, kvo, 0, kmr_noopt);
    }

    *(tbl->data.variable) = kvo;

    double t1 = wtime();

    ptime(kvo, 0, "scanning table file", tbl->data.file, (t1 - t0));
}

static void
scan_table_in_memory(KMR_KVS *kvo, struct TABLE_INFO *tbl,
		     struct SCAN_OP *scanner)
{
    KMR *mr = kvo->c.mr;

    for (int i = 0; i < tbl->data.nfiles; i++) {
	void *b = tbl->data.buffers[i];
	size_t sz = tbl->data.sizes[i];
	struct kmr_option keepopen = {.keep_open = 1};
	kmr_map_getline_in_memory_(mr, b, sz, 0,
				   kvo, scanner, keepopen, scan_line);
    }
    kmr_add_kv_done(kvo);
}

static void
scan_table_files_in_advance(KMR *mr, enum TABLE *tbls, int ntbls,
			    struct RUN *run)
{
    if (mr->rank == 0) {
	printf("scanning tables (in advance)...\n"); fflush(0);
    }
    double t0 = wtime();

    for (int i = 0; i < ntbls; i++) {
	struct TABLE_INFO *tbl = find_table(tbls[i]);
	assert(tbl->data.nread != 0);
	KMR_KVS *kvs = kmr_create_kvs(mr, KMR_KV_OPAQUE, KMR_KV_OPAQUE);
	scan_table_files(kvs, tbl->name, 0, 0, run);
    }

    double t1 = wtime();
    if (mr->rank == 0) {
	printf("scanning tables in %f sec\n", (t1 - t0)); fflush(0);
    }
}

/* Dumps an n-tuple U to a line buffer, in accordance with datatypes
   given by descriptions. */

static void
dump_line(KMR *mr, char *line, int linesz, struct kmr_ntuple *u,
	  struct COLUMN descs[], int ndescs)
{
    int cc;
    assert(u->n == ndescs);
    char *q;
    q = line;
    char *end = &line[linesz];
    for (int i = 0; i < ndescs; i++) {
	if (i > 0) {
	    cc = snprintf(q, (size_t)(end - q), "|");
	    q += cc;
	}
	struct kmr_ntuple_entry p = kmr_nth_ntuple(u, i);
	switch (descs[i].field) {
	default:
	case F_NIL:
	    assert(NEVERHERE);
	    break;
	case F_ZAHL: {
	    assert(p.len == sizeof(long));
	    long v = *(long *)(p.p);
	    cc = snprintf(q, (size_t)(end - q), "%ld", v);
	    if (cc < 0) {
		fprintf(stderr, "Bad integer in %d-th field\n", i);
		MPI_Abort(MPI_COMM_WORLD, 1);
		return;
	    }
	    q += cc;
	    break;
	}
	case F_REAL: {
	    assert(p.len == sizeof(double));
	    double v = *(double *)(p.p);
	    cc = snprintf(q, (size_t)(end - q), "%lf", v);
	    if (cc < 0) {
		fprintf(stderr, "Bad real in %d-th field\n", i);
		MPI_Abort(MPI_COMM_WORLD, 1);
		return;
	    }
	    q += cc;
	    break;
	}
	case F_TEXT: {
	    char *v = p.p;
	    assert((size_t)(p.len + 1) < (size_t)(end - q));
	    cc = snprintf(q, (size_t)(p.len + 1), "%s", v);
	    if (cc < 0) {
		fprintf(stderr, "Bad text in %d-th field\n", i);
		MPI_Abort(MPI_COMM_WORLD, 1);
		return;
	    }
	    /*assert(p.len <= cc);*/
	    q += MIN(p.len, cc);
	    break;
	}
	case F_DATE: {
	    assert(p.len == sizeof(time_t));
	    time_t *v = p.p;
	    size_t cx = format_date(q, (size_t)(end - q), *v);
	    if (cx == 0) {
		fprintf(stderr, "Bad date in %d-th field\n", i);
		MPI_Abort(MPI_COMM_WORLD, 1);
		return;
	    }
	    q += (int)cx;
	    break;
	}
	}
    }
}

#if 0
static int
dump_kv(const struct kmr_kv_box kv0,
	const KMR_KVS *kvi, KMR_KVS *kvo, void *p, const long i)
{
    KMR *mr = kvi->c.mr;
    char line[RECORD_SIZE];
    char buf[RECORD_SIZE];

    struct kmr_ntuple *u = (void *)kv0.v.p;
    struct RECORD *d = find_description((enum TABLE)u->marker);

    if (d->nkeys == 1) {
	struct kmr_ntuple *k = (void *)buf;
	kmr_reset_ntuple(k, 1, -1);
	kmr_put_ntuple(mr, k, (int)sizeof(buf), kv0.k.p, kv0.klen);
	dump_line(kvi->c.mr, line, (int)sizeof(line), k,
		  d->keys, d->nkeys);
	printf("%s:", line);
    } else {
	struct kmr_ntuple *k = (void *)kv0.k.p;
	dump_line(kvi->c.mr, line, (int)sizeof(line), k, d->keys, d->nkeys);
	printf("%s:", line);
    }

    dump_line(mr, line, (int)sizeof(line), u, d->columns, d->ncolumns);
    printf("%s\n", line);
    return MPI_SUCCESS;
}
#endif

static int
dump_value(const struct kmr_kv_box kv0,
	   const KMR_KVS *kvi, KMR_KVS *kvo, void *p, const long i)
{
    KMR *mr = kvi->c.mr;
    char line[RECORD_SIZE];

    struct kmr_ntuple *u = (void *)kv0.v.p;
    struct RECORD *d = find_description((enum TABLE)u->marker);

    dump_line(mr, line, (int)sizeof(line), u, d->columns, d->ncolumns);
    //printf("%s [%d]\n", line, mr->rank);
    printf("%s\n", line);
    return MPI_SUCCESS;
}

static void
dump_table(KMR_KVS *kvs, enum TABLE table)
{
    struct RECORD *d = find_description(table);
    struct kmr_option inspect = {.nothreading = 1, .inspect = 1};
    kmr_map_rank_by_rank(kvs, 0, d, inspect, dump_value);
}

#define CREATE_KVS(MR, KEY, PUSHOFF) \
    create_kvs1((MR), (KEY), KMR_KV_OPAQUE, \
		(PUSHOFF), __FILE__, __LINE__, __func__)

static KMR_KVS *
create_kvs1(KMR *mr, enum kmr_kv_field kf, enum kmr_kv_field vf,
	    _Bool pushoff,
	    const char *file, const int line, const char *func)
{
    KMR_KVS *kvs;
    if (pushoff) {
	kvs = kmr_create_pushoff_kvs(mr, kf, KMR_KV_OPAQUE,
				     kmr_noopt, file, line, func);
    } else {
	kvs = kmr_create_kvs7(mr, kf, KMR_KV_OPAQUE,
			      kmr_noopt, file, line, func);
    }
    return kvs;
}

/* Chooses the key by nth of the n-tuple. */

static int
key_by_nth(const struct kmr_kv_box kv0,
	   const KMR_KVS *kvi, KMR_KVS *kvo, void *p, const long i)
{
    int *nth = p;
    struct kmr_ntuple *u = (void *)kv0.v.p;
    struct kmr_ntuple_entry e = kmr_nth_ntuple(u, *nth);
    struct kmr_kv_box kv = {
	.klen = e.len,
	.k.p = e.p,
	.vlen = kv0.vlen,
	.v.p = kv0.v.p
    };
    kmr_add_kv(kvo, kv);
    return MPI_SUCCESS;
}

/* Just selects fields as specified (without calculations). */

static int
select_by_fields(const struct kmr_kv_box kv0,
		 const KMR_KVS *kvi, KMR_KVS *kvo,
		 void *p, const long i)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    struct SELECT *selector = p;
    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u = (void *)kv0.v.p;
    assert(u->marker == (int)selector->input);

    int klen;
    void *kval;
    if (selector->nkeys == 0) {
	klen = 0;
	kval = 0;
    } else if (selector->nkeys == 1) {
	struct kmr_ntuple_entry e = kmr_nth_ntuple(u, selector->keys[0]);
	klen = e.len;
	kval = e.p;
    } else {
	kmr_reset_ntuple(k, selector->nkeys, 0);
	put_columns_by_indexes(mr, k, sizeof(kbuf), u,
			       selector->keys, selector->nkeys);
	klen = kmr_size_ntuple(k);
	kval = k;
    }

    kmr_reset_ntuple(v, selector->ncolumns, selector->output);
    put_columns_by_indexes(mr, v, sizeof(vbuf), u,
			   selector->columns, selector->ncolumns);

    struct kmr_kv_box kv = {
	.klen = klen,
	.k.p = kval,
	.vlen = kmr_size_ntuple(v),
	.v.p = (void *)v
    };
    kmr_add_kv(kvo, kv);

    return MPI_SUCCESS;
}

/* Just joins fields as specified (without calculations). */

static int
join_by_fields(const struct kmr_kv_box kv[], const long n,
	       const KMR_KVS *kvs, KMR_KVS *kvo, void *p)
{
    struct PRODUCT *producer = p;
    struct kmr_ntuple **vv[2];
    long cnt[2];
    kmr_separate_ntuples(kvo->c.mr, kv, n, vv, cnt, producer->inputs, 1);
    kmr_product_ntuples(kvo, vv, cnt, producer->output,
			producer->columns, producer->ncolumns,
			producer->keys, producer->nkeys);

    if (producer->trace_product) {
	fprintf(stderr, "prod %ld %ld\n", cnt[0], cnt[1]); fflush(0);
    }
    if (producer->trace_product_nonempty && cnt[0] != 0 && cnt[1] != 0) {
	fprintf(stderr, "prod %ld %ld\n", cnt[0], cnt[1]); fflush(0);
    }
    assert((!producer->cnt0_zero || cnt[0] == 0)
	   && (!producer->cnt0_one || cnt[0] == 1)
	   && (!producer->cnt0_zero_one || (cnt[0] == 0 || cnt[0] == 1))
	   && (!producer->cnt0_nonzero || cnt[0] != 0));
    assert((!producer->cnt1_zero || cnt[1] == 0)
	   && (!producer->cnt1_one || cnt[1] == 1)
	   && (!producer->cnt1_zero_one || (cnt[1] == 0 || cnt[1] == 1))
	   && (!producer->cnt1_nonzero || cnt[1] != 0));

    free(vv[0]);
    free(vv[1]);
    return MPI_SUCCESS;
}

static KMR_KVS *
JOIN1(KMR_KVS *input0, enum kmr_kv_field outputkf,
      kmr_redfn_t join, void *arg, char *msg, _Bool pushoff)
{
    KMR *mr = input0->c.mr;
    /*char msg[80];*/
    /*snprintf(msg, sizeof(msg), "join (%s)", m);*/

    ptime(input0, 0, 0, 0, 0.0);
    double t0 = wtime();
    KMR_KVS *kvs1 = CREATE_KVS(mr, input0->c.key_data, 0);
    kmr_shuffle(input0, kvs1, kmr_noopt);
    double t1 = wtime();
    ptime(kvs1, 0, "shuffle", msg, (t1 - t0));
    pcount(kvs1, 0, msg, 0);
    KMR_KVS *kvs2 = CREATE_KVS(mr, outputkf, pushoff);
    kmr_reduce(kvs1, kvs2, arg, kmr_noopt, join);
    pcount(kvs2, 0, msg, 1);
    return kvs2;
}

static inline KMR_KVS *
JOIN2(KMR_KVS *input0, KMR_KVS *input1, enum kmr_kv_field outputkf,
      kmr_redfn_t join, void *arg, char *m, _Bool pushoff)
{
    KMR *mr = input0->c.mr;
    char msg[80];
    snprintf(msg, sizeof(msg), "join (%s)", m);

    ptime(input0, input1, 0, 0, 0.0);
    double t0 = wtime();
    assert(input0->c.key_data == input1->c.key_data);
    enum kmr_kv_field inputkf = input0->c.key_data;
    KMR_KVS *kvs0 = CREATE_KVS(mr, inputkf, 0);
    kmr_shuffle(input0, kvs0, kmr_noopt);
    KMR_KVS *kvs1 = CREATE_KVS(mr, inputkf, 0);
    kmr_shuffle(input1, kvs1, kmr_noopt);
    double t1 = wtime();
    ptime(kvs0, kvs1, "shuffle", m, (t1 - t0));
    KMR_KVS *vec[] = {kvs0, kvs1};
    KMR_KVS *kvs2 = CREATE_KVS(mr, inputkf, 0);
    kmr_concatenate_kvs(vec, 2, kvs2, kmr_noopt);
    pcount(kvs2, 0, msg, 0);
    KMR_KVS *kvs3 = CREATE_KVS(mr, outputkf, pushoff);
    kmr_reduce(kvs2, kvs3, arg, kmr_noopt, join);
    pcount(kvs3, 0, msg, 1);
    return kvs3;
}

static inline KMR_KVS *
JOINP(KMR_KVS *input0, KMR_KVS *input1, enum kmr_kv_field outputkf,
      struct PRODUCT *join, char *m, _Bool pushoff)
{
    KMR *mr = input0->c.mr;
    char msg[80];
    snprintf(msg, sizeof(msg), "join (%s)", m);

    ptime(input0, input1, 0, 0, 0.0);
    double t0 = wtime();
    assert(input0->c.key_data == input1->c.key_data);
    enum kmr_kv_field inputkf = input0->c.key_data;
    KMR_KVS *kvs0 = CREATE_KVS(mr, inputkf, 0);
    kmr_shuffle(input0, kvs0, kmr_noopt);
    KMR_KVS *kvs1 = CREATE_KVS(mr, inputkf, 0);
    kmr_shuffle(input1, kvs1, kmr_noopt);
    double t1 = wtime();
    ptime(kvs0, kvs1, "shuffle", m, (t1 - t0));
    KMR_KVS *vec[] = {kvs0, kvs1};
    KMR_KVS *kvs2 = CREATE_KVS(mr, inputkf, 0);
    kmr_concatenate_kvs(vec, 2, kvs2, kmr_noopt);
    pcount(kvs2, 0, msg, 0);
    KMR_KVS *kvs3 = CREATE_KVS(mr, outputkf, pushoff);
    kmr_reduce(kvs2, kvs3, join, kmr_noopt, join_by_fields);
    pcount(kvs3, 0, msg, 1);
    return kvs3;
}

/* ================================================================ */

/* QUERY (Q7)

   VALIDATION-RUN PARAMETERS (NATION1=FRANCE, NATION2=GERMANY)

   [QUERY#0]

   select: shipping = (supp_nation, cust_nation, l_year, volume)
   supp_nation = n1.n_name,
   cust_nation = n2.n_name,
   l_year = extract(year from l_shipdate),
   volume = (l_extendedprice * (1 - l_discount))

   from: n1 = nation, n2 = nation

   where:
   s_suppkey = l_suppkey
   && o_orderkey = l_orderkey
   && c_custkey = o_custkey
   && s_nationkey = n1.n_nationkey
   && c_nationkey = n2.n_nationkey
   && ((n1.n_name = 'FRANCE' && n2.n_name = 'GERMANY')
   || (n1.n_name = 'GERMANY' && n2.n_name = 'FRANCE'))
   && l_shipdate between(date '1995-01-01', date '1996-12-31')

   [QUERY#1]

   select: (supp_nation, cust_nation, l_year, revenue)
   group-by: (supp_nation, cust_nation, l_year)
   revenue = sum(volume)

   from: shipping

   [QUERY#2]

   select: (supp_nation, cust_nation, l_year, revenue)
   order-by: (supp_nation, cust_nation, l_year)

   from: shipping

   [SCHEDULE#0]

   (N+N):
   select: (n1.n_name = 'FRANCE' && n2.n_name = 'GERMANY') and the reverse
   output: NN: {n1.n_nationkey*, n1.n_name, n2.n_nationkey, n2.n_name}

   (S):
   output: S1 = {s_nationkey*, s_suppkey}

   (S1+NN):
   select: s_nationkey = n1.n_nationkey
   output: NNS = {n2.n_nationkey*, s_suppkey*, n1.n_name, n2.n_name}

   (C):
   output: C1 = {c_custkey*, c_nationkey}

   (O):
   output: O1 = {o_custkey*, o_orderkey}

   (C+O):
   select: c_custkey = o_custkey
   output: CO = {o_orderkey*, c_nationkey}

   (L):
   select: (l_shipdate between(date '1995-01-01', date '1996-12-31')
   output: L1 = {l_orderkey*, l_suppkey, year, volume}

   (L+CO):
   select: o_orderkey = l_orderkey
   output: CLO = {c_nationkey*, l_suppkey*, year, volume}

   (CLO+NNS):
   select: c_nationkey = n2.n_nationkey, s_suppkey = l_suppkey
   output: CLNNOS = {n1.n_name*, n2.n_name*, year*, volume}

   (CLNNOS):
   let: revenue = sum(volume)
   output: CLNNOS1 = {n1.n_name*, n2.n_name*, year*, revenue} */

static struct SELECT q7_select_s = {
    .input = TAB_S,
    .output = TAB_Q7_S1,
    /*{s_nationkey*, s_suppkey}*/
    .ncolumns = 2,
    .columns = {3, 0},
    .nkeys = 1,
    .keys = {3}
};

static struct SELECT q7_select_c = {
    .input = TAB_C,
    .output = TAB_Q7_C1,
    /*{c_custkey*, c_nationkey}*/
    .ncolumns = 2,
    .columns = {0, 3},
    .nkeys = 1,
    .keys = {0}
};

static struct SELECT q7_select_o = {
    .input = TAB_O,
    .output = TAB_Q7_O1,
    /*{o_custkey*, o_orderkey}*/
    .ncolumns = 2,
    .columns = {1, 0},
    .nkeys = 1,
    .keys = {1}
};

static struct PRODUCT q7_join_nn_s = {
    .inputs = {TAB_Q7_S1, TAB_Q7_NN},
    .output = TAB_Q7_NNS,
    /*{n2.n_nationkey*, s_suppkey*, n1.n_name, n2.n_name}*/
    .ncolumns = 4,
    .columns = {{2, SND}, {1, FST}, {1, SND}, {3, SND}},
    .nkeys = 2,
    .keys = {{2, SND}, {1, FST}},
    .trace_product = 0
};

static struct PRODUCT q7_join_c_o = {
    .inputs = {TAB_Q7_C1, TAB_Q7_O1},
    .output = TAB_Q7_CO,
    /*{o_orderkey*, c_nationkey}*/
    .ncolumns = 2,
    .columns = {{1, SND}, {1, FST}},
    .nkeys = 1,
    .keys = {{1, SND}},
    .trace_product = 0
};

static struct PRODUCT q7_join_l_co = {
    .inputs = {TAB_Q7_L1, TAB_Q7_CO},
    .output = TAB_Q7_CLO,
    /*{c_nationkey*, l_suppkey*, year, volume}*/
    .ncolumns = 4,
    .columns = {{1, SND}, {1, FST}, {2, FST}, {3, FST}},
    .nkeys = 2,
    .keys = {{1, SND}, {1, FST}},
    .cnt1_one = 1,
    .trace_product_nonempty = 0
};

struct PRODUCT q7_join_clo_nns = {
    .inputs = {TAB_Q7_CLO, TAB_Q7_NNS},
    .output = TAB_Q7_CLNNOS0,
    /*{n1.n_name*, n2.n_name*, year*, volume}*/
    .ncolumns = 4,
    .columns = {{2, SND}, {3, SND}, {2, FST}, {3, FST}},
    .nkeys = 0,
    .keys = {{0, FST}},
    //.cnt0_nonzero = 1,
    .cnt1_zero_one = 1,
    .trace_product_nonempty = 0
};

static int
q7_select_nations(const struct kmr_kv_box kv0, const KMR_KVS *kvi,
		  KMR_KVS *kvo, void *p, const long i)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_N;
    enum TABLE output = TAB_Q7_N1;
    /*{n_nationkey, n_name}*/
    struct RECORD *d = find_description(input);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u = (void *)kv0.v.p;
    struct kmr_ntuple_entry name = column_by_name(u, d, "n_name");

    char *s0 = "FRANCE";
    char *s1 = "GERMANY";
    if (strncmp((char *)name.p, s0, strlen(s0)) == 0
	|| strncmp((char *)name.p, s1, strlen(s1)) == 0) {
	char *cols[] = {"n_nationkey", "n_name"};

	kmr_reset_ntuple(k, 0, 0);
	kmr_reset_ntuple(v, 2, output);
	put_columns_by_names(mr, v, sizeof(vbuf), u, d, cols, 2);
	add_record(kvo, k, v);
    }

    return MPI_SUCCESS;
}

static int
q7_pair_names(const struct kmr_kv_box kv[], const long n,
	      const KMR_KVS *kvs, KMR_KVS *kvo, void *p)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_N;
    enum TABLE output = TAB_Q7_NN;
    /*{n1.n_nationkey* n1.n_nationkey, n1.n_name, n2.n_nationkey, n2.n_name}*/
    struct RECORD *d = find_description(input);
    char *cols[] = {"n_nationkey", "n_name"};

    KMR *mr = kvo->c.mr;
    assert(n == 2);
    struct kmr_ntuple *u0 = (void *)kv[0].v.p;
    struct kmr_ntuple *u1 = (void *)kv[1].v.p;

    {
	struct kmr_ntuple_entry key0 = column_by_name(u0, d, "n_nationkey");

	kmr_reset_ntuple(k, 1, 0);
	kmr_put_ntuple_entry(mr, k, (int)sizeof(kbuf), key0);
	kmr_reset_ntuple(v, 4, output);
	put_columns_by_names(mr, v, sizeof(vbuf), u0, d, cols, 2);
	put_columns_by_names(mr, v, sizeof(vbuf), u1, d, cols, 2);
	add_record(kvo, k, v);
    }

    {
	struct kmr_ntuple_entry key1 = column_by_name(u1, d, "n_nationkey");

	kmr_reset_ntuple(k, 1, 0);
	kmr_put_ntuple_entry(mr, k, (int)sizeof(kbuf), key1);
	kmr_reset_ntuple(v, 4, output);
	put_columns_by_names(mr, v, sizeof(vbuf), u1, d, cols, 2);
	put_columns_by_names(mr, v, sizeof(vbuf), u0, d, cols, 2);
	add_record(kvo, k, v);
    }

    return MPI_SUCCESS;
}

/* (l_shipdate between(date '1995-01-01', date '1996-12-31'). */

static int
q7_select_by_date(const struct kmr_kv_box kv0,
		  const KMR_KVS *kvi, KMR_KVS *kvo,
		  void *p, const long i)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_L;
    enum TABLE output = TAB_Q7_L1;
    /*{l_orderkey*, l_suppkey, year, volume}*/
    struct RECORD *d = find_description(input);
    struct RECORD *dx = find_description(output);

    time_t *dt = p;
    KMR *mr = kvo->c.mr;

    struct kmr_ntuple *u = (void *)kv0.v.p;
    assert(u->marker == (int)input);

    time_t shipdate = get_date_column(u, d, "l_shipdate");
    if (dt[0] <= shipdate && shipdate <= dt[1]) {
	struct kmr_ntuple_entry orderkey = column_by_name(u, d, "l_orderkey");
	struct kmr_ntuple_entry suppkey = column_by_name(u, d, "l_suppkey");

	time_t year = year_value(shipdate);
	long iyear = year;
	double extendedprice = get_real_column(u, d, "l_extendedprice");
	double discount = get_real_column(u, d, "l_discount");
	double volume = (extendedprice * (1 - discount));

	kmr_reset_ntuple(k, 1, 0);
	kmr_put_ntuple_entry(mr, k, (int)sizeof(kbuf), orderkey);
	kmr_reset_ntuple(v, dx->ncolumns, output);
	kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), orderkey);
	kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), suppkey);
	kmr_put_ntuple(mr, v, (int)sizeof(vbuf), &iyear, sizeof(iyear));
	kmr_put_ntuple(mr, v, (int)sizeof(vbuf), &volume, sizeof(volume));
	add_record(kvo, k, v);
    }

    return MPI_SUCCESS;
}

static int
q7_make_sort_keys(const struct kmr_kv_box kv0,
		  const KMR_KVS *kvi, KMR_KVS *kvo,
		  void *p, const long i)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;

    enum TABLE input = TAB_Q7_CLNNOS0;
    /*enum TABLE output = TAB_Q7_CLNNOS1;*/
    struct RECORD *d = find_description(input);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u = (void *)kv0.v.p;
    assert(u->marker == (int)input);

    struct kmr_ntuple_entry name1 = kmr_nth_ntuple(u, 0);
    struct kmr_ntuple_entry name2 = kmr_nth_ntuple(u, 1);
    time_t year = get_date_column_by_index(u, d->columns, 2);

    char nbuf[NAME_SIZE];
    assert((name1.len + name2.len) <= NAME_SIZE);
    memset(nbuf, 0, sizeof(nbuf));
    memcpy(&nbuf[0], name1.p, name1.len);
    memcpy(&nbuf[name1.len], name2.p, name2.len);
    uint64_t beyear = htonll_((uint64_t)(year));

    kmr_reset_ntuple(k, 2, 0);
    kmr_put_ntuple(mr, k, (int)sizeof(kbuf), nbuf, NAME_SIZE);
    kmr_put_ntuple(mr, k, (int)sizeof(kbuf), &beyear, sizeof(beyear));
    add_record(kvo, k, (void *)kv0.v.p);

    return MPI_SUCCESS;
}

static int
q7_sum_volume(const struct kmr_kv_box kv[], const long n,
	      const KMR_KVS *kvs, KMR_KVS *kvo, void *p)
{
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_Q7_CLNNOS1;
    enum TABLE output = TAB_Q7_REVENUE;
    struct RECORD *d = find_description(input);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u0 = (void *)kv[0].v.p;
    assert(u0->marker == TAB_Q7_CLNNOS0);

    double revenue;
    revenue = 0.0;
    for (long i = 0; i < n; i++) {
	struct kmr_ntuple *u = (void *)kv[i].v.p;
	double volume = get_real_column_by_index(u, d->columns, 3);
	revenue += volume;
    }

    int cols[] = {0, 1, 2};

    assert(d->nkeys >= 2);
    kmr_reset_ntuple(v, 4, output);
    put_columns_by_indexes(mr, v, sizeof(vbuf), u0, cols, 3);
    kmr_put_ntuple(mr, v, (int)sizeof(vbuf), &revenue, sizeof(revenue));
    add_record(kvo, (void *)kv[0].k.p, v);

    return MPI_SUCCESS;
}

static KMR_KVS *
q7(KMR *mr, struct RUN *run)
{
    _Bool pushoff = ((run->pushoff == 0) ? 0 : 1);
    struct kmr_option rankzero = {.rank_zero = 1};

    if (pushoff) {
	if (mr->rank == 0) {printf("q7 (with push-off)...\n"); fflush(0);}
    } else {
	if (mr->rank == 0) {printf("q7...\n"); fflush(0);}
    }

    /*(N+N)*/

    if (mr->rank == 0) {printf("q7 (n+n)...\n"); fflush(0);}

    if (run->load_tables_in_advance) {
	/*empty*/
    } else {
	KMR_KVS *n_ = kmr_create_kvs(mr, KMR_KV_OPAQUE, KMR_KV_OPAQUE);
	scan_table_files(n_, TAB_N, 0, 0, run);
    }

    KMR_KVS *n1 = CREATE_KVS(mr, KMR_KV_OPAQUE, 0);
    kmr_map(N0, n1, 0, kmr_noopt, q7_select_nations);
    KMR_KVS *n2 = CREATE_KVS(mr, KMR_KV_OPAQUE, 0);
    kmr_replicate(n1, n2, rankzero);
    pcount(n2, 0, "join (n+n)", 0);
    KMR_KVS *nn = CREATE_KVS(mr, KMR_KV_OPAQUE, 0);
    kmr_reduce(n2, nn, 0, kmr_noopt, q7_pair_names);
    pcount(nn, 0, "join (n+n)", 1);

    if (mr->rank == 0) {printf("q7 (s)...\n"); fflush(0);}

    KMR_KVS *s1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(S0, s1, &q7_select_s, kmr_noopt, select_by_fields);
    } else {
	scan_table_files(s1, TAB_S, select_by_fields, &q7_select_s, run);
    }

    if (mr->rank == 0) {printf("q7 (nn+s)...\n"); fflush(0);}

    KMR_KVS *nns = JOINP(s1, nn, KMR_KV_OPAQUE,
			 &q7_join_nn_s, "nn+s", pushoff);

    //dump_table(nns, TAB_Q7_NNS);

    if (mr->rank == 0) {printf("q7 (c)...\n"); fflush(0);}

    KMR_KVS *c1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(C0, c1, &q7_select_c, kmr_noopt, select_by_fields);
    } else {
	scan_table_files(c1, TAB_C, select_by_fields, &q7_select_c, run);
    }

    if (mr->rank == 0) {printf("q7 (o)...\n"); fflush(0);}

    KMR_KVS *o1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(O0, o1, &q7_select_o, kmr_noopt, select_by_fields);
    } else {
	scan_table_files(o1, TAB_O, select_by_fields, &q7_select_o, run);
    }

    if (mr->rank == 0) {printf("q7 (c+o)...\n"); fflush(0);}

    KMR_KVS *co = JOINP(c1, o1, KMR_KV_OPAQUE,
			&q7_join_c_o, "c+o", pushoff);

    if (mr->rank == 0) {printf("q7 (l)...\n"); fflush(0);}

    time_t tv[2];
    tv[0] = decode_date("1995-01-01");
    tv[1] = decode_date("1996-12-31");
    assert((tv[0] != (time_t)-1) && (tv[1] != (time_t)-1));
    KMR_KVS *l1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(L0, l1, tv, kmr_noopt, q7_select_by_date);
    } else {
	scan_table_files(l1, TAB_L, q7_select_by_date, tv, run);
    }

    //dump_table(l1, TAB_Q7_L1);

    if (mr->rank == 0) {printf("q7 (co+l)...\n"); fflush(0);}

    KMR_KVS *clo = JOINP(l1, co, KMR_KV_OPAQUE,
			 &q7_join_l_co, "co+l", pushoff);

    //dump_table(clo, TAB_Q7_CLO);

    if (mr->rank == 0) {printf("q7 (clo+nns)...\n"); fflush(0);}

    KMR_KVS *clnnos2 = JOINP(clo, nns, KMR_KV_OPAQUE,
			     &q7_join_clo_nns, "clo+nns", 0);
    KMR_KVS *clnnos3 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    kmr_map(clnnos2, clnnos3, 0, kmr_noopt, q7_make_sort_keys);

    KMR_KVS *revenue0 = JOIN1(clnnos3, KMR_KV_OPAQUE,
			      q7_sum_volume, 0, "sum(volume)", 0);
    KMR_KVS *revenue1 = CREATE_KVS(mr, KMR_KV_OPAQUE, 0);
    kmr_sort(revenue0, revenue1, kmr_noopt);

    return revenue1;
}

/* ================================================================ */

/* QUERY (Q9)

   VALIDATION-RUN PARAMETERS (COLOR=green)

   [QUERY#0]

   select: (nation, o_year, amount)
   nation = n_name
   o_year = extract(year from o_orderdate)
   amount = (l_extendedprice*(1-l_discount)-ps_supplycost*l_quantity)

   where:
   s_suppkey = l_suppkey
   && ps_suppkey = l_suppkey
   && ps_partkey = l_partkey
   && p_partkey = l_partkey
   && o_orderkey = l_orderkey
   && s_nationkey = n_nationkey
   && p_name = '%green%'

   [QUERY#1]

   select: (nation, o_year, sum_profit)
   o_year = extract(year, o_orderdate)
   sum_profit = sum(amount)
   group-by: (nation, o_year)

   [QUERY#2]

   select: (nation, o_year, sum_profit)
   order-by: (nation, o_year descending)

   (P+H):
   select: ps_partkey* = p_partkey* (= l_partkey) && (p_name like '%%')
   output: PH = {ps_partkey, ps_suppkey*, ps_supplycost}

   (S+N):
   select: s_nationkey = n_nationkey*
   output: SN = {n_name, s_suppkey*}

   ((P+H)+(S+N)):
   select: s_suppkey = ps_suppkey (= l_suppkey)
   output: PHSN = {n_name, ps_partkey*, ps_suppkey*, ps_supplycost}

   (L+O):
   select: o_orderkey* = l_orderkey*
   output: LO = {l_discount, l_extendedprice, l_partkey*, l_quantity,
   l_suppkey*, o_orderdate}

   (((P+H)+(S+N))+(L+O)):
   select: (ps_partkey, ps_suppkey) = (l_partkey, l_suppkey)
   let: amount = (l_extendedprice*(1-l_discount)-ps_supplycost*l_quantity)
   output: LHNOPS = {n_name, o_orderdate, amount} */

static struct PRODUCT q9_join_p_h = {
    .inputs = {TAB_P, TAB_H},
    .output = TAB_Q9_PH,
    /*{ps_partkey, ps_suppkey*, ps_supplycost}*/
    .ncolumns = 3,
    .columns = {{0, SND}, {1, SND}, {3, SND}},
    .nkeys = 1,
    .keys = {{1, SND}},
    /*assert(cnt[0] == 0 || (cnt[0] == 1 && cnt[1] != 0));*/
    .cnt0_zero_one = 1,
    .trace_product = 0
};

static struct PRODUCT q9_join_s_n = {
    .inputs = {TAB_S, TAB_N},
    .output = TAB_Q9_NS,
    /*{n_name, s_suppkey*}*/
    .ncolumns = 2,
    .columns = {{1, SND}, {0, FST}},
    .nkeys = 1,
    .keys = {{0, FST}},
    /*assert(cnt[0] != 0 && cnt[1] == 1);*/
    .trace_product = 0
};

static struct PRODUCT q9_join_hp_ns = {
    .inputs = {TAB_Q9_PH, TAB_Q9_NS},
    .output = TAB_Q9_PHSN,
    /*{n_name, ps_partkey*, ps_suppkey*, ps_supplycost}*/
    .ncolumns = 4,
    .columns = {{0, SND}, {0, FST}, {1, FST}, {2, FST}},
    .nkeys = 2,
    .keys = {{0, FST}, {1, FST}},
    /*assert(cnt[0] == 0 || (cnt[0] != 0 && cnt[1] == 1));*/
    .trace_product = 0
};

static struct PRODUCT q9_join_l_o = {
    .inputs = {TAB_L, TAB_O},
    .output = TAB_Q9_LO,
    /*{l_discount, l_extendedprice, l_partkey*,
      l_quantity, l_suppkey*, o_orderdate}*/
    .ncolumns = 6,
    .columns = {{6, FST}, {5, FST}, {1, FST}, {4, FST}, {2, FST}, {4, SND}},
    .nkeys = 2,
    .keys = {{1, FST}, {2, FST}},
    /*assert(cnt[0] != 0 && cnt[1] == 1);*/
    .trace_product = 0
};

static struct PRODUCT q9_join_hnps_lo = {
    .inputs = {TAB_Q9_PHSN, TAB_Q9_LO},
    .output = TAB_Q9_PHSNLO,
    /*{l_discount, l_extendedprice, l_quantity,
      n_name, o_orderdate*, ps_supplycost}*/
    .ncolumns = 6,
    .columns = {{0, SND}, {1, SND}, {3, SND}, {0, FST}, {5, SND}, {3, FST}},
    .nkeys = 1,
    .keys = {{5, SND}},
    /*assert(cnt[0] == 0 || cnt[0] == 1);*/
    .cnt0_zero_one = 1,
    .trace_product = 0
};

static int
q9_select_by_name(const struct kmr_kv_box kv0,
		  const KMR_KVS *kvi, KMR_KVS *kvo,
		  void *p, const long i)
{
    enum TABLE input = TAB_P;
    struct RECORD *d0 = find_description(input);
    assert(d0->columns[1].field == F_TEXT);

    struct kmr_ntuple *u = (void *)kv0.v.p;
    struct kmr_ntuple_entry e = kmr_nth_ntuple(u, 1);
    char *pos = strnstr_(e.p, "green", (size_t)e.len);
    if (pos != 0) {
	kmr_add_kv(kvo, kv0);
    }
    return MPI_SUCCESS;
}

static int
q9_calculate_amount(const struct kmr_kv_box kv0,
		    const KMR_KVS *kvi, KMR_KVS *kvo,
		    void *p, const long i)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE inputoutput = TAB_Q9_PHSNLO;
    struct RECORD *d = find_description(inputoutput);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u = (void *)kv0.v.p;
    double l_discount = get_real_column_by_index(u, d->columns, 0);
    double l_extendedprice = get_real_column_by_index(u, d->columns, 1);
    double l_quantity = get_real_column_by_index(u, d->columns, 2);
    struct kmr_ntuple_entry n_name = kmr_nth_ntuple(u, 3);
    time_t o_orderdate = get_date_column_by_index(u, d->columns, 4);
    double l_supplycost = get_real_column_by_index(u, d->columns, 5);

    time_t year = year_value(o_orderdate);

    double amount = ((l_extendedprice * (1 - l_discount))
		     - (l_supplycost * l_quantity));

    {
	char nbuf[NAME_SIZE];
	assert(n_name.len <= NAME_SIZE);
	memset(nbuf, 0, sizeof(nbuf));
	memcpy(nbuf, n_name.p, n_name.len);
	uint64_t beyear = htonll_((uint64_t)(-year));

	kmr_reset_ntuple(k, 2, 0);
	kmr_put_ntuple(mr, k, (int)sizeof(kbuf), nbuf, NAME_SIZE);
	kmr_put_ntuple(mr, k, (int)sizeof(kbuf), &beyear, sizeof(beyear));

	long iyear = year;

	kmr_reset_ntuple(v, 3, TAB_Q9_AMOUNT);
	kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), n_name);
	kmr_put_ntuple(mr, v, (int)sizeof(vbuf), &iyear, sizeof(iyear));
	kmr_put_ntuple(mr, v, (int)sizeof(vbuf), &amount, sizeof(amount));
    }
    add_record(kvo, k, v);

    return MPI_SUCCESS;
}

static int
q9_sum_amount(const struct kmr_kv_box kv[], const long n,
	      const KMR_KVS *kvs, KMR_KVS *kvo, void *p)
{
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE inputoutput = TAB_Q9_AMOUNT;
    struct RECORD *d = find_description(inputoutput);

    KMR *mr = kvo->c.mr;

    double sum;
    sum = 0.0;
    for (long i = 0; i < n; i++) {
	struct kmr_ntuple *u = (void *)kv[i].v.p;
	double amount = get_real_column_by_index(u, d->columns, 2);
	sum += amount;
    }

    {
	struct kmr_ntuple *u = (void *)kv[0].v.p;
	struct kmr_ntuple_entry name = kmr_nth_ntuple(u, 0);
	struct kmr_ntuple_entry year = kmr_nth_ntuple(u, 1);

	kmr_reset_ntuple(v, 3, inputoutput);
	kmr_put_ntuple(mr, v, (int)sizeof(vbuf), name.p, name.len);
	kmr_put_ntuple(mr, v, (int)sizeof(vbuf), year.p, year.len);
	kmr_put_ntuple(mr, v, (int)sizeof(vbuf), &sum, sizeof(sum));
    }

    struct kmr_kv_box nkv = {
	.klen = kv[0].klen,
	.k = kv[0].k,
	.vlen = kmr_size_ntuple(v),
	.v.p = (void *)v
    };
    kmr_add_kv(kvo, nkv);

    return MPI_SUCCESS;
}

static KMR_KVS *
q9(KMR *mr, struct RUN *run)
{
    _Bool pushoff = ((run->pushoff == 0) ? 0 : 1);
    int nth;

    if (pushoff) {
	if (mr->rank == 0) {printf("q9 (with push-off)...\n"); fflush(0);}
    } else {
	if (mr->rank == 0) {printf("q9...\n"); fflush(0);}
    }

    /*(P+H)*/

    if (mr->rank == 0) {printf("q9 (p+ps)...\n"); fflush(0);}

    if (run->load_tables_in_advance) {
	/*empty*/
    } else {
	KMR_KVS *h0 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
	scan_table_files(h0, TAB_H, 0, 0, run);
    }

    KMR_KVS *p1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(P0, p1, 0, kmr_noopt, q9_select_by_name);
    } else {
	scan_table_files(p1, TAB_P, q9_select_by_name, 0, run);
    }

    KMR_KVS *pps2 = JOINP(p1, H0, KMR_KV_OPAQUE,
			  &q9_join_p_h, "p+ps", pushoff);

    /*(S+N)*/

    if (mr->rank == 0) {printf("q9 (s+n)...\n"); fflush(0);}

    if (run->load_tables_in_advance) {
	/*empty*/
    } else {
	KMR_KVS *n0 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
	scan_table_files(n0, TAB_N, 0, 0, run);
    }

    KMR_KVS *s0x = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    nth = 3; /*s_nationkey*/
    if (run->load_tables_in_advance) {
	kmr_map(S0, s0x, &nth, kmr_noopt, key_by_nth);
    } else {
	scan_table_files(s0x, TAB_S, key_by_nth, &nth, run);
    }

    KMR_KVS *sn2 = JOINP(s0x, N0, KMR_KV_OPAQUE,
			 &q9_join_s_n, "n+s", pushoff);

    /*((P+H)+(S+N))*/

    if (mr->rank == 0) {printf("q9 (p+ps)+(s+n)...\n"); fflush(0);}

    KMR_KVS *ppssn2 = JOINP(pps2, sn2, KMR_KV_OPAQUE,
			    &q9_join_hp_ns, "ns+pps", pushoff);

    /*(L+O)*/

    if (mr->rank == 0) {printf("q9 (l+o)...\n"); fflush(0);}

    KMR_KVS *l1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    nth = 0; /*l_orderkey*/
    if (run->load_tables_in_advance) {
	kmr_map(L0, l1, &nth, kmr_noopt, key_by_nth);
    } else {
	scan_table_files(l1, TAB_L, key_by_nth, &nth, run);
    }

    KMR_KVS *o1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    nth = 0; /*o_orderkey*/
    if (run->load_tables_in_advance) {
	kmr_map(O0, o1, &nth, kmr_noopt, key_by_nth);
    } else {
	scan_table_files(o1, TAB_O, key_by_nth, &nth, run);
    }

    KMR_KVS *lo2 = JOINP(l1, o1, KMR_KV_OPAQUE,
			 &q9_join_l_o, "l+o", pushoff);

    /*(((P+H)+(S+N))+(L+O))*/

    if (mr->rank == 0) {printf("q9 (((p+ps)+(s+n))+(l+o))...\n"); fflush(0);}

    KMR_KVS *ppssnlo2 = JOINP(ppssn2, lo2, KMR_KV_OPAQUE,
			      &q9_join_hnps_lo, "lo+nppss", 0);
    KMR_KVS *ppssnlo3 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    kmr_map(ppssnlo2, ppssnlo3, 0, kmr_noopt, q9_calculate_amount);

    pcount(ppssnlo3, 0, "q9_calculate_amount", 1);

    KMR_KVS *ppssnlo5 = JOIN1(ppssnlo3, KMR_KV_OPAQUE,
			      q9_sum_amount, 0, "sum(amount)", 0);

    KMR_KVS *ppssnlo6 = CREATE_KVS(mr, KMR_KV_OPAQUE, 0);
    kmr_sort(ppssnlo5, ppssnlo6, kmr_noopt);

    return ppssnlo6;
}

/* ================================================================ */

/* QUERY (Q10)

   VALIDATION-RUN PARAMETERS (DATE=1993-10-01)

   [QUERY#0]

   select: (c_custkey, c_name, revenue, c_acctbal,
   n_name, c_address, c_phone, c_comment)
   revenue = sum(l_extendedprice * (1 - l_discount))

   where:
   c_custkey = o_custkey
   && l_orderkey = o_orderkey
   && o_orderdate >= date '1993-10-01'
   && o_orderdate < date '1993-10-01' + interval '3' month
   && l_returnflag = 'R'
   && c_nationkey = n_nationkey

   group-by: (c_custkey, c_name, c_acctbal, c_phone,
   n_name, c_address, c_comment)

   [QUERY#1]

   select: (c_custkey, c_name, revenue, c_acctbal,
   n_name, c_address, c_phone, c_comment)

   order-by: (revenue descending)
   where: rownum <= 20;

   [SCHEDULE]

   (L):
   select: l_returnflag = 'R'
   let: volume = (l_extendedprice * (1 - l_discount))
   output: L1 = {l_orderkey*, volume}

   (O):
   select: '1993-10-01' <= o_orderdate < '1994-01-01'
   output: O1 = {o_orderkey*, o_custkey}

   (L1+O1):
   select: l_orderkey+ = o_orderkey+
   output: LO = {o_custkey*, volume}

   (C):
   output: C1 = {c_nationkey*, c_custkey, c_name, c_acctbal,
   c_phone, c_address, c_comment}

   (N):
   output: N1 = {n_nationkey*, n_name}

   (C+N):
   select: c_nationkey = n_nationkey+
   output: CN = {c_custkey*, c_name, c_acctbal, c_phone,
   n_name, c_address, c_comment*}

   (CN+LO):
   select: c_custkey+ = o_custkey
   output: CLNO0 = {c_custkey*, c_name*, c_acctbal*, c_phone*,
   n_name*, c_address*, c_comment*, volume}

   (CLNO1):
   let: revenue = sum(volume)
   output: CLNO1 = {-revenue*; c_custkey, c_name, revenue,
   c_acctbal, n_name, c_address, c_phone, c_comment} */

static struct SELECT q10_select_c = {
    .input = TAB_C,
    .output = TAB_Q10_C1,
    /*{c_nationkey*, c_custkey, c_name, c_acctbal,
      c_phone, c_address, c_comment}*/
    .ncolumns = 7,
    .columns = {3, 0, 1, 5, 4, 2, 7},
    .nkeys = 1,
    .keys = {3}
};

static struct SELECT q10_select_n = {
    .input = TAB_N,
    .output = TAB_Q10_N1,
    /*{n_nationkey*, n_name}*/
    .ncolumns = 2,
    .columns = {0, 1},
    .nkeys = 1,
    .keys = {0}
};

static struct PRODUCT q10_join_l_o = {
    .inputs = {TAB_Q10_L1, TAB_Q10_O1},
    .output = TAB_Q10_LO,
    /*{o_custkey*, volume}*/
    .ncolumns = 2,
    .columns = {{1, SND}, {1, FST}},
    .nkeys = 1,
    .keys = {{1, SND}},
    .trace_product = 0
};

static struct PRODUCT q10_join_c_n = {
    .inputs = {TAB_Q10_C1, TAB_Q10_N1},
    .output = TAB_Q10_CN,
    /*{c_custkey*, c_name, c_acctbal, c_phone,
      n_name, c_address, c_comment}*/
    .ncolumns = 7,
    .columns = {{1, FST}, {2, FST}, {3, FST}, {4, FST},
		{1, SND}, {5, FST}, {6, FST}},
    .nkeys = 1,
    .keys = {{1, FST}},
    .trace_product = 0
};

static struct PRODUCT q10_join_cn_lo = {
    .inputs = {TAB_Q10_CN, TAB_Q10_LO},
    .output = TAB_Q10_CLNO0,
    /*{c_custkey*, c_name*, c_acctbal*, c_phone*,
      n_name*, c_address*, c_comment*, volume}*/
    .ncolumns = 8,
    .columns = {{0, FST}, {1, FST}, {2, FST}, {3, FST},
		{4, FST}, {5, FST}, {6, FST}, {1, SND}},
    .nkeys = 7,
    .keys = {{0, FST}, {1, FST}, {2, FST}, {3, FST},
	     {4, FST}, {5, FST}, {6, FST}},
    .trace_product = 0
};

static int
q10_select_by_flag(const struct kmr_kv_box kv0, const KMR_KVS *kvi,
		   KMR_KVS *kvo, void *p, const long i)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_L;
    enum TABLE output = TAB_Q10_L1;
    struct RECORD *d = find_description(input);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u = (void *)kv0.v.p;
    struct kmr_ntuple_entry returnflag = column_by_name(u, d, "l_returnflag");
    char *s0 = "R";
    if (strncmp((char *)returnflag.p, s0, 1) == 0) {
	double extendedprice = get_real_column(u, d, "l_extendedprice");
	double discount = get_real_column(u, d, "l_discount");
	double volume = (extendedprice * (1 - discount));
	struct kmr_ntuple_entry orderkey = column_by_name(u, d, "l_orderkey");

	kmr_reset_ntuple(k, 1, 0);
	kmr_put_ntuple_entry(mr, k, (int)sizeof(kbuf), orderkey);
	kmr_reset_ntuple(v, 2, output);
	kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), orderkey);
	kmr_put_ntuple(mr, v, (int)sizeof(vbuf), &volume, sizeof(volume));
	add_record(kvo, k, v);
    }

    return MPI_SUCCESS;
}

static int
q10_select_by_date(const struct kmr_kv_box kv0, const KMR_KVS *kvi,
		   KMR_KVS *kvo, void *p, const long i)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_O;
    enum TABLE output = TAB_Q10_O1;
    struct RECORD *d = find_description(input);

    time_t *tv = p;
    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u = (void *)kv0.v.p;
    assert(u->marker == (int)input);

    time_t orderdate = get_date_column(u, d, "o_orderdate");
    if (tv[0] <= orderdate && orderdate <= tv[1]) {
	struct kmr_ntuple_entry orderkey = column_by_name(u, d, "o_orderkey");

	char *cols[] = {"o_orderkey", "o_custkey"};

	kmr_reset_ntuple(k, 1, 0);
	kmr_put_ntuple_entry(mr, k, (int)sizeof(kbuf), orderkey);
	kmr_reset_ntuple(v, 2, output);
	put_columns_by_names(mr, v, sizeof(vbuf), u, d, cols, 2);
	add_record(kvo, k, v);
    }
    return MPI_SUCCESS;
}

static int
q10_sum_volume(const struct kmr_kv_box kv[], const long n,
	       const KMR_KVS *kvs, KMR_KVS *kvo, void *p)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_Q10_CLNO0;
    enum TABLE output = TAB_Q10_CLNO1;
    struct RECORD *d = find_description(input);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u0 = (void *)kv[0].v.p;
    assert(u0->marker == (int)input);

    double revenue;
    revenue = 0.0;
    for (long i = 0; i < n; i++) {
	struct kmr_ntuple *u = (void *)kv[i].v.p;
	double volume = get_real_column_by_index(u, d->columns, 7);
	revenue += volume;
    }

    char *cols0[] = {"c_custkey", "c_name"};
    char *cols1[] = {"c_acctbal", "n_name", "c_address",
		     "c_phone", "c_comment"};

    double negrevenue = -revenue;

    kmr_reset_ntuple(k, 1, 0);
    kmr_put_ntuple(mr, k, (int)sizeof(kbuf), &negrevenue, sizeof(double));
    kmr_reset_ntuple(v, 8, output);
    put_columns_by_names(mr, v, sizeof(vbuf), u0, d, cols0, 2);
    kmr_put_ntuple(mr, v, (int)sizeof(vbuf), &revenue, sizeof(revenue));
    put_columns_by_names(mr, v, sizeof(vbuf), u0, d, cols1, 5);
    add_record(kvo, k, v);

    return MPI_SUCCESS;
}

static KMR_KVS *
q10(KMR *mr, struct RUN *run)
{
    _Bool pushoff = ((run->pushoff == 0) ? 0 : 1);

    if (pushoff) {
	if (mr->rank == 0) {printf("q10 (with push-off)...\n"); fflush(0);}
    } else {
	if (mr->rank == 0) {printf("q10...\n"); fflush(0);}
    }

    /*(L)*/

    if (mr->rank == 0) {printf("q10 (l)...\n"); fflush(0);}

    KMR_KVS *l1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(L0, l1, 0, kmr_noopt, q10_select_by_flag);
    } else {
	scan_table_files(l1, TAB_L, q10_select_by_flag, 0, run);
    }

    /*(O)*/

    if (mr->rank == 0) {printf("q10 (o)...\n"); fflush(0);}

    time_t tv[2];
    tv[0] = decode_date("1993-10-01");
    assert(tv[0] != (time_t)-1);
    tv[1] = decode_date("1994-01-01");
    assert(tv[1] != (time_t)-1);
    KMR_KVS *o1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(O0, o1, tv, kmr_noopt, q10_select_by_date);
    } else {
	scan_table_files(o1, TAB_O, q10_select_by_date, tv, run);
    }

    /*(L1+O1)*/

    KMR_KVS *lo = JOINP(l1, o1, KMR_KV_OPAQUE,
			&q10_join_l_o, "l+o", pushoff);

    /*(C+N)*/

    if (mr->rank == 0) {printf("q10 (c)...\n"); fflush(0);}

    KMR_KVS *c1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(C0, c1, &q10_select_c, kmr_noopt, select_by_fields);
    } else {
	scan_table_files(c1, TAB_C, select_by_fields, &q10_select_c, run);
    }

    if (mr->rank == 0) {printf("q10 (n)...\n"); fflush(0);}

    KMR_KVS *n1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(N0, n1, &q10_select_n, kmr_noopt, select_by_fields);
    } else {
	scan_table_files(n1, TAB_N, select_by_fields, &q10_select_n, run);
    }

    if (mr->rank == 0) {printf("q10 (c+n)...\n"); fflush(0);}

    KMR_KVS *cn = JOINP(c1, n1, KMR_KV_OPAQUE,
			&q10_join_c_n, "c+n", pushoff);

    /*(CN+LO)*/

    if (mr->rank == 0) {printf("q10 (cn+lo)...\n"); fflush(0);}

    KMR_KVS *clno0 = JOINP(cn, lo, KMR_KV_OPAQUE,
			   &q10_join_cn_lo, "cn+lo", pushoff);

    if (mr->rank == 0) {printf("q10 (sum(volume))...\n"); fflush(0);}

    KMR_KVS *clno1 = JOIN1(clno0, KMR_KV_FLOAT8,
			   q10_sum_volume, 0, "sum(volume)", 0);

    //phisto(clno1, "sum(volumne)");

    KMR_KVS *clno2 = CREATE_KVS(mr, KMR_KV_FLOAT8, 0);
    kmr_sort(clno1, clno2, kmr_noopt);

    pcount(clno2, 0, "sort", 1);

    KMR_KVS *clno3 = CREATE_KVS(mr, KMR_KV_FLOAT8, 0);
    kmr_choose_first_part(clno2, clno3, 20, kmr_noopt);

    pcount(clno3, 0, "choose", 1);

    return clno3;
}

/* ================================================================ */

/* QUERY (Q13)

   VALIDATION-RUN PARAMETERS (WORD1=special, WORD2=requests)

   [QUERY#0]

   select: #left-outer-join (customer, orders)
   on: c_custkey = o_custkey
   && o_comment not like '%special%requests%'

   [QUERY#1]

   select: c_orders = (c_custkey, count(o_orderkey))
   group-by: (c_custkey)

   [QUERY#2]

   select: (c_count, custdist=count(*))
   from: c_orders
   group-by: (c_count)

   order-by: (c_count descending, custdist descending)

   [SCHEDULE#0]

   (O1):
   select: o_comment = '%special%requests%'
   output: O1 = {o_custkey*, o_orderkey}

   (C+O1):
   select: (c_custkey* = o_custkey)
   let: q13_count = #count(o_orderkey)
   output: CO0 = {q13_count*, c_custkey}

   (CO0):
   select: (q13_count)
   let: q13_custdist = #count(c_custkey)
   output: CO1 = {q13_custdist* (descending), q13_count* (descending)} */

static int
q13_select_by_string(const struct kmr_kv_box kv0,
		     const KMR_KVS *kvi, KMR_KVS *kvo,
		     void *p, const long i)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_O;
    enum TABLE output = TAB_Q13_O1;
    struct RECORD *d = find_description(input);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u = (void *)kv0.v.p;

    assert(d->columns[8].field == F_TEXT);
    struct kmr_ntuple_entry comment = kmr_nth_ntuple(u, 8);
    char *p0 = (comment.p);
    char *end = &(p0[comment.len]);
    char *p1 = strnstr_(p0, "special", (size_t)(end - p0));
    char *p2 = ((p1 == 0) ? 0 : strnstr_(p1, "requests", (size_t)(end - p1)));

    if (!(p1 != 0 && p2 != 0)) {
	struct kmr_ntuple_entry orderkey = kmr_nth_ntuple(u, 0);
	struct kmr_ntuple_entry custkey = kmr_nth_ntuple(u, 1);

	kmr_reset_ntuple(k, 1, 0);
	kmr_put_ntuple_entry(mr, k, (int)sizeof(kbuf), custkey);
	kmr_reset_ntuple(v, 1, output);
	kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), orderkey);
	add_record(kvo, k, v);
    }
    return MPI_SUCCESS;
}

static int
q13_join_c_o(const struct kmr_kv_box kv[], const long n,
	     const KMR_KVS *kvs, KMR_KVS *kvo, void *p)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    int inputs[2] = {TAB_C, TAB_Q13_O1};
    int output = TAB_Q13_CO0;
    /*struct RECORD *dx = find_description((enum TABLE)output);*/

    KMR *mr = kvo->c.mr;

    struct kmr_ntuple **vv[2];
    long cnt[2];
    kmr_separate_ntuples(kvo->c.mr, kv, n, vv, cnt, inputs, 1);
    /*fprintf(stderr, "prod %ld x %ld\n", cnt[0], cnt[1]); fflush(0);*/
    assert(cnt[0] == 1);

    long count = cnt[1];

    struct kmr_ntuple *u0 = vv[0][0];
    struct kmr_ntuple_entry custkey = kmr_nth_ntuple(u0, 0);
    assert(custkey.len == sizeof(long));

    kmr_reset_ntuple(k, 1, 0);
    kmr_put_ntuple(mr, k, (int)sizeof(kbuf), &count, sizeof(long));
    kmr_reset_ntuple(v, 1, output);
    kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), custkey);
    add_record(kvo, k, v);

    free(vv[0]);
    free(vv[1]);
    return MPI_SUCCESS;
}

static int
q13_join_co(const struct kmr_kv_box kv[], const long n,
	    const KMR_KVS *kvs, KMR_KVS *kvo, void *p)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    /*enum TABLE input = TAB_Q13_CO0;*/
    enum TABLE output = TAB_Q13_CO1;

    KMR *mr = kvo->c.mr;
    assert(kv[0].klen == sizeof(long));

    long count = kv[0].k.i;
    assert(n > 0);
    long custdist = n;

    assert(sizeof(uint64_t) == sizeof(long));
    uint64_t becustdist = htonll_((uint64_t)(-custdist));
    uint64_t becount = htonll_((uint64_t)(-count));

    kmr_reset_ntuple(k, 2, 0);
    kmr_put_ntuple_long(mr, k, (int)sizeof(kbuf), (long)becustdist);
    kmr_put_ntuple_long(mr, k, (int)sizeof(kbuf), (long)becount);
    kmr_reset_ntuple(v, 2, output);
    kmr_put_ntuple_long(mr, v, (int)sizeof(vbuf), count);
    kmr_put_ntuple_long(mr, v, (int)sizeof(vbuf), custdist);
    add_record(kvo, k, v);

    return MPI_SUCCESS;
}

static KMR_KVS *
q13(KMR *mr, struct RUN *run)
{
    _Bool pushoff = ((run->pushoff == 0) ? 0 : 1);

    if (pushoff) {
	if (mr->rank == 0) {printf("q13 (with push-off)...\n"); fflush(0);}
    } else {
	if (mr->rank == 0) {printf("q13...\n"); fflush(0);}
    }

    /*(O)*/

    if (mr->rank == 0) {printf("q13 (o)...\n"); fflush(0);}

    KMR_KVS *o1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(O0, o1, 0, kmr_noopt, q13_select_by_string);
    } else {
	scan_table_files(o1, TAB_O, q13_select_by_string, 0, run);
    }

    pcount(o1, 0, "select (o)", 1);

    /*(C+O)*/

    if (run->load_tables_in_advance) {
	/*empty*/
    } else {
	KMR_KVS *c0 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
	scan_table_files(c0, TAB_C, 0, 0, run);
    }

    KMR_KVS *co2 = JOIN2(C0, o1, KMR_KV_INTEGER,
			 q13_join_c_o, 0, "c+o", pushoff);

    KMR_KVS *co4 = JOIN1(co2, KMR_KV_OPAQUE,
			 q13_join_co, 0, "c+o", 0);

    KMR_KVS *co5 = CREATE_KVS(mr, KMR_KV_OPAQUE, 0);
    kmr_sort(co4, co5, kmr_noopt);

    return co5;
}

/* ================================================================ */

/* QUERY (Q21)

   VALIDATION-RUN PARAMETERS (NATION=SAUDI ARABIA)

   [QUERY#0]

   select: TBL0(l1) = *

   from:
   l2 = lineitem

   where:
   l2.l_orderkey = l1.l_orderkey
   && l2.l_suppkey <> l1.l_suppkey

   [QUERY#1]

   select: TBL1(l1) = *

   from:
   l3 = lineitem

   where:
   l3.l_orderkey = l1.l_orderkey
   && l3.l_suppkey <> l1.l_suppkey
   && l3.l_receiptdate > l3.l_commitdate

   [QUERY#2]

   select: (s_name, numwait)
   numwait = count(*)

   from:
   supplier,
   l1 = lineitem,
   orders,
   nation

   where:
   s_suppkey = l1.l_suppkey
   and o_orderkey = l1.l_orderkey
   and o_orderstatus = 'F'
   and l1.l_receiptdate > l1.l_commitdate
   and exists (TBL0(l1))
   and not exists (TBL1(l1))
   and s_nationkey = n_nationkey
   and n_name = 'SAUDI ARABIA'

   group-by: s_name
   order-by: (numwait descending, s_name)
   where:
   rownum <= 100

   [SCHEDULE]

   (N1):
   select: n_name = 'SAUDI ARABIA'
   output N1 = {n_nationkey*}

   (N+S):
   select: s_nationkey = n_nationkey
   output: NS (:TAB_Q21_NS) = {s_suppkey*, s_name}

   (L1):
   select: l1.l_receiptdate > l1.l_commitdate
   output: L1 = {l_orderkey, l_suppkey*}

   (L1+NS):
   select: s_suppkey = l1.l_suppkey
   output: LNS (:TAB_Q21_LNS) = {l_orderkey*, l_suppkey, s_name}

   (O1):
   select o_orderstatus = 'F'
   output: O1 = {o_orderkey*}

   (LNS+O):
   select: o_orderkey = l1.l_orderkey
   output: LNOS0 (:TAB_Q21_LNS) = {l_orderkey*, l_suppkey, s_name}

   (COPY L TWICE):

   (L2):
   output: L2 = {l2.l_orderkey*, l2.l_suppkey}

   (LNOS0+L2):
   exists: l1.l_orderkey = l2.l_orderkey && l1.l_suppkey <> l2.l_suppkey
   output: LNOS2 (:TAB_Q21_LNS) = {l_orderkey*, l_suppkey, s_name}

   (L3):
   select: l3.l_receiptdate > l3.l_commitdate
   output: L3 = {l3.l_orderkey*, l3.l_suppkey}

   (LNOS2+L3):
   not-exists: l3.l_orderkey = l1.l_orderkey && l3.l_suppkey <> l1.l_suppkey
   output: NAME = {s_name}

   (NUMWAIT):
   select: s_name
   let: numwait = count(*)
   output: NUMWAIT = {-numwait*, s_name}

   (SORT):
   order-by: (numwait descending, s_name)
   filetr: (rownum <= 100) */

static struct PRODUCT q21_join_n_s = {
    .inputs = {TAB_Q21_N1, TAB_S},
    .output = TAB_Q21_NS,
    /*{s_suppkey*, s_name}*/
    .ncolumns = 2,
    .columns = {{0, SND}, {1, SND}},
    .nkeys = 1,
    .keys = {{0, SND}},
    .trace_product = 0
};

static struct PRODUCT q21_join_l_ns = {
    .inputs = {TAB_Q21_L1, TAB_Q21_NS},
    .output = TAB_Q21_LNS,
    /*{l_orderkey*, l_suppkey, s_name}*/
    .ncolumns = 3,
    .columns = {{0, FST}, {1, FST}, {1, SND}},
    .nkeys = 1,
    .keys = {{0, FST}},
    .trace_product = 0
};

static struct PRODUCT q21_join_lns_o = {
    .inputs = {TAB_Q21_LNS, TAB_Q21_O1},
    .output = TAB_Q21_LNS,
    /*{l_orderkey*, l_suppkey, s_name}*/
    .ncolumns = 3,
    .columns = {{0, FST}, {1, FST}, {2, FST}},
    .nkeys = 1,
    .keys = {{0, FST}},
    .trace_product = 0
};

static int
q21_select_n_by_name(const struct kmr_kv_box kv0,
		     const KMR_KVS *kvi, KMR_KVS *kvo,
		     void *p, const long i)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_N;
    enum TABLE output = TAB_Q21_N1;
    /*{n_nationkey*}*/
    struct RECORD *d = find_description(input);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u = (void *)kv0.v.p;

    assert(d->columns[1].field == F_TEXT);
    struct kmr_ntuple_entry n_name = kmr_nth_ntuple(u, 1);
    char *s0 = "SAUDI ARABIA";
    size_t len = strlen(s0);
    if (((size_t)n_name.len == len)
	&& (strncmp((char *)n_name.p, s0, len) == 0)) {
	struct kmr_ntuple_entry n_nationkey = kmr_nth_ntuple(u, 0);

	kmr_reset_ntuple(k, 1, 0);
	kmr_put_ntuple_entry(mr, k, (int)sizeof(kbuf), n_nationkey);
	kmr_reset_ntuple(v, 1, output);
	kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), n_nationkey);
	add_record(kvo, k, v);
    }
    return MPI_SUCCESS;
}

static int
q21_select_l1_by_date(const struct kmr_kv_box kv0, const KMR_KVS *kvi,
		      KMR_KVS *kvo, void *p, const long i)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_L;
    enum TABLE output = TAB_Q21_L1;
    struct RECORD *d = find_description(input);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u = (void *)kv0.v.p;

    time_t receiptdate = get_date_column(u, d, "l_receiptdate");
    time_t commitdate = get_date_column(u, d, "l_commitdate");
    if (receiptdate > commitdate) {
	struct kmr_ntuple_entry orderkey = column_by_name(u, d, "l_orderkey");
	struct kmr_ntuple_entry suppkey = column_by_name(u, d, "l_suppkey");

	kmr_reset_ntuple(k, 1, 0);
	kmr_put_ntuple_entry(mr, k, (int)sizeof(kbuf), suppkey);
	kmr_reset_ntuple(v, 2, output);
	kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), orderkey);
	kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), suppkey);
	add_record(kvo, k, v);
    }

    return MPI_SUCCESS;
}

static int
q21_select_l3_by_date(const struct kmr_kv_box kv0, const KMR_KVS *kvi,
		      KMR_KVS *kvo, void *p, const long i)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_L;
    enum TABLE output = TAB_Q21_L3;
    struct RECORD *d = find_description(input);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u = (void *)kv0.v.p;

    time_t receiptdate = get_date_column(u, d, "l_receiptdate");
    time_t commitdate = get_date_column(u, d, "l_commitdate");
    if (receiptdate > commitdate) {
	struct kmr_ntuple_entry orderkey = column_by_name(u, d, "l_orderkey");
	struct kmr_ntuple_entry suppkey = column_by_name(u, d, "l_suppkey");

	kmr_reset_ntuple(k, 1, 0);
	kmr_put_ntuple_entry(mr, k, (int)sizeof(kbuf), orderkey);
	kmr_reset_ntuple(v, 2, output);
	kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), orderkey);
	kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), suppkey);
	add_record(kvo, k, v);
    }

    return MPI_SUCCESS;
}

static struct SELECT q21_copy_l = {
    .input = TAB_L,
    .output = TAB_Q21_L3,
    .ncolumns = 2,
    .columns = {0, 2},
    .nkeys = 1,
    .keys = {0}
};

static int
q21_select_o_by_flag(const struct kmr_kv_box kv0, const KMR_KVS *kvi,
		     KMR_KVS *kvo, void *p, const long i)
{
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_O;
    enum TABLE output = TAB_Q21_O1;
    struct RECORD *d = find_description(input);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple *u = (void *)kv0.v.p;
    struct kmr_ntuple_entry status = column_by_name(u, d, "o_orderstatus");
    char *s0 = (char *)status.p;
    if (status.len == 1 && s0[0] == 'F') {
	struct kmr_ntuple_entry orderkey = column_by_name(u, d, "o_orderkey");

	kmr_reset_ntuple(v, 1, output);
	kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), orderkey);

	struct kmr_kv_box kv = {
	    .klen = orderkey.len,
	    .k.p = orderkey.p,
	    .vlen = kmr_size_ntuple(v),
	    .v.p = (void *)v
	};
	kmr_add_kv(kvo, kv);
    }

    return MPI_SUCCESS;
}

static int
q21_join_lnos_l2(const struct kmr_kv_box kv[], const long n,
		 const KMR_KVS *kvs, KMR_KVS *kvo, void *p)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    //char vbuf[RECORD_SIZE];
    //struct kmr_ntuple *v = (void *)vbuf;

    int inputs[] = {TAB_Q21_LNS, TAB_Q21_L3};
    //enum TABLE output = TAB_Q21_LNS;
    struct RECORD *d0 = find_description((enum TABLE)inputs[0]);
    struct RECORD *d1 = find_description((enum TABLE)inputs[1]);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple **vv[2];
    long cnt[2];
    kmr_separate_ntuples(mr, kv, n, vv, cnt, inputs, 1);

    for (long i0 = 0; i0 < cnt[0]; i0++) {
	struct kmr_ntuple *u0 = (void *)vv[0][i0];
	long suppkey0 = get_int_column_by_index(u0, d0->columns, 1);
	_Bool exists = 0;
	for (long i1 = 0; i1 < cnt[1]; i1++) {
	    struct kmr_ntuple *u1 = (void *)vv[1][i1];
	    long suppkey1 = get_int_column_by_index(u1, d1->columns, 1);
	    if (suppkey0 != suppkey1) {
		exists = 1;
		break;
	    }
	}
	if (exists) {
	    struct kmr_ntuple_entry orderkey = kmr_nth_ntuple(u0, 0);
	    kmr_reset_ntuple(k, 1, 0);
	    kmr_put_ntuple_entry(mr, k, (int)sizeof(kbuf), orderkey);
	    add_record(kvo, k, u0);
	}
    }

    return MPI_SUCCESS;
}

static int
q21_join_lnos_l3(const struct kmr_kv_box kv[], const long n,
		 const KMR_KVS *kvs, KMR_KVS *kvo, void *p)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    int inputs[] = {TAB_Q21_LNS, TAB_Q21_L3};
    //enum TABLE output = TAB_Q21_NAME;
    /*{s_name*, s_name}*/
    struct RECORD *d0 = find_description((enum TABLE)inputs[0]);
    struct RECORD *d1 = find_description((enum TABLE)inputs[1]);

    KMR *mr = kvo->c.mr;
    struct kmr_ntuple **vv[2];
    long cnt[2];
    kmr_separate_ntuples(mr, kv, n, vv, cnt, inputs, 1);

    for (long i0 = 0; i0 < cnt[0]; i0++) {
	struct kmr_ntuple *u0 = (void *)vv[0][i0];
	long suppkey0 = get_int_column_by_index(u0, d0->columns, 1);
	_Bool nonexists = 1;
	for (long i1 = 0; i1 < cnt[1]; i1++) {
	    struct kmr_ntuple *u1 = (void *)vv[1][i1];
	    long suppkey1 = get_int_column_by_index(u1, d1->columns, 1);
	    if (suppkey0 != suppkey1) {
		nonexists = 0;
		break;
	    }
	}
	if (nonexists) {
	    struct kmr_ntuple_entry name = kmr_nth_ntuple(u0, 2);
	    kmr_reset_ntuple(k, 1, 0);
	    kmr_put_ntuple_entry(mr, k, (int)sizeof(kbuf), name);
	    kmr_reset_ntuple(v, 1, TAB_Q21_NAME);
	    kmr_put_ntuple_entry(mr, v, (int)sizeof(kbuf), name);
	    add_record(kvo, k, v);
	}
    }

    return MPI_SUCCESS;
}

static int
q21_join_numwait(const struct kmr_kv_box kv[], const long n,
		 const KMR_KVS *kvs, KMR_KVS *kvo, void *p)
{
    char kbuf[RECORD_SIZE];
    struct kmr_ntuple *k = (void *)kbuf;
    char vbuf[RECORD_SIZE];
    struct kmr_ntuple *v = (void *)vbuf;

    enum TABLE input = TAB_Q21_NAME;
    enum TABLE output = TAB_Q21_NUMWAIT;
    /*{-numwait*, s_name}*/
    struct RECORD *d = find_description((enum TABLE)input);

    KMR *mr = kvo->c.mr;

    struct kmr_ntuple *u = (void *)kv[0].v.p;
    struct kmr_ntuple_entry s_name = column_by_name(u, d, "s_name");

    long negnumwait = -n;

    char nbuf[NAME_SIZE];
    assert(s_name.len <= NAME_SIZE);
    memset(nbuf, 0, sizeof(nbuf));
    memcpy(nbuf, s_name.p, s_name.len);

    kmr_reset_ntuple(k, 2, 0);
    kmr_put_ntuple(mr, k, (int)sizeof(kbuf), &negnumwait, sizeof(long));
    kmr_put_ntuple(mr, k, (int)sizeof(kbuf), nbuf, NAME_SIZE);
    kmr_reset_ntuple(v, 2, output);
    kmr_put_ntuple_entry(mr, v, (int)sizeof(vbuf), s_name);
    kmr_put_ntuple(mr, v, (int)sizeof(vbuf), &n, (int)sizeof(long));
    add_record(kvo, k, v);

    return MPI_SUCCESS;
}

static KMR_KVS *
q21(KMR *mr, struct RUN *run)
{
    _Bool pushoff = ((run->pushoff == 0) ? 0 : 1);
    struct kmr_option inspect = {.inspect = 1};

    if (pushoff) {
	if (mr->rank == 0) {printf("q21 (with push-off)...\n"); fflush(0);}
    } else {
	if (mr->rank == 0) {printf("q21...\n"); fflush(0);}
    }

    /*(N)*/

    KMR_KVS *n1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(N0, n1, 0, kmr_noopt, q21_select_n_by_name);
    } else {
	scan_table_files(n1, TAB_N, q21_select_n_by_name, 0, run);
    }

    KMR_KVS *s1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    int nth = 3; /*s_nationkey*/
    if (run->load_tables_in_advance) {
	kmr_map(S0, s1, &nth, kmr_noopt, key_by_nth);
    } else {
	scan_table_files(s1, TAB_S, key_by_nth, &nth, run);
    }

    /*(N+S)*/

    KMR_KVS *ns0 = JOINP(n1, s1, KMR_KV_OPAQUE,
			 &q21_join_n_s, "n+s", pushoff);

    /*(L1+NS)*/

    if (run->load_tables_in_advance) {
	/*empty*/
    } else {
	KMR_KVS *l0 = CREATE_KVS(mr, KMR_KV_OPAQUE, 0);
	scan_table_files(l0, TAB_L, 0, 0, run);
    }

    KMR_KVS *l1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    kmr_map(L0, l1, 0, inspect, q21_select_l1_by_date);

    pcount(l1, 0, "l1", 1);

    KMR_KVS *lns0 = JOINP(l1, ns0, KMR_KV_OPAQUE,
			  &q21_join_l_ns, "l+ns", pushoff);

    /*(O1)*/

    KMR_KVS *o1 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    if (run->load_tables_in_advance) {
	kmr_map(O0, o1, 0, kmr_noopt, q21_select_o_by_flag);
    } else {
	scan_table_files(o1, TAB_O, q21_select_o_by_flag, 0, run);
    }

    pcount(o1, 0, "o1", 1);

    /*(LNS+O)*/

    KMR_KVS *lnos0 = JOINP(lns0, o1, KMR_KV_OPAQUE,
			   &q21_join_lns_o, "lns+o", pushoff);

    //dump_table(lnos0, TAB_Q21_LNS);

    /*(L2+LNOS)*/

    KMR_KVS *l2 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    kmr_map(L0, l2, &q21_copy_l, inspect, select_by_fields);

    KMR_KVS *lnos2 = JOIN2(lnos0, l2, KMR_KV_OPAQUE,
			   q21_join_lnos_l2, 0, "l2+lnos", pushoff);

    /*(LNOS+L3)*/

    KMR_KVS *l3 = CREATE_KVS(mr, KMR_KV_OPAQUE, pushoff);
    kmr_map(L0, l3, 0, inspect, q21_select_l3_by_date);
    kmr_free_kvs(L0);

    KMR_KVS *name0 = JOIN2(lnos2, l3, KMR_KV_OPAQUE,
			   q21_join_lnos_l3, 0, "l3+lnos", pushoff);

    //dump_table(name0, TAB_Q21_NAME);

    /*(NUMWAIT)*/

    KMR_KVS *ex2 = JOIN1(name0, KMR_KV_OPAQUE,
			 q21_join_numwait, 0, "numwait", 0);

    /*(SORT)*/

    KMR_KVS *ex3 = kmr_create_kvs(mr, KMR_KV_OPAQUE, KMR_KV_OPAQUE);
    kmr_sort(ex2, ex3, kmr_noopt);

    pcount(ex3, 0, "sort", 1);
    //dump_table(ex3, TAB_Q21_NUMWAIT);

    KMR_KVS *ex4 = kmr_create_kvs(mr, KMR_KV_OPAQUE, KMR_KV_OPAQUE);
    struct kmr_option opt = {.nothreading = 1};
    kmr_choose_first_part(ex3, ex4, 100, opt);

    pcount(ex4, 0, "choose", 1);

    return ex4;
}

/* ================================================================ */

static int
atoi_safe(char *s, int ok[], int n, char *m)
{
    int v;
    char gomi[4];
    int cc = sscanf(s, "%d%c", &v, gomi);
    if (cc != 1) {
	fprintf(stderr, "%s.  Not integer (%s).\n", m, s);
	return -1;
    }
    for (int i = 0; i < n; i++) {
	if (ok[i] == v) {
	    return v;
	}
    }
    fprintf(stderr, "%s.  Not acceptable (%d).\n", m, v);
    return -1;
}

struct RUN runs[50];
int nruns = 0;

int
main(int argc, char *argv[])
{
    assert(sizeof(long) == sizeof(time_t));

    /* For localtime()/mktime(). */

    setenv("TZ", "UTC", 1);
    tzset();

    char *helpstring = ("%s directory-of-tables [-C -F -P]"
			" query [options] query [options]...\n"
			"  query={7,9,10,13,21}\n"
			"  options: [-p po -b sz -a -g -r -s]\n"
			"  -p po: po={0,1,2}, push-off setting\n"
			"  -b sz: block size for push-off (in KB)\n"
			"  -a: scan tables in advance\n"
			"  -g: stop push-off at the end\n"
			"  -r: redistribute table entries\n"
			"  -s: use small block size\n"
			"  -C: report count in messages\n"
			"  -F: report file read time\n"
			"  -P: report push-off statistics\n");

    int nprocs, rank, thlv;
    /*MPI_Init(&argc, &argv);*/
    MPI_Init_thread(&argc, &argv, MPI_THREAD_SERIALIZED, &thlv);
    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    if (!(argc >= 3)) {
	if (rank == 0) {
	    fprintf(stderr, helpstring, argv[0]);
	}
	MPI_Finalize();
	return 0;
    }

#if 0
    /* LET DUMP CORE ONLY AT RANK ZERO. */
    if (rank != 0) {
	struct rlimit core = {.rlim_cur = 0, .rlim_max = 0};
	int cc = setrlimit(RLIMIT_CORE, &core);
	if (cc != 0) {perror("setrlimit(core=0)");}
	/* CONTINUE RUN. */
    }
#endif

    char *directory = argv[1];

    xxx_optind = 2;
    int c;
    while ((c = xxx_getopt(argc, argv, "hCFP")) != -1) {
	switch (c) {
	case 'h':
	{
	    if (rank == 0) {
		fprintf(stderr, helpstring, argv[0]);
		fflush(0);
	    }
	    MPI_Finalize();
	    return 0;
	}

	case 'C':
	    report_count_in_messages = 1;
	    break;
	case 'F':
	    report_time_to_read = 1;
	    break;
	case 'P':
	    report_pushoff_statistics = 1;
	    break;

	case '?':
	    if (rank == 0) {
		fprintf(stderr, "Unknown option (%c)\n", xxx_optopt);
		fprintf(stderr, helpstring, argv[0]);
		fflush(0);
	    }
	    MPI_Finalize();
	    return 0;
	}
    }

    if (xxx_optind >= argc) {
	fprintf(stderr, helpstring, argv[0]);
	fflush(0);
	MPI_Finalize();
	return 0;
    }

    while (xxx_optind < argc) {
	int qset[] = {7, 9, 10, 13, 21};
	int nq = (int)(sizeof(qset) / sizeof(qset[0]));
	int query = atoi_safe(argv[xxx_optind], qset, nq, "Bad query");
	if (query == -1) {
	    if (rank == 0) {
		fprintf(stderr, helpstring, argv[0]);
		fflush(0);
	    }
	    MPI_Finalize();
	    return 0;
	}

	runs[nruns].query = query;
	runs[nruns].pushoff = 0;
	runs[nruns].load_tables_in_advance = 0;
	runs[nruns].hang_out_communication = 0;
	runs[nruns].redistribute_loaded_tables = 0;
	runs[nruns].use_small_block_size = 0;
	runs[nruns].pushoff_block_size_in_kilo = 64;

	xxx_optind++;
	while ((c = xxx_getopt(argc, argv, "p:b:agrs")) != -1) {
	    switch (c) {
	    case 'p':
	    {
		int okset[] = {0, 1, 2};
		int nokset = (int)(sizeof(okset) / sizeof(okset[0]));
		int pushoffv = atoi_safe(xxx_optarg, okset, nokset,
					 "Bad pushoff");
		if (pushoffv == -1) {
		    if (rank == 0) {
			fprintf(stderr, helpstring, argv[0]);
			fflush(0);
		    }
		    MPI_Finalize();
		    return 0;
		}
		runs[nruns].pushoff = pushoffv;
		break;
	    }

	    case 'b':
	    {
		int bs = atoi(xxx_optarg);
		runs[nruns].pushoff_block_size_in_kilo = (size_t)bs;
		break;
	    }

	    case 'a':
		runs[nruns].load_tables_in_advance = 1;
		break;
	    case 'g':
		runs[nruns].hang_out_communication = 1;
		break;
	    case 'r':
		runs[nruns].redistribute_loaded_tables = 1;
		break;
	    case 's':
		runs[nruns].use_small_block_size = 1;
		break;

	    case '?':
		if (rank == 0) {
		    fprintf(stderr, "Unknown option (%c)\n", xxx_optopt);
		    fprintf(stderr, helpstring, argv[0]);
		    fflush(0);
		}
		MPI_Finalize();
		return 0;
	    }
	}

	nruns++;
	if (nruns >= (int)(sizeof(runs)/sizeof(runs[0]))) {
	    if (rank == 0) {
		fprintf(stderr, "run list too long\n");
		fprintf(stderr, helpstring, argv[0]);
		fflush(0);
	    }
	    MPI_Finalize();
	    return 0;
	}
    }

    if (rank == 0) {
	char ss[88];
	int sc = 0;
	sc += snprintf((ss + sc), (sizeof(ss) - (size_t)sc),
		       "Running (%d runs) with:", nruns);
	for (int i = 0; i < nruns; i++) {
	    sc += snprintf((ss + sc), (sizeof(ss) - (size_t)sc),
			   " %d", runs[i].query);
	}
	snprintf((ss + sc), (sizeof(ss) - (size_t)sc), "\n");
	printf("%s", ss);
	fflush(0);
    }

    kmr_init();

    /* Load table files into memory. */

    {
	enum TABLE t[] = {TAB_N, TAB_R, TAB_P, TAB_S,
			  TAB_H, TAB_C, TAB_O, TAB_L};
	int nt = (int)(sizeof(t) / sizeof(t[0]));
	load_input_tables(nprocs, rank, directory, t, nt);
    }

    /* Initialize fast-notice once. */

    {
	kmr_init_pushoff_fast_notice_(MPI_COMM_WORLD, 1);

	KMR *mr = kmr_create_context(MPI_COMM_WORLD, MPI_INFO_NULL, 0);
	mr->pushoff_fast_notice = 1;
	kmr_check_pushoff_fast_notice_(mr);
	kmr_free_context(mr);
    }

    for (int i = 0; i < nruns; i++) {
	int query = runs[i].query;
	_Bool pushoff = ((runs[i].pushoff == 0) ? 0 : 1);
	//load_tables_in_advance = runs[i].load_tables_in_advance;
	//redistribute_loaded_tables = runs[i].redistribute_loaded_tables;

	KMR *mr = kmr_create_context(MPI_COMM_WORLD, MPI_INFO_NULL, 0);
	mr->pushoff_hang_out = runs[i].hang_out_communication;
	mr->pushoff_fast_notice = (runs[i].pushoff == 2);
	mr->pushoff_stat = report_pushoff_statistics;
	if (runs[i].use_small_block_size) {
	    mr->preset_block_size = (64 * 1024);
	} else {
	    mr->preset_block_size = (64 * 1024 * 1024);
	}
	if (runs[i].pushoff_block_size_in_kilo != 0) {
	    mr->pushoff_block_size = (runs[i].pushoff_block_size_in_kilo
				      * (size_t)1024);
	}

	MPI_Barrier(MPI_COMM_WORLD);
	usleep(50 * 1000);
	if (rank == 0) {
	    fprintf(stdout, "Run Q%d (pushoff=%d fast_notice=%d)\n",
		    query, pushoff, mr->pushoff_fast_notice);
	    fprintf(stderr, "Run Q%d (pushoff=%d fast_notice=%d)\n",
		    query, pushoff, mr->pushoff_fast_notice);
	    fflush(0);
	}

	usleep(50 * 1000);
	if (rank == 0) {
	    printf("OPTION: (-p) pushoff=%d fast_notice=%d\n",
		   pushoff, mr->pushoff_fast_notice);
	    printf("OPTION: (-a) load_tables_in_advance=%d\n",
		   runs[i].load_tables_in_advance);
	    printf("OPTION: (-g) pushoff_hang_out=%d\n",
		   mr->pushoff_hang_out);
	    printf("OPTION: (-r) redistribute_loaded_tables=%d\n",
		   runs[i].redistribute_loaded_tables);
	    printf("OPTION: (-s) preset_block_size=%zd\n",
		   mr->preset_block_size);
	    printf("OPTION: (-b) pushoff_block_size=%zd\n",
		   mr->pushoff_block_size);
	    printf("OPTION: (-C) report_count_in_messages=%d\n",
		   report_count_in_messages);
	    printf("OPTION: (-F) report_time_to_read=%d\n",
		   report_time_to_read);
	    printf("OPTION: (-P) report_pushoff_statistics=%d\n",
		   report_pushoff_statistics);
	    fflush(0);
	}

	double t0 = 0.0;
	double t1 = 0.0;
	KMR_KVS *r = 0;
	enum TABLE tbl = TAB_NIL;
	switch (query) {
	case 7:
	    if (runs[i].load_tables_in_advance) {
		enum TABLE t7[] = {TAB_N, TAB_S, TAB_C, TAB_O, TAB_L};
		/*TAB_R,TAB_P,TAB_H;*/
		int nt7 = (int)(sizeof(t7) / sizeof(t7[0]));
		scan_table_files_in_advance(mr, t7, nt7, &runs[i]);
	    }
	    MPI_Barrier(MPI_COMM_WORLD);
	    t0 = wtime();
	    r = q7(mr, &runs[i]);
	    tbl = TAB_Q7_REVENUE;
	    MPI_Barrier(MPI_COMM_WORLD);
	    t1 = wtime();
	    break;

	case 9:
	    if (runs[i].load_tables_in_advance) {
		enum TABLE t9[] = {TAB_N, TAB_P, TAB_S, TAB_H, TAB_O, TAB_L};
		/*TAB_R,TAB_C;*/
		int nt9 = (int)(sizeof(t9) / sizeof(t9[0]));
		scan_table_files_in_advance(mr, t9, nt9, &runs[i]);
	    }
	    MPI_Barrier(MPI_COMM_WORLD);
	    t0 = wtime();
	    r = q9(mr, &runs[i]);
	    tbl = TAB_Q9_AMOUNT;
	    MPI_Barrier(MPI_COMM_WORLD);
	    t1 = wtime();
	    break;

	case 10:
	    if (runs[i].load_tables_in_advance) {
		enum TABLE t10[] = {TAB_N, TAB_C, TAB_O, TAB_L};
		/*TAB_R,TAB_P,TAB_S,TAB_H;*/
		int nt10 = (int)(sizeof(t10) / sizeof(t10[0]));
		scan_table_files_in_advance(mr, t10, nt10, &runs[i]);
	    }
	    MPI_Barrier(MPI_COMM_WORLD);
	    t0 = wtime();
	    r = q10(mr, &runs[i]);
	    tbl = TAB_Q10_CLNO1;
	    MPI_Barrier(MPI_COMM_WORLD);
	    t1 = wtime();
	    break;

	case 13:
	    if (runs[i].load_tables_in_advance) {
		enum TABLE t13[] = {TAB_C, TAB_O, TAB_L};
		/*TAB_N,TAB_R,TAB_P,TAB_S,TAB_H,TAB_L;*/
		int nt13 = (int)(sizeof(t13) / sizeof(t13[0]));
		scan_table_files_in_advance(mr, t13, nt13, &runs[i]);
	    }
	    MPI_Barrier(MPI_COMM_WORLD);
	    t0 = wtime();
	    r = q13(mr, &runs[i]);
	    tbl = TAB_Q13_CO1;
	    MPI_Barrier(MPI_COMM_WORLD);
	    t1 = wtime();
	    break;

	case 21:
	    if (runs[i].load_tables_in_advance) {
		enum TABLE t21[] = {TAB_N, TAB_S, TAB_O, TAB_L};
		/*TAB_R,TAB_P,TAB_H,TAB_C;*/
		int nt21 = (int)(sizeof(t21) / sizeof(t21[0]));
		scan_table_files_in_advance(mr, t21, nt21, &runs[i]);
	    }
	    MPI_Barrier(MPI_COMM_WORLD);
	    t0 = wtime();
	    r = q21(mr, &runs[i]);
	    tbl = TAB_Q21_NUMWAIT;
	    MPI_Barrier(MPI_COMM_WORLD);
	    t1 = wtime();
	    break;
	}

	if (rank == 0) {printf("Run Q%d in %f sec\n", query, (t1 - t0));}

	if (r != 0) {
	    long rcnt;
	    kmr_get_element_count(r, &rcnt);
	    if (mr->rank == 0) {
		printf("result count=%ld\n", rcnt);
		fflush(0);
	    }
	    dump_table(r, tbl);

	    kmr_free_kvs(r);
	}

	if (pushoff && mr->pushoff_stat) {
	    char *s = "STATISTICS on push-off kvs:\n";
	    kmr_print_statistics_on_pushoff(mr, s);
	}

	kmr_free_context(mr);
    }

    kmr_fin_pushoff_fast_notice_();
    kmr_fin();
    MPI_Finalize();

    return 0;
}
